{
  "name": "taskcluster-client",
  "version": "0.15.2",
  "author": {
    "name": "Jonas Finnemann Jensen",
    "email": "jopsen@gmail.com"
  },
  "description": "Client for interfacing taskcluster components",
  "license": "MPL-2.0",
  "scripts": {
    "test": "./test/runtests.sh"
  },
  "browser": "./client.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/taskcluster/taskcluster-client.git"
  },
  "dependencies": {
    "lodash": "2.4.1",
    "debug": "1.0.4",
    "superagent": "0.18.2",
    "superagent-promise": "0.1.2",
    "superagent-hawk": "0.0.4",
    "amqplib": "0.2.1",
    "slugid": "1.0.2",
    "promise": "5.0.0",
    "hawk": "2.2.3"
  },
  "devDependencies": {
    "mocha": "1.21.4",
    "commander": "2.3.0",
    "cliff": "0.1.8",
    "taskcluster-base": "0.4.6",
    "browserify": "5.10.1",
    "mocha-phantomjs": "3.5.0"
  },
  "readme": "# TaskCluster Client [![Build Status](https://travis-ci.org/taskcluster/taskcluster-client.svg?branch=master)](https://travis-ci.org/taskcluster/taskcluster-client)\n_A taskcluster client library for node.js._\n\nThis client library is generated from the auto-generated API reference.\nYou can create a Client class from a JSON reference object at runtime using\n`taskcluster.createClient(reference)`. But there is also a set of builtin\nreferences from which Client classes are already constructed.\n\n## Calling API End-Points\nTo invoke an API end-point instantiate a taskcluster Client class, these are\nclasses can be created from a JSON reference object, but a number of them are\nalso built-in to this library. In the following example we instantiate an\ninstance of the `Queue` Client class and use to to create a task.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Instantiate the Queue Client class\nvar queue = new taskcluster.Queue({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n\n// Create task using the queue client\nvar taskId = '...';\nqueue.createTask(taskId, task).then(function(result) {\n  // status is a task status structure\n  console.log(result.status);\n});\n```\n\nThe `payload` parameter is always a JSON object as documented by the REST API\ndocumentation. The methods always returns a _promise_ for the response JSON\nobject as documented in the REST API documentation.\n\n## Listening for Events\nMany TaskCluster components publishes messages about current events over AMQP.\nThe JSON reference object also contains meta-data about declared AMQP topic\nexchanges and their routing key construction. This is designed to make it easy\nto construct routing key patterns and parse routing keys from incoming messages.\n\nThe following example create a `listener` and instantiate an instance of\nthe Client class `QueueEvents` which we use to find the exchange and create\na routing pattern to listen for completion of a specific task. The\n`taskCompleted` method will construct a routing key pattern by using `*` or `#`\nfor missing entries, pending on whether or not they are single word or\nmulti-key entries.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Create a listener (this creates a queue on AMQP)\nvar listener = new taskcluster.Listener({\n  connectionString:   'amqp://...'\n});\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents();\n\n// Bind to task-completed events from queue that matches routing key pattern:\n//   'primary.<myTaskId>.*.*.*.*.*.#'\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n\n// Listen for messages\nlistener.on('message', function(message) {\n  message.exchange        // Exchange from which message came\n  message.payload         // Documented on docs.taskcluster.net\n  message.routingKey      // Message routing key in string format\n  message.routing.taskId  // Element from parsed routing key\n  message.routing.runId   // ...\n  message.redelivered     // True, if message has been nack'ed and requeued\n  message.routes          // List of CC'ed routes, without the `route.` prefix\n  return new Promise(...);\n});\n\n// Listen and consume events:\nlistener.resume().then(function() {\n  // Now listening\n});\n```\n\nTo bind to a custom routing-key like the task-specific routes that messages\nfrom the queue is CC'ed to, just provide the desired routing key to the\nmethod for exchange. See example below.\n\n```js\nvar RawRoutingPattern = 'route.task.specific.routing.key';\nlistener.bind(queueEvents.taskCompleted(RawRoutingPattern);\n```\n\n\n## Advanced Listening\n\nFor advanced queue usage the `connect` method can be used to\ncreate and bind the queue and return an associated\n[amqplib](http://www.squaremobius.net/amqp.node/doc/channel_api.html) channel:\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Create a listener (this creates a queue on AMQP)\nvar listener = new taskcluster.Listener({\n  connectionString:   'amqp://...'\n});\n\n// See: http://www.squaremobius.net/amqp.node/doc/channel_api.html\nvar channel = listener.connect().then(function(channel) {\n  return channel.consume(function(msg) {\n    channel.ack(msg);\n  });\n});\n```\n\nThe listener creates a AMQP queue, on the server side and subscribes to messages\non the queue. It's possible to use named queues, see details below. For details\non routing key entries refer to documentation on\n[docs.taskcluster.net](docs.taskcluster.net).\n\n**Remark,** API end-points and AMQP exchanges are typically documented in\nseparate reference files. For this reason they also have separate Client\nclasses, even if they are from the same component.\n\n## Documentation\nThe set of API entries listed below is generated from the builtin references.\nDetailed documentation with description, payload and result format details is\navailable on [docs.taskcluster.net](http://docs.taskcluster.net).\n\nOn the [documentation site](http://docs.taskcluster.net) entries often have a\n_signature_, you'll find that it matches the signatures below. Notice that all\nthe methods returns a promise. A method with `: void` also returns a promise,\nthat either resolves without giving a value or rejects with an error.\n\n<!-- START OF GENERATED DOCS -->\n\n### Methods in `taskcluster.Auth`\n```js\n// Create Auth client instance with default baseUrl:\n//  - https://auth.taskcluster.net/v1\nvar auth = new taskcluster.Auth(options);\n```\n * `auth.inspect(clientId) : result`\n * `auth.getCredentials(clientId) : result`\n\n### Methods in `taskcluster.Queue`\n```js\n// Create Queue client instance with default baseUrl:\n//  - https://queue.taskcluster.net/v1\nvar queue = new taskcluster.Queue(options);\n```\n * `queue.createTask(taskId, payload) : result`\n * `queue.getTask(taskId) : result`\n * `queue.defineTask(taskId, payload) : result`\n * `queue.scheduleTask(taskId) : result`\n * `queue.status(taskId) : result`\n * `queue.claimTask(taskId, runId, payload) : result`\n * `queue.reclaimTask(taskId, runId) : result`\n * `queue.claimWork(provisionerId, workerType, payload) : result`\n * `queue.reportCompleted(taskId, runId, payload) : result`\n * `queue.rerunTask(taskId) : result`\n * `queue.createArtifact(taskId, runId, name, payload) : result`\n * `queue.getArtifact(taskId, runId, name) : void`\n * `queue.getLastestArtifact(taskId, name) : void`\n * `queue.listArtifacts(taskId, runId) : result`\n * `queue.listLatestArtifacts(taskId) : result`\n * `queue.getPendingTasks(provisionerId) : void`\n * `queue.getAMQPConnectionString() : result`\n * `queue.ping() : void`\n\n### Methods in `taskcluster.Scheduler`\n```js\n// Create Scheduler client instance with default baseUrl:\n//  - https://scheduler.taskcluster.net/v1\nvar scheduler = new taskcluster.Scheduler(options);\n```\n * `scheduler.createTaskGraph(taskGraphId, payload) : result`\n * `scheduler.extendTaskGraph(taskGraphId, payload) : result`\n * `scheduler.status(taskGraphId) : result`\n * `scheduler.info(taskGraphId) : result`\n * `scheduler.inspect(taskGraphId) : result`\n * `scheduler.ping() : void`\n\n### Exchanges in `taskcluster.QueueEvents`\n```js\n// Create QueueEvents client instance with default exchangePrefix:\n//  - queue/v1/\nvar queueEvents = new taskcluster.QueueEvents(options);\n```\n * `queueEvents.taskDefined(routingKeyPattern) : binding-info`\n * `queueEvents.taskPending(routingKeyPattern) : binding-info`\n * `queueEvents.taskRunning(routingKeyPattern) : binding-info`\n * `queueEvents.artifactCreated(routingKeyPattern) : binding-info`\n * `queueEvents.taskCompleted(routingKeyPattern) : binding-info`\n * `queueEvents.taskFailed(routingKeyPattern) : binding-info`\n\n### Exchanges in `taskcluster.SchedulerEvents`\n```js\n// Create SchedulerEvents client instance with default exchangePrefix:\n//  - scheduler/v1/\nvar schedulerEvents = new taskcluster.SchedulerEvents(options);\n```\n * `schedulerEvents.taskGraphRunning(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphExtended(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphBlocked(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphFinished(routingKeyPattern) : binding-info`\n\n<!-- END OF GENERATED DOCS -->\n\n## Construct Urls\nYou can build a url for any request, but this feature is mostly useful for\nrequest that doesn't require any authentication. If you need authentication\ntake a look at the section on building signed urls, which is possible for all\n`GET` requests. To construct a url for a request use the `buildUrl` method, as\nillustrated in the following example:\n\n```js\n// Create queue instance\nvar queue = new taskcluster.Queue(...);\n\n// Build url to get a specific task\nvar url = queue.buildUrl(\n  queue.getTask,    // Method to build url for.\n  taskId            // First parameter for the method, in this case taskId\n);\n```\n\nPlease, note that the `payload` parameter cannot be encoded in urls. And must be\nsent when using a constructed urls. Again, this is not a problem as most methods\nthat takes a `payload` also requires authentication.\n\n\n## Construct Signed Urls\nIt's possible to build both signed urls for all `GET` requests. A signed url\ncontains a query-string parameter called `bewit`, this parameter holds\nexpiration time, signature and scope restrictions (if applied). The signature\ncovers the following parameters:\n\n  * Expiration time,\n  * Url and query-string, and\n  * scope restrictions (if applied)\n\nThese signed urls is very convenient if you want to grant somebody access to\nspecific resource without proxying the request or sharing your credentials.\nFor example it's fairly safe to provide someone with a signed url for a\nspecific artifact that is protected by a scope. See example below.\n\n```js\n// Create queue instance\nvar queue = new taskcluster.Queue(...);\n\n// Build signed url\nvar signedUrl = queue.buildSignedUrl(\n  queue.getArtifactFromRun,   // method to build signed url for.\n  taskId,                     // TaskId parameter\n  runId,                      // RunId parameter\n  artifactName,               // Artifact name parameter\n  {\n    expiration:     60 * 10   // Expiration time in seconds\n});\n```\n\nPlease, note that the `payload` parameter cannot be encoded in the signed url\nand must be sent as request payload. This should work fine, just remember that\nit's only possible to make signed urls for `GET` requests, which in most cases\ndon't take a payload.\n\nAlso please consider using a relatively limited expiration time, as it's not\npossible to retract a signed url without revoking your credentials.\nFor more technical details on signed urls, see _bewit_ urls in\n[hawk](https://github.com/hueniverse/hawk).\n\n## Create Client Class Dynamically\nYou can create a Client class from a reference JSON object as illustrated\nbelow:\n\n```js\nvar reference = {...}; // JSON from references.taskcluster.net/...\n\n// Create Client class\nvar MyClient = taskcluster.createClient(reference);\n\n// Instantiate an instance of MyClient\nvar myClient = new MyClient(options);\n\n// Make a request with a method on myClient\nmyClient.myMethod(arg1, arg2, payload).then(function(result) {\n  // ...\n});\n```\n\n## Configuration of API Invocations\nThere is a number of configuration options for Client which affects invocation\nof API end-points. These are useful if using a non-default server, for example\nwhen setting up a staging area or testing locally.\n\n### Configuring API BaseUrls\nIf you use the builtin API Client classes documented above you can configure\nthe `baseUrl` when creating an instance of the client. As illustrated below:\n\n```js\nvar auth = new taskcluster.Auth({\n  credentials:  {...},\n  baseUrl:      \"http://localhost:4040\" // Useful for development and testing\n});\n```\n\n### Configuring Credentials\nWhen creating an instance of a Client class the credentials can be provided\nin options. For example:\n```js\nvar auth = new taskcluster.Auth({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n```\n\nYou can also configure default options globally using\n`taskcluster.config(options)`, as follows:\n\n```js\n// Configure default options\ntaskcluster.config({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n\n// No credentials needed here\nvar auth = new taskcluster.Auth();\n```\n\nIf the `clientId` and `accessToken` are left empty we also check the\n`TASKCLUSTER_CLIENT_ID` and `TASKCLUSTER_ACCESS_TOKEN` environment variables\nto use as defaults (similar to how AWS, Azure, etc. handle authentication).\n\n### Restricting Authorized Scopes\nIf you wish to perform requests on behalf of a third-party that has small set of\nscopes than you do. You can specify which scopes your request should be allowed\nto use, in the key `authorizedScopes`. This is useful when the scheduler\nperforms a request on behalf of a task-graph, or when authentication takes\nplace in a trusted proxy. See example below:\n\n```js\n// Create a Queue Client class can only define tasks for a specific workerType\nvar queue = new taskcluster.Queue({\n  // Credentials that can define tasks for any provisioner and workerType.\n  credentials: {\n    clientId:       '...',\n    accessToken:    '...'\n  },\n  // Restricting this instance of the Queue client to only one scope\n  authorizedScopes: ['queue:post:define-task/my-provisioner/my-worker-type']\n});\n\n// This request will only be successful, if the task posted is aimed at\n// \"my-worker-type\" under \"my-provisioner\".\nqueue.defineTask(taskId taskDefinition).then(function(result) {\n  // ...\n});\n```\n\n\n## Configuration of Exchange Bindings\nWhen a taskcluster Client class is instantiated the option `exchangePrefix` may\nbe given. This will replace the default `exchangePrefix`. This can be useful if\ndeploying a staging area or similar. See example below:\n\n```js\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents({\n  exchangePrefix:     'staging-queue/v1/'\n});\n\n// This listener will now bind to: staging-queue/v1/task-completed\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n```\n\n## Using the Listener\nTaskCluster relies on AMQP for exchanges of messages. You'll need an AMQP\nconnection string for using the taskcluster AMQP listener.\nAn outline of how to create an instance and use is given below. Note, you\nmust call `resume()` before message starts arriving.\n\n```js\nvar listener = new taskcluster.Listener({\n  prefetch:           5,            // Number of tasks to process in parallel\n  connectionString:   'amqp://...', // AMQP connection string\n  // If no queue name is given, the queue is:\n  //    exclusive, autodeleted and non-durable\n  // If a queue name is given, the queue is:\n  //    durable, not auto-deleted and non-exclusive\n  queueName:          'my-queue',   // Queue name, undefined if none\n  maxLength:          0,            // Max allowed queue size\n});\n\nlistener.connect().then(...);       // Setup listener and bind queue\nlistener.resume().then(...);        // Start getting new messages\nlistener.pause().then(...);         // Pause retrieval of new messages\nlistener.deleteQueue();             // Delete named queue and disconnect\nlistener.close();                   // Disconnect from AMQP\n```\n\n**Using `Connection`**, instead of giving a `connectionString` it is also\npossible to give the `Listener` the key `connection` which must then be a\n`taskcluster.Connection` object. Using a `Connection` object it's possible\nto have multiple listeners using the same AMQP TCP connection, which is the\nrecommended way of using AMQP. Notice, that the `Connection` will not be\nclosed with the `Listener`s, so you must `close()` it manually.\n\n```js\nvar connection = new taskcluster.Connection({\n  connectionString:   'amqp://...', // AMQP connection string\n});\n\n// Create listener\nvar listener = new taskcluster.Listener({\n  connection:         connection,   // AMQP connection object\n});\n\n\nconnection.close();                 // Disconnect from AMQP\n```\n\n## Using `taskcluster-client` in a Browser\nRunning the script `utils/browserify.js` will generate `taskcluster-client.js`\nusing browserify. This does not contain any listener, but all the API logic\nand references is present. To get AMQP events in the browser use\n[events.taskcluster.net](https://github.com/taskcluster/taskcluster-events).\n\n## Updating Builtin APIs\nWhen releasing a new version of the `taskcluster-client` library, we should\nalways update the builtin references using `utils/update-apis.js` this\nmaintenance script can be used to list, show, add, remove and update builtin\nAPI definitions.\n\nWhen `apis.json` is updated, please run `utils/generate-docs.js` to update\nthe documentation in this file.\n\n##License\nThe taskcluster client library is released on [MPL 2.0](http://mozilla.org/MPL/2.0/).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/taskcluster/taskcluster-client/issues"
  },
  "homepage": "https://github.com/taskcluster/taskcluster-client",
  "_id": "taskcluster-client@0.15.2",
  "_from": "taskcluster-client@0.15.2"
}
