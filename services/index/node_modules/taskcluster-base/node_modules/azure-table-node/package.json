{
  "name": "azure-table-node",
  "version": "1.4.1",
  "description": "Azure Table Storage client using JSON on the wire",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gluwer/azure-table-node.git"
  },
  "keywords": [
    "azure",
    "storage",
    "table",
    "client"
  ],
  "author": {
    "name": "Gluwer Rafał Jońca",
    "email": "rafal@gluwer.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/gluwer/azure-table-node/issues"
  },
  "homepage": "https://github.com/gluwer/azure-table-node",
  "directories": {
    "test": "./test",
    "lib": "./lib"
  },
  "engines": {
    "node": ">= 0.8.26"
  },
  "dependencies": {
    "request": "~2.34.0",
    "lodash": "~2.4.1",
    "node-uuid": "~1.4.1",
    "async": "~0.2.10"
  },
  "devDependencies": {
    "mocha": "~1.17.0",
    "chai": "~1.8.1",
    "nock": "~0.27.1"
  },
  "readme": "azure-table-node\r\n================\r\n\r\nSimplified Azure Table Storage client library for NodeJS.\r\n\r\nWhat is supported:\r\n\r\n* creating, deleting and listing tables\r\n* creating, updating, querying and deleting entities\r\n* batch operation support\r\n* generating SAS (Shared Access Signature) and using it for authentication\r\n\r\nWhat will likely be added in the future:\r\n\r\n* get and set service properties\r\n\r\nUsage\r\n==============\r\n\r\n## Setting the default client connection info and other settings\r\n\r\nDefault client uses environment variable to set up the access key and storage URL if possible. It looks for the `CLOUD_STORAGE_ACCOUNT` setting with three elements (it is the default format used by Azure Storage):\r\n\r\n```\r\nTableEndpoint=http://accountName.table.core.windows.net/;AccountName=accountName;AccountKey=theKey\r\n```\r\n\r\nNo error is returned if this doesn't exists, is incomplete or malformed.\r\n\r\n*Current version does not support quotes and AccountKey must be the last one to be parsed correctly. This will be fixed in the future.*\r\n\r\nIf the environment variable is not set, the default connection info have to be set using below command to be usable:\r\n\r\n```javascript\r\nvar azureTable = require('azure-table-node');\r\nazureTable.setDefaultClient({\r\n  accountUrl: 'http://accountName.table.core.windows.net/',\r\n  accountName: 'accountName',\r\n  accountKey: 'theKey'\r\n});\r\n```\r\n\r\nThe same method allows to set other default client settings (see *Client settings*).\r\n\r\n## Using default client\r\n\r\n```javascript\r\nvar azureTable = require('azure-table-node');\r\nvar defaultClient = azureTable.getDefaultClient();\r\n\r\n// use the client to create the table\r\ndefaultClient.createTable('tableName', true, cb);\r\n// or insert entity\r\ndefaultClient.insert('table', entity, options, cb);\r\n```\r\n\r\n## Creating customized client\r\n\r\nIt is possible to create additional clients that are based on other client (or on default settings), but customized and independent. This allows to for example use several table storage accounts but still have one default for convenience.\r\n\r\n```javascript\r\nvar azureTable = require('azure-table-node');\r\nvar tableClient = azureTable.createClient({\r\n  // predefined settings\r\n}, [baseClient]);\r\n```\r\n\r\nBase client is the client on which the new one will be based. If not provided, it is based on the default one.\r\n\r\n## Longer usage example\r\n\r\n```javascript\r\nvar client = azureTable.getDefaultClient();\r\nclient.insertEntity('testtable', {\r\n  PartitionKey: 'tests',\r\n  RowKey: 'insert',\r\n  value1: 'ABCDEFG'\r\n}, function(err, data) {\r\n  // err is null\r\n  // data contains etag\r\n});\r\nclient.getEntity('testtable', 'tests', 'tests', function(err, data) {\r\n  // err is null\r\n  // data contains the object with entity\r\n});\r\nclient.queryEntities('testtable', {\r\n query: azureTable.Query.create('PartitionKey', '==', 'tests')\r\n limitTo: 20,\r\n onlyFields: ['RowKey', 'value1']\r\n}, function(err, data, continuation) {\r\n  // err is null\r\n  // data contains the array of objects (entities)\r\n  // continuation is undefined or two element array to be passed to next query\r\n});\r\nclient.deleteEntity('testtable', {\r\n  PartitionKey: 'tests',\r\n  RowKey: 'insert',\r\n  __etag: 'W/\"datetime\\'2014-01-23T07%3A34%3A30.4871837Z\\'\"'\r\n}, function(err, data) {\r\n  // err is null\r\n  // data is undefined\r\n});\r\nvar batchClient = client.startBatch();\r\nbatchClient.updateEntity('testtable', {\r\n  PartitionKey: 'tests',\r\n  RowKey: 'insert1',\r\n  value: 11\r\n}, {force: true}).deleteEntity('testtable', {\r\n  PartitionKey: 'tests',\r\n  RowKey: 'insert2',\r\n  __etag: 'W/\"datetime\\'2014-01-31T10%3A14%3A18.918655Z\\'\"'\r\n}).commit(function(err, data) {\r\n  // err is null\r\n  // data to be an array of results\r\n});\r\n```\r\n\r\nClient settings\r\n===============\r\n\r\nAccount related:\r\n\r\n* `accountUrl` (string) - URL of the service's endpoint (no default value)\r\n* `accountName` (string) - name of the used account (no default value)\r\n* `accountKey` (string) - base64 encoded account key (no default value), may be null if `sas` is provided\r\n* `sas` (string) - SAS query string that can be used instead of accountKey (in some less trusted environment) (no default value)\r\n\r\nUnderlying HTTP request related (passed without changes to request module):\r\n\r\n* `timeout` (int) - request timeout in miliseconds (default: 30000)\r\n* `proxy` (string) - proxy URL\r\n* `forever` (bool) - use `true` to turn advanced socket reuse\r\n* `agent` (Agent) - already created agent object (do not set `proxy`, `forever` or `pool` is set (may not work otherwise)\r\n* `agentOptions` (object) - used to set maxSockets option for forever or standard agent\r\n* `pool` (false|object) - use `false` to turn off socket reuse\r\n\r\nAzure Table Storage related:\r\n\r\n* `metadata` (string) - default metadata level, available values: `no`, `minimal`, `full` (default: `minimal`); if `no` is used, you have to take care yourself of changing Date, int64 and binary from strings to proper objects\r\n* `retry` (false/object/function) - set to `false` to turn off any retry policy; provide a function for custom retry logic or use object to change parameter of build in retry logic\r\n\r\nRetry options:\r\n\r\n* `retries` (int) - a number of retries (default: 3)\r\n* `firstDelay` (int) - delay of the first retry request in ms (default: 2000ms)\r\n* `nextDelayMult` (float) - delay multiplier using previous delay as a base (default: 2); use 1 for linear delay\r\n* `variability` (float) - random delay multiplier added or subtracted from current delay (default 0.2)\r\n* `transientErrors` (array of ints or strings) - describes situations where retry should be used; if it is int, status code is checked for equality; for string the code element of error or response is checked (default: `[500, 501, 502, 503, 'ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ESOCKETTIMEDOUT']`\r\n\r\nCustom retry function should support below parameters (in order of appearance):\r\n\r\n* `requestOptions` (object) - if needed it can be edited in place to change request options and headers\r\n* `nextReq` (function) - function to be called to make a request.\r\n\r\nThe `nextReq` function must be called passing additional function `retryFn` with below parameters:\r\n\r\n* `err` (object) - null or error object from response (see normal response callback)\r\n* `resp` (object/array) - response object (see normal response callback)\r\n* `nextResp` (function) - function to be called when there is no need for a retry passing (`err` and `resp` to it)\r\n\r\nAs by default request headers are not regenerated on retries, the retry time of of the last one cannot be very long, because authentication will fail.\r\n\r\nExample retry function which retries every time `code` in error is `ETIMEDOUT`:\r\n\r\n```javascript\r\nfunction _retryLogic(requestOptions, nextReq) {\r\n  function retryFn(err, resp, nextResp) {\r\n    if (err && err.code === 'ETIMEDOUT') {\r\n      nextReq(retryFn);\r\n    } else {\r\n      nextResp(err, resp);\r\n    }\r\n  }\r\n  nextReq(retryFn);\r\n}\r\n```\r\n\r\nIn case of reties, the default retry function returns `retriesMade` key in error informing about the number of retries made (helps in debugging).\r\n\r\nAPI\r\n===\r\n\r\nIf not explained differently, `cb` in API is a functions in format `function cb(err, data)`. For queries there may be additional third argument passed if there is a continuation token.\r\n\r\n## Module level\r\n\r\n### getDefaultClient()\r\n\r\nReturns default `Client` object. If `setDefaultClient()` was not used earlier the client only have default module settings and environment variable applied.\r\n\r\n### setDefaultClient(settings)\r\n\r\nSets up and returns default `Client` object with provided `settings`. It is using default settings as a base.\r\n\r\n### createClient(settings, [base])\r\n\r\nReturns new `Client` object using new settings and `base` client settings as a fallback. If `base` is not provided, uses default client settings.\r\n\r\n## Client object level\r\n\r\n### create(settings)\r\n\r\nReturns new `Client` object using only provided settings object. Shouldn't be used directly unless you want to provide all options. Use `createClient` from main module if possible.\r\n\r\n### getSettings()\r\n\r\nReturns sealed settings object used by this client.\r\n\r\n### createTable(table, [options], cb)\r\n\r\nCreates new table. The `table` is table name. The `options` is optional, but if exists and `ignoreIfExists` key equals `true`, the error 'table already exists' is ignored. The `cb` is a standard callback function.\r\n\r\n### deleteTable(table, cb)\r\n\r\nRemoves existing table. The `table` is table name. The `cb` is a standard callback function.\r\n\r\n### listTables([options], cb)\r\n\r\nReturns array with table names (as strings). The `options` is optional, but if exists and `nextTableName` key is provided, the retrieval will start from last continuation token. The `cb` is a standard callback function, but if continuation is required, the third argument will be passed with value for `nextTableName` key.\r\n\r\n### insertEntity(table, entity, [options], cb)\r\n\r\nCreates new `entity` in `table`. The `entity` must at least contain `PartitionKey` and `RowKey` as strings. The `options` have one setting supported `returnEntity`. If set to `true`, it will return the entity in `data` element in entity key (etag will be in `__etag` property). Otherwise function will return etag in data (as string).\r\n\r\n### insertOrReplaceEntity(table, entity, cb)\r\n\r\nCreates new `entity` in `table`. If it exists, it will be replaced. The `entity` must  contain `PartitionKey` and `RowKey` as strings. The `data` contains etag of inserted/replaced entity.\r\n\r\n### insertOrMergeEntity(table, entity, cb)\r\n\r\nCreates new `entity` in `table`. If it exists, passed values will be merged with existing ones. The `entity` must contain `PartitionKey` and `RowKey` as strings. The `data` contains etag of inserted/merged entity.\r\n\r\n### updateEntity(table, entity, [options], cb)\r\n\r\nUpdates `entity` in `table`. The `entity` must contain `PartitionKey` and `RowKey` as strings and also `__etag` if `force` is not used. The `options` object is optional. Use key `force` set to `true` to not use etag for optimistic concurrency. The `data` in callback contains new etag value.\r\n\r\n### mergeEntity(table, entity, [options], cb)\r\n\r\nMerge update of `entity` in `table`. The `entity` must contain `PartitionKey` and `RowKey` as strings and also `__etag` if `force` is not used. The `options` object is optional. Use key `force` set to `true` to not use etag for optimistic concurrency. The `data` in callback contains new etag value.\r\n\r\n### deleteEntity(table, entity, [options], cb)\r\n\r\nRemoves `entity` from `table`. The `entity` must contain `PartitionKey` and `RowKey` as strings and also `__etag` if `force` is not used. The `options` object is optional. Use key `force` set to `true` to not use etag for optimistic concurrency. The `data` in callback will always be undefined.\r\n\r\n### getEntity(table, partitionKey, rowKey, [options], cb)\r\n\r\nRetrieves one entity from `table`. Entity is located by `partitionKey` and `rowKey` values as strings. The `options` object is optional.  Use `onlyFields` as array of strings to retrieve only mentioned fields.\r\n\r\n### queryEntities(table, [options], cb)\r\n\r\nRetrieve up to 1000 entities as array. The `options` is optional. If not used first 1000 entities of table will be returned (or less if they do not exist). Callback will receive in `data` an array of entities. If not everything was returned, the third argument will contain two element array with continuation tokens. The should be used in options to retrieve next part of results.\r\n\r\nOptions can contain below elements. All are optional:\r\n\r\n* `query` -- the `Query` object for returned entities filtering or string with properly created `$filter` query string (for very advanced queries), see [Querying Entities](http://msdn.microsoft.com/en-us/library/windowsazure/dd894031.aspx)\r\n* `limitTo` -- integer, if provided it will return no more than this results\r\n* `onlyFields` -- array of strings to retrieve only mentioned fields\r\n* `forceEtags` -- if set to `true` it will force of etag retrieval (even if full metadata is not set for this client)\r\n* `continuation` -- array with two strings working as continuation token (array is returned as third argument in previous query)\r\n\r\n### startBatch()\r\n\r\nThis method will return new object that you use to prepare a batch. All methods available on `Client` can be used, but because of the limitations of Azure Table Storage (like only one query in batch) you should limit yourself only to insert, update, merge and delete operations. **Do not provide callback functions to those methods. Otherwise the results may not be as expected**. After adding all of them (up to 100) call `commit()` to send the batch.\r\n\r\n### commit(cb) - in objects returned by startBatch()\r\n\r\nSends the batch request. Requires only callback function. In case of error the callback's first parameter will receive error info for operation that was the reason of the error. If the whole batch was committed, second argument will contain array of responses for each operation.\r\n\r\n### generateSAS(table, permissions, expiry, [options])\r\n\r\nGenerates and returns the SAS (Shared Access Signature) query string to use in requests. The returned query string is already encoded and should be added after the main REST URL and other parameters. The `table` is the table for which SAS is generated. The `permissions` is a string with up to 4 characters describing permissions allowed on table: `r` (get/querying), `a` (insert), `u` (update), `d` (delete). Permissions must be provided in exactly the order mentioned and some operations like upsert may require both insert and update permissions. The `expiry` is the Date object with SAS expiration date. The `options` is an object with all other optional SAS restrictions:\r\n\r\n* `start` (Date) - date describing time when SAS should start to be valid\r\n* `policyId` (string) - string with the policy identifier\r\n* `startPK` (string) - the first partition key that is allowed\r\n* `startRK` (string) - the first row key that is allowed\r\n* `endPK` (string) - the last partition key that is allowed\r\n* `endRK` (string) - the last row key that is allowed\r\n\r\n\r\n## Query object level\r\n\r\nThe `Key` part is a string with field name. It can also be a `PartitionKey` or `RowKey`, but if only one row is going to be returned without additional filters, it is better to use `getEntity()` method.\r\n\r\nThe `comparison` only allows 6 standard comparison operators passed as strings: `==`, `!=`, `<`, `>`, `>=`, and `<=`. Passing anything else will end up throwing exception.\r\n\r\nThe `value` element can be a string, number, boolean or `Date` object. Everything else will be converted to string using `toString()`.\r\n\r\n### create([key, comparison, value])\r\n\r\nCreates and returns new `Query` object. For convenience it can use `where()` parameters. If all three are provided, `Query.create('a', '==', 'b')` is equivalent of `Query.create().where('a', '==', 'b')`.\r\n\r\n### where(key, comparison, value)\r\n\r\nAdds first query element. Cannot be used after the first one (will throw exception). Returns `Query` object.\r\n\r\n### and(key, comparison, value)\r\n\r\nAdds next query element using AND clause. Cannot be used as the first one (will throw exception). Returns `Query` object.\r\n\r\n### or(key, comparison, value)\r\n\r\nAdds next query element using OR clause. Cannot be used as the first one (will throw exception). Returns `Query` object.\r\n\r\n### not()\r\n\r\nWill negate next element. Returns `Query` object.\r\n\r\n\r\nRunning tests\r\n=============\r\n\r\nRun the tests using mocha from main project folder. But before that set the environment variable as some tests are relying on default:\r\n\r\n```\r\nset CLOUD_STORAGE_ACCOUNT=TableEndpoint=http://dummy.table.core.windows.net/;AccountName=dummy;AccountKey=DWFdvtgaJ/4okdYJs1sAr1yyvrRe4dAuY5yPg+R+Wsl5wMiX6QOZ+6egJseLXK8YlDASx6eP0bfWV3rgZlgxYA==\r\nmocha\r\n```",
  "readmeFilename": "README.md",
  "_id": "azure-table-node@1.4.1",
  "_from": "azure-table-node@1.4.1"
}
