const helper = require('./helper');
const assert = require('assert');
const nock = require('nock');
const githubAuth = require('../src/github-auth');
const testing = require('taskcluster-lib-testing');

const WITH_NEWLINES = '-----BEGIN RSA PRIVATE KEY-----\nsomekey\nline2\n-----END RSA PRIVATE KEY-----';
const WITH_ESCAPED_NEWLINES = '-----BEGIN RSA PRIVATE KEY-----\\nsomekey\\nline2\\n-----END RSA PRIVATE KEY-----';

// just needed some arbitrary parsable key so took one from
// the example at https://runkit.com/gr2m/reproducable-jwt
const FAKE_KEY = `-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA1c7+9z5Pad7OejecsQ0bu3aozN3tihPmljnnudb9G3HECdnH
lWu2/a1gB9JW5TBQ+AVpum9Okx7KfqkfBKL9mcHgSL0yWMdjMfNOqNtrQqKlN4kE
p6RD++7sGbzbfZ9arwrlD/HSDAWGdGGJTSOBM6pHehyLmSC3DJoR/CTu0vTGTWXQ
rO64Z8tyXQPtVPb/YXrcUhbBp8i72b9Xky0fD6PkEebOy0Ip58XVAn2UPNlNOSPS
ye+Qjtius0Md4Nie4+X8kwVI2Qjk3dSm0sw/720KJkdVDmrayeljtKBx6AtNQsSX
gzQbeMmiqFFkwrG1+zx6E7H7jqIQ9B6bvWKXGwIDAQABAoIBAD8kBBPL6PPhAqUB
K1r1/gycfDkUCQRP4DbZHt+458JlFHm8QL6VstKzkrp8mYDRhffY0WJnYJL98tr4
4tohsDbqFGwmw2mIaHjl24LuWXyyP4xpAGDpl9IcusjXBxLQLp2m4AKXbWpzb0OL
Ulrfc1ZooPck2uz7xlMIZOtLlOPjLz2DuejVe24JcwwHzrQWKOfA11R/9e50DVse
hnSH/w46Q763y4I0E3BIoUMsolEKzh2ydAAyzkgabGQBUuamZotNfvJoDXeCi1LD
8yNCWyTlYpJZJDDXooBU5EAsCvhN1sSRoaXWrlMSDB7r/E+aQyKua4KONqvmoJuC
21vSKeECgYEA7yW6wBkVoNhgXnk8XSZv3W+Q0xtdVpidJeNGBWnczlZrummt4xw3
xs6zV+rGUDy59yDkKwBKjMMa42Mni7T9Fx8+EKUuhVK3PVQyajoyQqFwT1GORJNz
c/eYQ6VYOCSC8OyZmsBM2p+0D4FF2/abwSPMmy0NgyFLCUFVc3OECpkCgYEA5OAm
I3wt5s+clg18qS7BKR2DuOFWrzNVcHYXhjx8vOSWV033Oy3yvdUBAhu9A1LUqpwy
Ma+unIgxmvmUMQEdyHQMcgBsVs10dR/g2xGjMLcwj6kn+xr3JVIZnbRT50YuPhf+
ns1ScdhP6upo9I0/sRsIuN96Gb65JJx94gQ4k9MCgYBO5V6gA2aMQvZAFLUicgzT
u/vGea+oYv7tQfaW0J8E/6PYwwaX93Y7Q3QNXCoCzJX5fsNnoFf36mIThGHGiHY6
y5bZPPWFDI3hUMa1Hu/35XS85kYOP6sGJjf4kTLyirEcNKJUWH7CXY+00cwvTkOC
S4Iz64Aas8AilIhRZ1m3eQKBgQCUW1s9azQRxgeZGFrzC3R340LL530aCeta/6FW
CQVOJ9nv84DLYohTVqvVowdNDTb+9Epw/JDxtDJ7Y0YU0cVtdxPOHcocJgdUGHrX
ZcJjRIt8w8g/s4X6MhKasBYm9s3owALzCuJjGzUKcDHiO2DKu1xXAb0SzRcTzUCn
7daCswKBgQDOYPZ2JGmhibqKjjLFm0qzpcQ6RPvPK1/7g0NInmjPMebP0K6eSPx0
9/49J6WTD++EajN7FhktUSYxukdWaCocAQJTDNYP0K88G4rtC2IYy5JFn9SWz5oh
x//0u+zd/R/QRUzLOw4N72/Hu+UG6MNt5iDZFCtapRaKt6OvSBwy8w==
-----END RSA PRIVATE KEY-----`;

suite(testing.suiteName(), function() {
  suite('octokit wrapping', function() {
    test('getAppGithub', async function() {
      nock('https://api.github.com:443')
        .post('/app/installations/100/access_tokens')
        .reply(200);
      const gh = await githubAuth({
        monitor: await helper.load('monitor'),
        cfg: {
          github: {
            credentials: {
              appId: 12345,
              privatePEM: FAKE_KEY,
            },
          },
        },
      });
      // Now just make sure these don't throw any errors
      await gh.getAppGithub();
      await gh.getInstallationGithub(100);
    });
  });
  suite('getPrivatePEM', function() {
    test('with actual newlines', function() {
      const cfg = { github: { credentials: { privatePEM: WITH_NEWLINES } } };
      assert.equal(githubAuth.getPrivatePEM(cfg), WITH_NEWLINES);
    });

    test('with escaped newlines', function() {
      const cfg = { github: { credentials: { privatePEM: WITH_ESCAPED_NEWLINES } } };
      assert.equal(githubAuth.getPrivatePEM(cfg), WITH_NEWLINES);
    });

    test('with invalid value', function() {
      const cfg = { github: { credentials: { privatePEM: 'somekey' } } };
      assert.throws(() => githubAuth.getPrivatePEM(cfg), err => {
        assert(/must match/.test(err.toString()));
        assert(!/somekey/.test(err.toString()));
        return true;
      });
    });
  });
  suite('getCachedInstallationToken', function () {
    const getGh = async () => {
      const gh = await githubAuth({
        monitor: await helper.load('monitor'),
        cfg: {
          github: {
            credentials: {
              appId: 12345,
              privatePEM: FAKE_KEY,
            },
          },
        },
      });
      return gh.getAppGithub();
    };

    test('cache responses', async function() {
      nock('https://api.github.com:443')
        .post('/app/installations/500/access_tokens')
        .reply(200, { expires_at: new Date('3000-01-01T00:00:00Z'), token: 'abc' });

      const ghApp = await getGh();
      const token1 = await githubAuth.getCachedInstallationToken(ghApp, 500);
      // calling this second time ensures that nock() will not be activated, since it only expects one call
      const token2 = await githubAuth.getCachedInstallationToken(ghApp, 500);

      assert.equal('abc', token1.token);
      assert.equal('abc', token2.token);
      assert.equal(true, nock.isDone());
    });

    test('cache responses and checks expiration dates', async function() {
      nock('https://api.github.com:443')
        .post('/app/installations/505/access_tokens')
        .times(2)
        .reply(200, { expires_at: new Date('1000-01-01T00:00:00Z'), token: 'abc' });

      const ghApp = await getGh();
      const token1 = await githubAuth.getCachedInstallationToken(ghApp, 505);
      const token2 = await githubAuth.getCachedInstallationToken(ghApp, 505);

      assert.equal('abc', token1.token);
      assert.equal('abc', token2.token);
      assert.equal(true, nock.isDone());
    });
  });
});
