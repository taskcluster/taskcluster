{
  "name": "taskcluster-client",
  "version": "0.7.4",
  "author": {
    "name": "Jonas Finnemann Jensen",
    "email": "jopsen@gmail.com"
  },
  "description": "Client for interfacing taskcluster components",
  "license": "MPL-2.0",
  "scripts": {
    "test": "./test/runtests.sh"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/taskcluster/taskcluster-client.git"
  },
  "dependencies": {
    "lodash": "2.4.1",
    "debug": "0.7.4",
    "superagent": "0.18.2",
    "superagent-promise": "0.1.2",
    "superagent-hawk": "0.0.3",
    "amqplib": "0.2.0",
    "slugid": "1.0.1"
  },
  "devDependencies": {
    "mocha": "1.18.2",
    "commander": "2.2.0",
    "cliff": "0.1.8",
    "taskcluster-base": "0.0.12",
    "promise": "5.0.0"
  },
  "readme": "# TaskCluster Client [![Build Status](https://travis-ci.org/taskcluster/taskcluster-client.svg?branch=master)](https://travis-ci.org/taskcluster/taskcluster-client)\n_A taskcluster client library for node.js._\n\nThis client library is generated from the auto-generated API reference.\nYou can create a Client class from a JSON reference object at runtime using\n`taskcluster.createClient(reference)`. But there is also a set of builtin\nreferences from which Client classes are already constructed.\n\n## Calling API End-Points\nTo invoke an API end-point instantiate a taskcluster Client class, these are\nclasses can be created from a JSON reference object, but a number of them are\nalso built-in to this library. In the following example we instantiate an\ninstance of the `Queue` Client class and use to to create a task.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Instantiate the Queue Client class\nvar queue = new taskcluster.Queue({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n\n// Create task using the queue client\nqueue.createTask(task).then(function(result) {\n  // status is a task status structure\n  console.log(result.status);\n});\n```\n\nThe `payload` parameter is always a JSON object as documented by the REST API\ndocumentation. The methods always returns a _promise_ for the response JSON\nobject as documented in the REST API documentation.\n\n## Listening for Events\nMany TaskCluster components publishes messages about current events over AMQP.\nThe JSON reference object also contains meta-data about declared AMQP topic\nexchanges and their routing key construction. This is designed to make it easy\nto construct routing key patterns and parse routing keys from incoming messages.\n\nThe following example create a `listener` and instantiate an instance of\nthe Client class `QueueEvents` which we use to find the exchange and create\na routing pattern to listen for completion of a specific task. The\n`taskCompleted` method will construct a routing key pattern by using `*` or `#`\nfor missing entries, pending on whether or not they are single word or\nmulti-key entries.\n\n```js\nvar taskcluster = require('taskcluster-client');\n\n// Create a listener (this creates a queue on AMQP)\nvar listener = new taskcluster.Listener({\n  connectionString:   'amqp://...'\n});\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents();\n\n// Bind to task-completed events from queue that matches routing key pattern:\n//   '<myTaskId>.*.*.*.*.*.#'\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n\n// Listen for messages\nlistener.on('message', function(message) {\n  message.exchange        // Exchange from which message came\n  message.payload         // Documented on docs.taskcluster.net\n  message.routingKey      // Message routing key in string format\n  message.routing.taskId  // Element from parsed routing key\n  message.routing.runId   // ...\n  message.redelivered     // True, if message has been nack'ed and requeued\n  return new Promise(...);\n});\n\n// Start listening for events\nlistener.connect().then(function() {\n  // Now listening\n});\n```\n\nThe listener creates a AMQP queue, on the server side and subscribes to messages\non the queue. It's possible to use named queues, see details below. For details\non routing key entries refer to documentation on\n[docs.taskcluster.net](docs.taskcluster.net).\n\n**Remark,** API end-points and AMQP exchanges are typically documented in\nseparate reference files. For this reason they also have separate Client\nclasses, even if they are from the same component.\n\n## Documentation\nThe set of API entries listed below is generated from the builtin references.\nDetailed documentation with description, payload and result format details is\navailable on [docs.taskcluster.net](http://docs.taskcluster.net).\n\nOn the [documentation site](http://docs.taskcluster.net) entries often have a\n_signature_, you'll find that it matches the signatures below. Notice that all\nthe methods returns a promise. A method with `: void` also returns a promise,\nthat either resolves without giving a value or rejects with an error.\n\n<!-- START OF GENERATED DOCS -->\n\n### Methods in `taskcluster.Auth`\n```js\n// Create Auth client instance with default baseUrl:\n//  - http://auth.taskcluster.net/v1\nvar auth = new taskcluster.Auth(options);\n```\n * `auth.inspect(clientId) : result`\n * `auth.getCredentials(clientId) : result`\n\n### Methods in `taskcluster.Queue`\n```js\n// Create Queue client instance with default baseUrl:\n//  - http://queue.taskcluster.net/v1\nvar queue = new taskcluster.Queue(options);\n```\n * `queue.createTask(payload) : result`\n * `queue.defineTasks(payload) : result`\n * `queue.scheduleTask(taskId) : result`\n * `queue.getTask(taskId) : result`\n * `queue.getTaskStatus(taskId) : result`\n * `queue.claimTask(taskId, payload) : result`\n * `queue.requestArtifactUrls(taskId, payload) : result`\n * `queue.reportTaskCompleted(taskId, payload) : result`\n * `queue.claimWork(provisionerId, workerType, payload) : result`\n * `queue.rerunTask(taskId) : result`\n * `queue.getPendingTasks(provisionerId) : void`\n * `queue.getAMQPConnectionString() : result`\n\n### Methods in `taskcluster.Scheduler`\n```js\n// Create Scheduler client instance with default baseUrl:\n//  - http://scheduler.taskcluster.net/v1\nvar scheduler = new taskcluster.Scheduler(options);\n```\n * `scheduler.createTaskGraph(payload) : result`\n * `scheduler.extendTaskGraph(taskGraphId, payload) : result`\n * `scheduler.getTaskGraphStatus(taskGraphId) : result`\n * `scheduler.getTaskGraphInfo(taskGraphId) : result`\n * `scheduler.inspectTaskGraph(taskGraphId) : result`\n\n### Exchanges in `taskcluster.QueueEvents`\n```js\n// Create QueueEvents client instance with default exchangePrefix:\n//  - queue/v1/\nvar queueEvents = new taskcluster.QueueEvents(options);\n```\n * `queueEvents.taskPending(routingKeyPattern) : binding-info`\n * `queueEvents.taskRunning(routingKeyPattern) : binding-info`\n * `queueEvents.taskCompleted(routingKeyPattern) : binding-info`\n * `queueEvents.taskFailed(routingKeyPattern) : binding-info`\n\n### Exchanges in `taskcluster.SchedulerEvents`\n```js\n// Create SchedulerEvents client instance with default exchangePrefix:\n//  - scheduler/v1/\nvar schedulerEvents = new taskcluster.SchedulerEvents(options);\n```\n * `schedulerEvents.taskGraphRunning(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphExtended(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphBlocked(routingKeyPattern) : binding-info`\n * `schedulerEvents.taskGraphFinished(routingKeyPattern) : binding-info`\n\n<!-- END OF GENERATED DOCS -->\n\n## Create Client Class Dynamically\nYou can create a Client class from a reference JSON object as illustrated\nbelow:\n\n```js\nvar reference = {...}; // JSON from references.taskcluster.net/...\n\n// Create Client class\nvar MyClient = taskcluster.createClient(reference);\n\n// Instantiate an instance of MyClient\nvar myClient = new MyClient(options);\n\n// Make a request with a method on myClient\nmyClient.myMethod(arg1, arg2, payload).then(function(result) {\n  // ...\n});\n```\n\n## Configuration of API Invocations\nThere is a number of configuration options for Client which affects invocation\nof API end-points. These are useful if using a non-default server, for example\nwhen setting up a staging area or testing locally.\n\n### Configuring API BaseUrls\nIf you use the builtin API Client classes documented above you can configure\nthe `baseUrl` when creating an instance of the client. As illustrated below:\n\n```js\nvar auth = new taskcluster.Auth({\n  credentials:  {...},\n  baseUrl:      \"http://localhost:4040\" // Useful for development and testing\n});\n```\n\n### Configuring Credentials\nWhen creating an instance of a Client class the credentials can be provided\nin options. For example:\n```js\nvar auth = new taskcluster.Auth({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n```\n\nYou can also configure default options globally using\n`taskcluster.config(options)`, as follows:\n\n```js\n// Configure default options\ntaskcluster.config({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...'\n  }\n});\n\n// No credentials needed here\nvar auth = new taskcluster.Auth();\n```\n\n### Delegated Authorization\nIf your client has the scope `auth:can-delegate` you can send requests with\na scope set different from the one you have. This is useful when the\nscheduler performs a request on behalf of a task-graph, or when\nauthentication takes place in a trusted proxy. See example below:\n\n```js\n// Create delegating instance of Auth Client class\nvar auth = new taskcluster.Auth({\n  credentials: {\n    clientId:     '...',\n    accessToken:  '...',\n    delegating:   true,\n    scopes:       ['scope', ...]  // For example task.scopes\n  }\n});\n\n// This request is only successful if the set of scopes declared above\n// allows the request to come through. The set of scopes the client has\n// will not be used to authorize this request.\nauth.getCredentials(someClientId).then(function(result) {\n  // ...\n});\n```\nWe call this delegated authorization, because the trusted node that has the\nscope `auth:can-delegate`, delegates authorization of the request to API\nend-point.\n\n## Configuration of Exchange Bindings\nWhen a taskcluster Client class is instantiated the option `exchangePrefix` may\nbe given. This will replace the default `exchangePrefix`. This can be useful if\ndeploying a staging area or similar. See example below:\n\n```js\n\n// Instantiate the QueueEvents Client class\nvar queueEvents = new taskcluster.QueueEvents({\n  exchangePrefix:     'staging-queue/v1/'\n});\n\n// This listener will now bind to: staging-queue/v1/task-completed\nlistener.bind(queueEvents.taskCompleted({taskId: '<myTaskId>'}));\n```\n\n## Using the Listener\n\nTODO:\n```\nvar listener = new taskcluster.Listener({\n  prefetch:           5,            // Number of tasks to process in parallel\n  connectionString:   'amqp://...', // AMQP connection string\n  // If no queue name is given, the queue is:\n  //    exclusive, autodeleted and non-durable\n  // If a queue name is given, the queue is:\n  //    durable, not auto-deleted and non-exclusive\n  queueName:          'my-queue',   // Queue name, undefined if none\n  maxLength:          0,            // Max allowed queue size\n});\n\nlistener.connect().then(...);       // Setup listener and start\nlistener.pause().then(...);         // Pause retrieval of new messages\nlistener.resume().then(...);        // Start getting new messages\nlistener.close();                   // Disconnect from AMQP\n```\n\n## Updating Builtin APIs\nWhen releasing a new version of the `taskcluster-client` library, we should\nalways update the builtin references using `utils/update-apis.js` this\nmaintenance script can be used to list, show, add, remove and update builtin\nAPI definitions.\n\nWhen `apis.json` is updated, please run `utils/generate-docs.js` to update\nthe documentation in this file.\n\n##License\nThe taskcluster client library is released on [MPL 2.0](http://mozilla.org/MPL/2.0/).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/taskcluster/taskcluster-client/issues"
  },
  "homepage": "https://github.com/taskcluster/taskcluster-client",
  "_id": "taskcluster-client@0.7.4",
  "_from": "taskcluster-client@0.7.4"
}
