{
  "version": 3,
  "sources": [
    "datacontainer.js"
  ],
  "names": [
    "debug",
    "DataContainer",
    "options",
    "container",
    "schema",
    "schemaVersion",
    "blobService",
    "account",
    "auth",
    "Auth",
    "credentials",
    "baseUrl",
    "authBaseUrl",
    "Blob",
    "timeout",
    "AZURE_BLOB_TIMEOUT",
    "accountId",
    "minSASAuthExpiry",
    "sas",
    "level",
    "accessLevel",
    "azureBlobSAS",
    "result",
    "accountName",
    "accountKey",
    "accessKey",
    "name",
    "_validateFunctionMap",
    "id",
    "_getSchemaId",
    "validator",
    "useDefaults",
    "format",
    "verbose",
    "allErrors",
    "updateRetries",
    "updateDelayFactor",
    "updateRandomizationFactor",
    "updateMaxDelay",
    "schemaName",
    "_getSchemaName",
    "putBlob",
    "type",
    "code",
    "storedSchema",
    "getBlob",
    "schemaBlob",
    "content",
    "_saveSchema",
    "ajvValidate",
    "compile",
    "JSON",
    "parse",
    "valid",
    "errors",
    "ensureContainer",
    "_cacheSchema",
    "createContainer",
    "deleteContainer",
    "blobs",
    "listBlobs",
    "prefix",
    "marker",
    "continuation",
    "maxResults",
    "map",
    "blob",
    "contentLanguage",
    "contentDisposition",
    "cacheControl",
    "test",
    "continuationToken",
    "nextMarker",
    "handler",
    "limit",
    "all",
    "dataBlob",
    "undefined",
    "create",
    "append",
    "blobName",
    "cacheContent",
    "properties",
    "getBlobProperties",
    "statusCode",
    "message",
    "load",
    "ignoreIfNotExists",
    "deleteBlob",
    "module",
    "exports"
  ],
  "mappings": "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",
  "file": "datacontainer.js",
  "sourceRoot": "../src",
  "sourcesContent": [
    "import assert           from 'assert';\nimport azure            from 'fast-azure-storage';\nimport taskcluster      from 'taskcluster-client';\nimport constants        from './constants';\nimport Ajv              from 'ajv';\nimport {rethrowDebug}   from './utils';\nimport _debug           from 'debug';\nconst debug = _debug('azure-blob-storage:account');\nimport {DataBlockBlob, AppendDataBlob} from './datablob';\nimport {SchemaIntegrityCheckError} from './customerrors';\n\n/**\n * This class represents an Azure Blob Storage container which stores objects in JSON format.\n * All the objects will be validated against the schema that is provided at the creation time of the container.\n */\nclass DataContainer {\n\n  /**\n   * Options:\n   * ```js\n   * {\n   *   // Azure connection details for use with SAS from auth.taskcluster.net\n   *   account:           '...',                  // Azure storage account name\n   *   container:         'AzureContainerName',   // Azure container name\n   *   // TaskCluster credentials\n   *   credentials: {\n   *     clientId:        '...',                  // TaskCluster clientId\n   *     accessToken:     '...',                  // TaskCluster accessToken\n   *   },\n   *   accessLevel:       'read-write',           // The access level of the container: read-only/read-write (optional)\n   *   authBaseUrl:       '...',                  // baseUrl for auth (optional)\n   *   schema:            '...',                  // JSON schema object\n   *   schemaVersion:     1,                      // JSON schema version. (optional)\n   *                                              // The default value is 1.\n   *\n   *   // Max number of update blob request retries\n   *   updateRetries:              10,\n   *   // Multiplier for computation of retry delay: 2 ^ retry * delayFactor\n   *   updateDelayFactor:          100,\n   *\n   *   // Randomization factor added as:\n   *   // delay = delay * random([1 - randomizationFactor; 1 + randomizationFactor])\n   *   updateRandomizationFactor:  0.25,\n   *\n   *   // Maximum retry delay in ms (defaults to 30 seconds)\n   *   updateMaxDelay:             30 * 1000,\n   * }\n   * ```\n   * Using the `options` format provided above a shared-access-signature will be\n   * fetched from auth.taskcluster.net. The goal with this is to reduce secret\n   * configuration and reduce exposure of our Azure `accountKey`. To fetch the\n   * shared-access-signature the following scope is required:\n   *   `auth:azure-blob:<level>:<account>/<container>`\n   *\n   * In case you have the Azure credentials, the options are:\n   * ```js\n   * {\n   *    // Azure credentials\n   *    credentials: {\n   *      accountName: '...',         // Azure account name\n   *      accountKey: '...',          // Azure account key\n   *    }\n   * }\n   * ```\n   */\n  constructor(options) {\n    // validate the options\n    assert(options,                                 'options must be given');\n    assert(options.container,                       'options.container must be given');\n    assert(typeof options.container === 'string',   'options.container is not a string');\n    assert(options.schema,                          'options.schema must be given');\n    assert(typeof options.schema === 'object',      'options.schema is not an object');\n\n    if (options.schemaVersion) {\n      assert(typeof options.schemaVersion === 'number', 'options.schemaVersion is not a number');\n    }\n\n    // create an Azure Blob Storage client\n    let blobService;\n    if (options.account) {\n      assert(typeof options.account === 'string',\n        'Expected `options.account` to be a string, or undefined.');\n\n      // Create auth client to fetch SAS from auth.taskcluster.net\n      let auth = new taskcluster.Auth({\n        credentials:    options.credentials,\n        baseUrl:        options.authBaseUrl,\n      });\n\n      // Create azure blob storage client with logic for fetch SAS\n      blobService = new azure.Blob({\n        timeout:          constants.AZURE_BLOB_TIMEOUT,\n        accountId:        options.account,\n        minSASAuthExpiry: 15 * 60 * 1000,\n        sas: async () => {\n          let level = options.accessLevel || 'read-write';\n          let result = await auth.azureBlobSAS(options.account, options.container, level);\n          return result.sas;\n        },\n      });\n    } else {\n      assert(options.credentials.accountName,\n        'The `options.credentials.accountName` must be supplied.');\n      assert(options.credentials.accountKey || options.credentials.sas,\n        'The `options.credentials.accountKey` or `options.credentials.sas` must be supplied.');\n\n      // Create azure blob storage client with accessKey\n      blobService = new azure.Blob({\n        timeout:    constants.AZURE_BLOB_TIMEOUT,\n        accountId:  options.credentials.accountName,\n        accessKey:  options.credentials.accountKey,\n        sas:        options.credentials.sas,\n      });\n    }\n\n    this.blobService = blobService;\n    this.name        = options.container;\n    // _validateFunctionMap is a mapping from schema version to validation function generated\n    // after the ajv schema compile\n    this._validateFunctionMap = {};\n\n    this.schema      = options.schema;\n    this.schemaVersion = options.schemaVersion? options.schemaVersion : 1;\n    this.schema.id = this._getSchemaId(this.schemaVersion);\n\n    this.validator   = Ajv({\n      useDefaults: true,\n      format: 'full',\n      verbose: true,\n      allErrors: true,\n    });\n\n    this.updateRetries = options.updateRetries || 10;\n    this.updateDelayFactor = options.updateDelayFactor || 100;\n    this.updateRandomizationFactor = options.updateRandomizationFactor || 0.25;\n    this.updateMaxDelay = options.updateMaxDelay || 30 * 1000;\n  }\n\n  /**\n   * @param schemaVersion - the schema version\n   * @returns {string} - the id of the schema\n   * @private\n   */\n  _getSchemaId(schemaVersion) {\n    return `http://${this.blobService.options.accountId}.blob.core.windows.net/` +\n      `${this.name}/.schema.v${schemaVersion}.json`;\n  }\n\n  /**\n   * @param schemaVersion - the schema version\n   * @returns {string} - the name of the schema\n   * @private\n   */\n  _getSchemaName(schemaVersion) {\n    return `.schema.v${schemaVersion}`;\n  }\n\n  /**\n   * Saves the JSON schema in a BlockBlob.\n   * This method will throw an 'AuthorizationPermissionMismatch', if the client has read-only rights\n   * for the data container.\n   *\n   * @private\n   */\n  async _saveSchema() {\n    try {\n      let schemaName = this._getSchemaName(this.schemaVersion);\n      await this.blobService.putBlob(this.name, schemaName, {type: 'BlockBlob'}, JSON.stringify(this.schema));\n    } catch (error) {\n      // Ignore the 'AuthorizationPermissionMismatch' error that will be throw if the client has read-only rights.\n      // The save of the schema can be done only by the clients with read-write access.\n      if (error.code !== 'AuthorizationPermissionMismatch') {\n        rethrowDebug(`Failed to save the json schema '${this.schema.id}' with error: ${error}`, error);\n      }\n    }\n  }\n\n  /**\n   * If the schema was previously saved, this method will make an integrity check, otherwise will save the schema in\n   * a blockBlob.\n   * @private\n   */\n  async _cacheSchema() {\n    let storedSchema;\n    let schemaName = this._getSchemaName(this.schemaVersion);\n    try {\n      let schemaBlob = await this.blobService.getBlob(this.name, schemaName);\n      storedSchema = schemaBlob.content;\n    } catch (error) {\n      if (error.code === 'BlobNotFound') {\n        this._saveSchema();\n        return;\n      }\n      rethrowDebug(`Failed to save the json schema '${this.schema.id}' with error: ${error}`, error);\n    }\n\n    // integrity check\n    if (storedSchema !== JSON.stringify(this.schema)) {\n      throw new SchemaIntegrityCheckError('The stored schema is not the same with the schema defined.');\n    }\n  }\n\n  /**\n   * Method that validates the content\n   *\n   * @param content - JSON content\n   * @param schemaVersion - the schema version (optional)\n   *\n   * @return {object}\n   * ```js\n   * {\n   *    valid: boolean,   // true/false if the content is valid or not\n   *    errors: [],       // if the content is invalid, errors will contain an array of validation errors\n   * }\n   * ```\n   */\n  async validate(content, schemaVersion = this.schemaVersion) {\n    let ajvValidate = this._validateFunctionMap[schemaVersion];\n    // if the validate function is not available, this means that the schema is not yet loaded\n    if (!ajvValidate) {\n      if (schemaVersion === this.schemaVersion) {\n        this._validateFunctionMap[this.schemaVersion] = this.validator.compile(this.schema);\n      } else {\n        // load the schema\n        try {\n          let schemaBlob = await this.blobService.getBlob(this.name, this._getSchemaName(schemaVersion));\n          let schema = JSON.parse(schemaBlob.content);\n          // cache the ajv validate function\n          this._validateFunctionMap[schemaVersion] = this.validator.compile(schema);\n        } catch (error) {\n          rethrowDebug(`Failed to save the json schema '${this.schema.id}' with error: ${error}`, error);\n        }\n      }\n    }\n    ajvValidate = this._validateFunctionMap[schemaVersion];\n    let result = {\n      valid: ajvValidate(content),\n      errors: ajvValidate.errors,\n    };\n\n    return result;\n  }\n\n  async init() {\n    // ensure the existence of the data container\n    await this.ensureContainer();\n\n    // cache the JSON schema\n    await this._cacheSchema();\n  }\n\n  /**\n   * Ensure existence of the underlying container\n   *\n   * Note that this doesn't work, if authenticated with SAS.\n   */\n  async ensureContainer() {\n    // Auth creates the container for us, so we don't do it again\n    // The request will actually fail because Auth doesn't give\n    // us permissions for creating containers.\n    if (this.blobService.options && this.blobService.options.sas) {\n      return;\n    }\n\n    try {\n      await this.blobService.createContainer(this.name);\n    } catch (error) {\n      if (!error || error.code !== 'ContainerAlreadyExists') {\n        rethrowDebug(`Failed to ensure container '${this.name}' with error: ${error}`, error);\n      }\n    }\n  }\n\n  /**\n   * Delete the underlying container\n   *\n   * Note that this doesn't work, if authenticated with SAS.\n   */\n  async removeContainer() {\n    try {\n      await this.blobService.deleteContainer(this.name);\n    } catch (error) {\n      rethrowDebug(`Failed to delete container \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Returns a paginated list of blobs contained by this container\n   *\n   * @param options\n   * {\n   *    prefix: '...',                // Prefix of blobs to list (optional)\n   *    continuation: '...',          // Continuation token to continue from (optional)\n   *    maxResults: 5000,             // The maximum number of blobs to return (optional)\n   * }\n   * @returns\n   * {\n   *    blobs: [],                    // An array of blob instances\n   *    continuationToken: '...',     // Next token if not at end of list\n   * }\n   */\n  async listBlobs(options) {\n    options = options || {};\n    let blobs = [];\n\n    try {\n      let result = await this.blobService.listBlobs(this.name, {\n        prefix: options.prefix,\n        marker: options.continuation,\n        maxResults: options.maxResults,\n      });\n\n      blobs = result.blobs.map(blob => {\n        let options = {\n          container: this,\n          name: blob.name,\n          contentLanguage: blob.contentLanguage,\n          contentDisposition: blob.contentDisposition,\n          cacheControl: blob.cacheControl,\n        };\n        // the list can't contain the blobs that store the JSON schema\n        if (blob.type === 'BlockBlob' && !/.schema.v*/i.test(blob.name)) {\n          return new DataBlockBlob(options);\n        } else if (blob.type === 'AppendBlob') {\n          return new AppendDataBlob(options);\n        } else {\n          // PageBlobs are not supported\n        }\n      });\n\n      return {\n        blobs: blobs || [],\n        continuationToken: result.nextMarker,\n      };\n    } catch (error) {\n      rethrowDebug(`Failed to list blobs for container \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Execute the provided function on each data block blob from this container while handling pagination.\n   *\n   * @param {function} handler\n   * ```js\n   *   function(blob) {\n   *      return new Promise(...); // Do something with the blob\n   *   }\n   * ```\n   * @param {object} options - Options on the form\n   * ```js\n   *    {\n   *      prefix: '...',      // Prefix of blobs to list (optional)\n   *      limit:  1000,       // Max number of parallel handler calls\n   *    }\n   * ```\n   */\n  async scanDataBlockBlob(handler, options) {\n    assert(typeof handler === 'function', 'handler must be a function');\n    options = options || {};\n\n    try {\n      let marker;\n      do {\n        let result = await this.blobService.listBlobs(this.name, {\n          prefix: options.prefix,\n          marker: marker,\n          maxResults: options.limit,\n        });\n\n        await Promise.all(result.blobs.map(\n          async (blob) => {\n            if (blob.type === 'BlockBlob') {\n              // 1. create an instance of DataBlockBlob from the result blob\n              let dataBlob = new DataBlockBlob({\n                name: blob.name,\n                container: this,\n                contentLanguage: blob.contentLanguage,\n                contentDisposition: blob.contentDisposition,\n                cacheControl: blob.cacheControl,\n              });\n              // we need to take extra care for the blobs that contain the schema information.\n              // the handle can't be applied on blobs that store the JSON schema\n              if (!/.schema.v*/i.test(dataBlob.name)) {\n                // 2. execute the handler function\n                await handler(dataBlob);\n              }\n            }\n          }));\n\n        marker = result.nextMarker || undefined;\n      } while (marker);\n    } catch (error) {\n      rethrowDebug(`Failed to execute the handler with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Returns an instance of DataBlockBlob.\n   * By using this instance of blob, a JSON file can be stored in azure storage.\n   * The content will be validated against the schema defined at the container level.\n   *\n   * @param options - Options on the form\n   * ```js\n   * {\n   *    name: '...',                // The name of the blob (required)\n   *    metadata: '...',            // Name-value pairs associated with the blob as metadata\n   *    contentEncoding: '...',     // The content encoding of the blob\n   *    contentLanguage: '...',     // The content language of the blob\n   *    cacheControl: '...',        // The cache control of the blob\n   *    contentDisposition: '...',  // The content disposition of the blob\n   *    cacheContent: true|false,   // This can be set true in order to keep a reference of the blob content.\n   *                                // Default value is false\n   * }\n   * ```\n   * @param content - content in JSON format of the blob\n   * @returns {DataBlockBlob} an instance of DataBlockBlob\n   */\n  async createDataBlockBlob(options, content) {\n    assert(content, 'The content of the blob must be provided.');\n    options = options || {};\n    options.container = this;\n\n    let blob = new DataBlockBlob(options);\n    await blob.create(content);\n\n    return blob;\n  }\n\n  /**\n   * Create an instance of AppendDataBlob.\n   * This type is optimized for fast append operations and all writes happen at the end of the blob.\n   * Each object appended must be in JSON format and must match the schema defined at container level.\n   * Updating and deleting existing content is not supported.\n   *\n   * @param options - Options on the form\n   * ```js\n   * {\n   *    name: '...',                // The name of the blob (required)\n   *    metadata: '...',            // Name-value pairs associated with the blob as metadata\n   *    contentEncoding: '...',     // The content encoding of the blob\n   *    contentLanguage: '...',     // The content language of the blob\n   *    cacheControl: '...',        // The cache control of the blob\n   *    contentDisposition: '...',  // The content disposition of the blob\n   * }\n   * ```\n   * @param content - the content, in JSON format, that should be appended(optional)\n   */\n  async createAppendDataBlob(options, content) {\n    options = options || {};\n    options.container = this;\n\n    let blob = new AppendDataBlob(options);\n    await blob.create(); // for append blobs, the create method should be called without content\n\n    if (content) {\n      await blob.append();\n    }\n    return blob;\n  }\n\n  /**\n   * Returns an instance of DataBlockBlob or AppendDataBlob.\n   * It makes sense to set the cacheContent to true only for DataBlockBlob, because AppendDataBlob blobs do not keep\n   * the content in their instance.\n   *\n   * @param blobName - the name of the blob\n   * @param cacheContent - true in order to cache the content\n   */\n  async load(blobName, cacheContent) {\n    assert(blobName, 'The name of the blob must be specified.');\n\n    let properties;\n    try {\n      // find the type of the blob\n      properties = await this.blobService.getBlobProperties(this.name, blobName);\n    } catch (error) {\n      /**\n       * For getBlobProperties, if the blob does not exist, Azure does not send a proper BlobNotFound error.\n       * Azure sends a response with statusCode: 404, statusMessage: 'The specified blob does not exists.' and\n       * without any payload. Because of this, the error received here will look like this:\n       *\n       *  { ErrorWithoutCodeError: No error message given, in payload ''\n       *     name: 'ErrorWithoutCodeError',\n       *     code: 'ErrorWithoutCode',\n       *     statusCode: 404,\n       *     retries: 0 }\n       * Probably in the future, Azure will correct the response, but, till then we will override the name and code.\n       */\n      if (error.statusCode === 404 && error.name === 'ErrorWithoutCodeError') {\n        error.code = 'BlobNotFound';\n        error.name = 'BlobNotFoundError';\n        error.message = 'The specified blob does not exist.';\n      }\n      rethrowDebug(`Failed to load the blob '${blobName}' from container \"${this.name}\" with error: ${error}`, error);\n    }\n\n    let blob;\n    let options = {\n      name: blobName,\n      container: this,\n      cacheContent: cacheContent,\n    };\n    if (properties.type === 'BlockBlob') {\n      blob = new DataBlockBlob(options);\n    } else if (properties.type === 'AppendBlob') {\n      return new AppendDataBlob(options);\n    } else {\n      // PageBlob is not supported\n      return null;\n    }\n\n    await blob.load();\n    return blob;\n  }\n\n  /**\n   * Removes a blob from Azure storage without loading it.\n   * Returns true, if the blob was deleted. It makes sense to read the return value only if `ignoreIfNotExists` is set\n   * to value true.\n   *\n   * @param blob\n   * @param ignoreIfNotExists - true in order to ignore the error that is thrown in case the blob does not exist\n   */\n  async remove(blob, ignoreIfNotExists) {\n    assert(blob, 'The blob name must be specified.');\n\n    try {\n      await this.blobService.deleteBlob(this.name, blob);\n      return true;\n    } catch (error) {\n      if (ignoreIfNotExists && error && error.code === 'BlobNotFound') {\n        return false;\n      }\n      rethrowDebug(`Failed to remove the blob '${blob}' from container \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n}\n\nmodule.exports.DataContainer = DataContainer;\n"
  ]
}
