{
  "version": 3,
  "sources": [
    "datablob.js"
  ],
  "names": [
    "debug",
    "DataBlob",
    "options",
    "container",
    "name",
    "blobService",
    "cacheContent",
    "type",
    "contentType",
    "contentLanguage",
    "contentDisposition",
    "cacheControl",
    "content",
    "validate",
    "version",
    "schemaVersion",
    "result",
    "valid",
    "schema",
    "id",
    "errors",
    "error",
    "validationErrors",
    "undefined",
    "blobOptions",
    "defaults",
    "putBlob",
    "eTag",
    "_cache",
    "ignoreChanges",
    "ignoreIfNotExists",
    "ifMatch",
    "deleteBlob",
    "code",
    "DataBlockBlob",
    "json",
    "stack",
    "ifNoneMatch",
    "getBlob",
    "blob",
    "deserializedContent",
    "JSON",
    "parse",
    "_validateJSON",
    "statusCode",
    "_serialize",
    "modifier",
    "Function",
    "attemptsLeft",
    "updateRetries",
    "modifiedContent",
    "attemptModify",
    "load",
    "clonedContent",
    "cloneDeep",
    "updateDelayFactor",
    "updateRandomizationFactor",
    "updateMaxDelay",
    "AppendDataBlob",
    "appendBlock",
    "_create",
    "module",
    "exports"
  ],
  "mappings": "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",
  "file": "datablob.js",
  "sourceRoot": "../src",
  "sourcesContent": [
    "import assert from 'assert';\nimport _debug from 'debug';\nimport _      from 'lodash';\nconst debug = _debug('azure-blob-storage:blob');\nimport {CongestionError, SchemaValidationError, BlobSerializationError} from './customerrors';\nimport {rethrowDebug, sleep, computeDelay} from './utils';\n\n/**\n * Base class for data blobs\n */\nclass DataBlob {\n\n  /**\n   * @param options - Options on the form\n   * ```js\n   * {\n   *    name: '...',                  // The name of the blob (required)\n   *    type: 'BlockBlob|AppendBlob', // The type of the blob (required)\n   *    container: '...',             // An instance of DataContainer (required)\n   *    contentEncoding: '...',       // The content encoding of the blob\n   *    contentLanguage: '...',       // The content language of the blob\n   *    cacheControl: '...',          // The cache control of the blob\n   *    contentDisposition: '...',    // The content disposition of the blob\n   *    cacheContent: true|false,     // This can be set true in order to keep a reference of the blob content.\n   *                                  // Default value is false\n   * }\n   * ```\n   */\n  constructor(options) {\n    options = options || {};\n    assert(options, 'options must be specified.');\n    assert(options.container, 'The container instance, `options.container`, must be specified.');\n    assert(typeof options.name === 'string', 'The name of the blob, `options.name` must be specified.');\n\n    this.container = options.container;\n    this.blobService = this.container.blobService;\n    this.cacheContent = options.cacheContent || false;\n\n    this.name = options.name;\n    this.type = options.type;\n    this.contentType = 'application/json';\n    this.contentLanguage = options.contentLanguage;\n    this.contentDisposition = options.contentDisposition;\n    this.cacheControl = options.cacheControl;\n  }\n\n  async _validateJSON(content) {\n    let result = await this.container.validate(content, this.version ? this.version:this.container.schemaVersion);\n    if (!result.valid) {\n      debug(`Failed to validate the blob content against schema with id: \n          ${this.container.schema.id}, errors: ${result.errors}`);\n      let error = new SchemaValidationError(`Failed to validate the blob content against schema with id: \n                                            ${this.container.schema.id}`);\n      error.content = content;\n      error.validationErrors = result.errors;\n      throw error;\n    }\n  }\n\n  _cache(content) {\n    this.content = this.cacheContent ? content : undefined;\n  }\n\n  /**\n   * Creates the blob in Azure storage\n   *\n   * @param content - content of the blob\n   * @param options - options to pass to azure\n   */\n  async _create(content, options) {\n    let blobOptions = _.defaults({}, {\n      type: this.type,\n      contentType: this.contentType,\n      contentLanguage: this.contentLanguage,\n      contentDisposition: this.contentDisposition,\n      cacheControl: this.cacheControl,\n    }, options || {});\n    try {\n      let result = await this.blobService.putBlob(this.container.name, this.name, blobOptions, content);\n      this.eTag = result.eTag;\n      this._cache(content);\n    } catch (error) {\n      rethrowDebug(`Failed to create the blob \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Remove this blob if the content was not modified, unless `ignoreChanges` is set\n   */\n  async remove(ignoreChanges, ignoreIfNotExists) {\n    let options = {};\n    if (!ignoreChanges) {\n      options.ifMatch = this.eTag;\n    }\n    try {\n      await this.blobService.deleteBlob(this.container.name, this.name, options);\n    } catch (error) {\n      if (ignoreIfNotExists && error && error.code === 'BlobNotFound') {\n        return;\n      }\n      rethrowDebug(`Failed to remove the blob '${this.name}'` +\n        ` from container \"${this.container.name}\" with error: ${error}`, error);\n    }\n  }\n}\n\n/**\n * An instance of DataBlockBlob is a reference to an azure block blob which contains a JSON file.\n * The content of the DataBlockBlob is validated against the schema stored at the container level.\n */\nclass DataBlockBlob extends DataBlob {\n\n  constructor(options) {\n    options.type = 'BlockBlob';\n    super(options);\n  }\n\n  _serialize(json) {\n    try {\n      return JSON.stringify({\n        content: json,\n        version: this.version ? this.version : this.container.schemaVersion,\n      });\n    } catch (error) {\n      debug(`Failed to serialize the content of the blob: ${this.name} with error: ${error}, ${error.stack}`);\n      throw new BlobSerializationError(`Failed to serialize the content of the blob: ${this.name}`);\n    }\n  }\n\n  /**\n   * Load the content of this blob.\n   */\n  async load() {\n    // load the content only if the eTag of our local data doesn't match the copy on the server\n    let options = {};\n    if (this.cacheContent) {\n      options.ifNoneMatch = this.eTag;\n    }\n    try {\n      let blob = await this.blobService.getBlob(this.container.name, this.name, options);\n\n      // update the properties\n      this.eTag = blob.eTag;\n      this.contentType = blob.contentType;\n      this.contentLanguage = blob.contentLanguage;\n      this.contentDisposition = blob.contentDisposition;\n      this.cacheControl = blob.cacheControl;\n\n      let deserializedContent = JSON.parse(blob.content);\n      let content = deserializedContent.content;\n      this.version = deserializedContent.version;\n      // Validate the JSON against the schema\n      await this._validateJSON(content);\n      this._cache(content);\n      return content;\n    } catch (error) {\n      if (error && error.statusCode === 304) {\n        return this.content; // our local data match with server data\n      }\n      rethrowDebug(`Failed to load the blob \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * The method creates this blob on azure blob storage.\n   * The blob can be created without content. The content can be uploaded later using `modify` method.\n   *\n   * @param content - a JSON object\n   */\n  async create(content, options) {\n    assert(content, 'content must be specified');\n\n    // 1. Validate the content against the schema\n    await this._validateJSON(content);\n\n    // 2. store the blob\n    await super._create(this._serialize(content), options);\n\n    // 3. cache the raw content and not the serialized one\n    this._cache(content);\n  }\n\n  /**\n   * Update the content of the stored JSON.\n   *\n   * The JSON has the following structure:\n   * ```js\n   * {\n   *    content: '...',\n   *    version: 1\n   * }\n   * ```\n   * @param options - Options on the form:\n   * ```js\n   * {\n   *    contentLanguage: '...',\n   *    contentDisposition: '...',\n   *    cacheControl: '...'\n   * }\n   * ```\n   * @param modifier - function that is called to update the content\n   */\n  async modify(modifier, options) {\n    options = options || {};\n    options.type = this.type;\n    assert(modifier instanceof Function, 'The `modifier` must be a function.');\n\n    // Attempt to modify this object\n    let attemptsLeft = this.container.updateRetries;\n\n    let modifiedContent;\n    let attemptModify = async () => {\n      try {\n        // 1. load the resource\n        let content = await this.load();\n\n        // 2. run the modifier function\n        let clonedContent = _.cloneDeep(content);\n        modifier(clonedContent);\n        modifiedContent = clonedContent;\n\n        // 3. validate against the schema\n        await this._validateJSON(clonedContent);\n\n        // 4. update the resource\n        options.ifMatch = this.eTag;\n\n        let result = await this.blobService.putBlob(this.container.name,\n          this.name,\n          options,\n          this._serialize(modifiedContent));\n        this.eTag = result.eTag;\n      } catch (error) {\n        // rethrow error, if it's not caused by optimistic concurrency\n        if (!error || error.code !== 'ConditionNotMet') {\n          rethrowDebug(`Failed to update blob \"${this.name}\" with error: ${error}`, error);\n        }\n\n        // Decrement number of attempts left\n        attemptsLeft -= 1;\n        if (attemptsLeft === 0) {\n          debug('ERROR: the maximum number of retries exhausted, we might have congestion');\n          throw new CongestionError('the maximum number of retries exhausted, check for congestion');\n        }\n\n        await sleep(computeDelay(attemptsLeft,\n          this.container.updateDelayFactor,\n          this.container.updateRandomizationFactor,\n          this.container.updateMaxDelay));\n        await attemptModify();\n      }\n    };\n    await attemptModify();\n    // cache the raw content and not the one which is versioned\n    this._cache(modifiedContent);\n  }\n}\n\n/**\n * An instance of AppendDataBlob is a reference to an azure append blob.\n * Each appended object must be in JSON format and must match the schema defined at the container level.\n * Updating and deleting existing content is not supported.\n */\nclass AppendDataBlob extends DataBlob {\n\n  constructor(options) {\n    options.type = 'AppendBlob';\n    super(options);\n    this.cacheContent = false;\n  }\n\n  _serialize(content) {\n    try {\n      return JSON.stringify(content);\n    } catch (error) {\n      debug(`Failed to serialize the content of the blob: ${this.name} with error: ${error}, ${error.stack}`);\n      throw new BlobSerializationError(`Failed to serialize the content of the blob: ${this.name}`);\n    }\n  }\n\n  /**\n   * Append content that should be conform to container schema\n   *\n   * @param content - the content that should be appended\n   */\n  async append(content) {\n    // 1. validate the content against the schema\n    await this._validateJSON(content);\n\n    // 2. append the new content\n    try {\n      await this.blobService.appendBlock(this.container.name, this.name, {}, this._serialize(content));\n    } catch (error) {\n      rethrowDebug(`Failed to append content for blob '${this.name}' with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Load the content of this append blob.\n   */\n  async load() {\n    try {\n      let blob = await this.blobService.getBlob(this.container.name, this.name);\n\n      // update the properties\n      this.eTag = blob.eTag;\n      this.contentType = blob.contentType;\n      this.contentLanguage = blob.contentLanguage;\n      this.contentDisposition = blob.contentDisposition;\n      this.cacheControl = blob.cacheControl;\n\n      return blob.content;\n    } catch (error) {\n      rethrowDebug(`Failed to load the blob \"${this.name}\" with error: ${error}`, error);\n    }\n  }\n\n  /**\n   * Creates the blob in Azure storage\n   */\n  async create(options) {\n    await this._create(options);\n  }\n}\n\nmodule.exports = {\n  DataBlockBlob,\n  AppendDataBlob,\n};\n"
  ]
}
