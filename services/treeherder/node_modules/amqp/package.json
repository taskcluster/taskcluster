{
  "name": "amqp",
  "description": "AMQP driver for node",
  "keywords": [
    "amqp"
  ],
  "version": "0.1.8",
  "author": {
    "name": "Ryan Dahl"
  },
  "contributors": [
    {
      "name": "Vasili Sviridov"
    },
    {
      "name": "Theo Schlossnagle"
    },
    {
      "name": "Vincent Desjardins"
    },
    {
      "name": "Liang-Chi Hsieh"
    },
    {
      "name": "Tim Baga"
    },
    {
      "name": "Stéphane Alnet"
    },
    {
      "name": "Alen Mujezinovic"
    },
    {
      "name": "Michael Bridgen"
    },
    {
      "name": "Chris Bond"
    },
    {
      "name": "Andrei Vereha"
    },
    {
      "name": "Mike Bardzinski"
    },
    {
      "name": "James Carr"
    },
    {
      "name": "David Barshow"
    },
    {
      "name": "Jason Pincin"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/postwait/node-amqp.git"
  },
  "bugs": {
    "url": "http://github.com/postwait/node-amqp/issues"
  },
  "main": "./amqp",
  "engines": {
    "node": "0.4 || 0.6 || 0.8 || 0.9 || 0.10"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/postwait/node-amqp/raw/master/LICENSE-MIT"
    }
  ],
  "dependencies": {
    "lodash": "~1.3.1",
    "longjohn": "~0.2.1"
  },
  "devDependencies": {
    "optimist": "~0.6.0"
  },
  "readme": "[![build status](https://secure.travis-ci.org/postwait/node-amqp.png)](http://travis-ci.org/postwait/node-amqp)\n\n# node-amqp\n\nThis is a client for RabbitMQ (and maybe other servers?). It partially\nimplements the 0.9.1 version of the AMQP protocol.\n\n## Table of Contents \n\n- [Installation](#installation)\n- [Synopsis](#synopsis)\n- [Connection](#connection)\n  - [Connection options and URL](#connection-options-and-url)\n  - [connection.publish(queueName, body, options, callback)](#connectionpublishqueuename-body-options-callback)\n  - [connection.end()](#connectionend)\n- [Queue](#queue)\n  - [connection.queue(name, options, openCallback)](#connectionqueuename-options-opencallback)\n  - [queue.subscribe([options,] listener)](#queuesubscribeoptions-listener)\n  - [queue.subscribeRaw([options,] listener)](#queuesubscriberawoptions-listener)\n  - [queue.unsubscribe(consumerTag)](#queueunsubscribeconsumertag)\n  - [queue.shift([reject[, requeue]])](#queueshiftreject-requeue)\n  - [queue.bind([exchange,] routing)](#queuebindexchange-routing)\n  - [queue.unbind([exchange,] routing)](#queueunbindexchange-routing)\n  - [queue.bind_headers([exchange,] routing)](#queuebind_headersexchange-routing)\n  - [queue.destroy(options)](#queuedestroyoptions)\n- [Exchange](#exchange)\n  - [exchange.on('open', callback)](#exchangeon'open'-callback)\n  - [connection.exchange()](#connectionexchange)\n  - [connection.exchange(name, options={}, openCallback)](#connectionexchangename-options={}-opencallback)\n  - [exchange.publish(routingKey, message, options, callback)](#exchangepublishroutingkey-message-options-callback)\n  - [exchange.destroy(ifUnused = true)](#exchangedestroyifunused-=-true)\n  - [exchange.bind(srcExchange, routingKey [, callback])](#exchangebindsrcexchange-routingkey--callback)\n  - [exchange.unbind(srcExchange, routingKey [, callback])](#exchangeunbindsrcexchange-routingkey--callback)\n  - [exchange.bind_headers(exchange, routing [, bindCallback])](#exchangebind_headersexchange-routing--bindcallback)\n\n## Installation\n\n    npm install amqp\n\n## Synopsis\n\nIMPORTANT: This module only works with node v0.4.0 and later.\n\nAn example of connecting to a server and listening on a queue.\n\n```javascript\nvar amqp = require('amqp');\n\nvar connection = amqp.createConnection({ host: 'dev.rabbitmq.com' });\n\n// Wait for connection to become established.\nconnection.on('ready', function () {\n  // Use the default 'amq.topic' exchange\n  connection.queue('my-queue', function(q){\n      // Catch all messages\n      q.bind('#');\n    \n      // Receive messages\n      q.subscribe(function (message) {\n        // Print messages to stdout\n        console.log(message);\n      });\n  });\n});\n```\n\n## Connection\n\n`new amqp.Connection()` Instantiates a new connection. Use\n`connection.connect()` to connect to a server.\n\n`amqp.createConnection()` returns an instance of `amqp.Connection`, which contains\nan instance of `net.Socket` at its `socket` property. All events and methods which work on\n`net.Socket` can also be used on an `amqp.Connection` instance. (e.g., the\nevents `'connect'` and `'close'`.)\n\n### Connection options and URL\n\n`amqp.createConnection([options, [implOptions]])` takes two options\nobjects as parameters.  The first options object has these defaults:\n\n    { host: 'localhost'\n    , port: 5672\n    , login: 'guest'\n    , password: 'guest'\n    , authMechanism: 'AMQPLAIN'\n    , vhost: '/'\n    , ssl: { enabled : false\n           }\n    }\n\nAn example `options` object for creating an SSL connection has these properties:\n\n    { host: 'localhost'\n    , port: 5671\n    , login: 'guest'\n    , password: 'guest'\n    , authMechanism: 'AMQPLAIN'\n    , vhost: '/'\n    , ssl: { enabled : true\n           , keyFile : '/path/to/key/file'\n           , certFile : '/path/to/cert/file'\n           , caFile : '/path/to/cacert/file'\n           , rejectUnauthorized : true\n           }\n    }\n\nThe key, certificate, and certificate authority files must be in pem format.\nIf `port` is not specified, the default AMQPS port 5671 is used.\nIf `rejectUnauthorized` is not specified, it defaults to true.\n\nOptions can also be passed in a single URL of the form\n\n    amqp[s]://[user:password@]hostname[:port][/vhost]\n\nAMQPLAIN is assumed for the auth mechanism.\n\nNote that the vhost must be URL-encoded and appear as the only segment\nof the path, i.e., the only unencoded slash is that leading; leaving\nthe path entirely empty indicates that the vhost `/`, as\nabove, should be used (it could also be supplied as the path `/%2f`).\n\nThis URL is supplied as the field `url` in the options; for example\n\n```javascript\nvar conn =\n  amqp.createConnection({url: \"amqp://guest:guest@localhost:5672\"});\n\n```\n\n\nOptions provided as individual fields will override values given in\nthe URL.\n\n\nYou can also specify additional client properties for your connection\nby setting the `clientProperties` field on the `options` object.\n\n    { clientProperties: { applicationName: 'myApplication'\n                        }\n    }\n\nBy default the following client properties are set\n\n    { product: 'node-amqp'\n    , platform: 'node-' + process.version\n    , version: nodeAMQPVersion\n    }\n\n\nThe second options are specific to the node AMQP implementation. It has\nthe default values:\n\n    { defaultExchangeName: ''\n    , reconnect: true\n    , reconnectBackoffStrategy: 'linear'\n    , reconnectExponentialLimit: 120000\n    , reconnectBackoffTime: 1000\n    }\n\nThe defaultExchangeName is the default exchange to which\nconnection.publish will publish. In the past, the default exchange was\n`amq.topic`, which is not ideal.  To emulate this behaviour, one can\ncreate a connection like:\n\n```javascript\nvar conn =\n  amqp.createConnection({url: \"amqp://guest:guest@localhost:5672\"},\n                        {defaultExchangeName: \"amq.topic\"});\n```\n\n If the `reconnect` option is true, then the driver will attempt to reconnect using the\n configured strategy *any time* the connection becomes unavailable.  If this is not\n appropriate for your application, set this option to false.\n\n If you would like this option, you can set parameters controlling how aggressively the\n reconnections will be attempted.  Valid strategies are \"linear\" and \"exponential\".\n\n Backoff times are in milliseconds.  Under the \"linear\" strategy, the driver will pause\n `reconnectBackoffTime` ms before the first attempt, and between each subsequent attempt.\n Under the \"exponential\" strategy, the driver will pause `reconnectBackoffTime` ms before\n the first attempt, and will double the previous pause between each subsequent attempt\n until a connection is reestablished.\n\nAfter a connection is established the `'connect'` event is fired as it is\nwith any `net.Connection` instance. AMQP requires a 7-way handshake which\nmust be completed before any communication can begin. `net.Connection` does\nthe handshake automatically and emits the `'ready'` event when the handshaking\nis complete.\n\nFor backward compatibility, two additional options are available. Older\nversions of this library placed the routingKey and deliveryTag for incoming\nmessages into the JSON payload received. This module was changed to\nleave inbound JSON payloads pristine.  Some applications may need the\nold behaviour. If the key `routingKeyInPayload` is set to true in the\nconnection `options`, the messages resulting from a subscribe call will\ninclude a 'routingKey' key in the JSON payload.  If the key\n`deliveryTagInPayload` is set to true in the connection options, the\ndeliveryTag of the incoming message will be placed in the JSON payload.\n\n\n### connection.publish(queueName, body, options, callback)\n\nPublishes a message to the default exchange; if the defaultExchange is\nleft as `''`, this effectively publishes the message to the queue\nnamed.\n\nThis method proxies to the default exchange's `publish` method and parameters are passed\nthrough untouched.\n\n### connection.end()\n\n`amqp.Connection` is derived from `net.Stream` and has all the same methods.\nSo use `connection.end()` to terminate a connection gracefully.\n\n\n\n\n## Queue\n\nEvents: A queue will call the callback given to the `connection.queue()`\nmethod once it is usable. For example:\n\n```javascript\nvar q = connection.queue('my-queue', function (queue) {\n  console.log('Queue ' + queue.name + ' is open');\n});\n```\n\n\nDeclaring a queue with an empty name will make the server generate a\nrandom name.\n\n### connection.queue(name, options, openCallback)\n\nReturns a reference to a queue. The options are\n\n- `passive`: boolean, default false.\n    If set, the server will not create the queue.  The client can use\n    this to check whether a queue exists without modifying the server\n    state.\n- `durable`: boolean, default false.\n    Durable queues remain active when a server restarts.\n    Non-durable queues (transient queues) are purged if/when a\n    server restarts.  Note that durable queues do not necessarily\n    hold persistent messages, although it does not make sense to\n    send persistent messages to a transient queue.\n- `exclusive`: boolean, default false.\n    Exclusive queues may only be consumed from by the current connection.\n    Setting the 'exclusive' flag always implies 'autoDelete'.\n- `autoDelete`: boolean, default true.\n    If set, the queue is deleted when all consumers have finished\n    using it. Last consumer can be cancelled either explicitly or because\n    its channel is closed. If there was no consumer ever on the queue, it\n    won't be deleted.\n- `noDeclare`: boolean, default false.\n    If set, the queue will not be declared, this will allow a queue to be\n    deleted if you don't know its previous options.\n- `arguments`: a map of additional arguments to pass in when creating a queue.\n- `closeChannelOnUnsubscribe` : a boolean when true the channel will close on \n    unsubscrube, default false.\n\n### queue.subscribe([options,] listener)\n\nAn easy subscription command. It works like this\n\n```javascript\nq.subscribe(function (message, headers, deliveryInfo) {\n  console.log('Got a message with routing key ' + deliveryInfo.routingKey);\n});\n    \n```\n\nIt will automatically acknowledge receipt of each message.\n\nThere are several options available.  Setting the options argument to\n`{ ack: true }` (which defaults to false) will make it so that the AMQP\nserver only delivers a single message at a time. When you want the next\nmessage, call `q.shift()`. When `ack` is false then you will receive\nmessages as fast as they come in. \n\nYou can also use the prefetchCount option to increase the window of how\nmany messages the server will send you before you need to ack (quality of service).\n`{ ack: true, prefetchCount: 1 }` is the default and will only send you one\nmessage before you ack. Setting prefetchCount to 0 will make that window unlimited.\n\nThe `routingKeyInPayload` and `deliveryKeyInPayload` options determine\nif the reception process will inject the routingKey and deliveryKey,\nrespectively, into the JSON payload received.  These default to unset\nthus adopting the parent connection's values (which default to false).\nSetting these to true provide backward compatibility for older\napplications.\n\nThe `exclusive` option will subscribe to the queue in exclusive mode. Only one\nsubscriber is allowed at a time, and subsequent attempts to subscribe to the\nsame queue will result in an exception. This option differs from the exclusive\noption passed when creating in a queue in that the queue itself is not exclusive,\nonly the consumers. This means that long lived durable queues can be used\nas exclusive queues.\n\nThis method will emit `'basicQosOk'` when ready.\n\n\n### queue.subscribeRaw([options,] listener)\n\nSubscribes to a queue. The `listener` argument should be a function which\nreceives a message. This is a low-level interface - the message that the\nlistener receives will be a stream of binary data. You probably want to use\n`subscribe` instead. For now this low-level interface is left undocumented.\nLook at the source code if you need to do this.\n\nThis method will emit `'basicConsumeOk'` when ready.\n\n### queue.unsubscribe(consumerTag)\n\nUnsubscribe from a queue, given the consumer tag. The consumer tag is\nsupplied to the *promise callback* of `Queue.subscribeRaw` or\n`Queue.subscribe`:\n\n```javascript\nconnection.queue('foo', function(queue) {\n  var ctag;\n  queue.subscribe(function(msg) {...})\n    .addCallback(function(ok) { ctag = ok.consumerTag; });\n  // ... and in some other callback\n  queue.unsubscribe(ctag);\n});\n```\n\nNote that `Queue.unsubscribe` will not requeue messages that have not\nbeen acknowledged. You need to close the queue or connection for that\nto happen. You may also receive messages after calling `unsubscribe`;\nyou will **not** receive messages from the queue after the unsubscribe\npromise callback has been invoked, however.\n\n### queue.shift([reject[, requeue]])\n\nFor use with `subscribe({ack: true}, fn)`. Acknowledges the last\nmessage if no arguments are provided or if `reject` is false. If\n`reject` is true then the message will be rejected and put back onto\nthe queue if `requeue` is true, otherwise it will be discarded.\n\n\n### queue.bind([exchange,] routing)\n\nThis method binds a queue to an exchange.  Until a queue is\nbound it will not receive any messages, unless they are sent through\nthe unnamed exchange (see `defaultExchangeName` above).\n\nIf the `exchange` argument is left out `'amq.topic'` will be used.\n\nThis method will emit `'queueBindOk'` when complete.\n\n\n### queue.unbind([exchange,] routing)\n\nThis method unbinds a queue from an exchange.\n\nIf the exchange argument is left out `'amq.topic'` will be used.\n\nThs method will emit `'queueUnbindOk'` when complete.\n\n\n### queue.bind_headers([exchange,] routing)\n\nThis method binds a queue to an exchange.  Until a queue is\nbound it will not receive any messages.\n\nThis method is to be used on an \"headers\"-type exchange. The routing\nargument must contain the routing keys and the `x-match` value (`all` or `any`).\n\nIf the `exchange` argument is left out `'amq.headers'` will be used.\n\n### queue.destroy(options)\n\nDelete the queue. Without options, the queue will be deleted even if it has\npending messages or attached consumers. If +options.ifUnused+ is true, then\nthe queue will only be deleted if there are no consumers. If\n+options.ifEmpty+ is true, the queue will only be deleted if it has no\nmessages.\n\n\n\n\n## Exchange\n\nEvents: An exchange will call the callback given to the `connection.exchange()`\nmethod once it is usable. For example:\n\n```javascript\nvar exc = connection.exchange('my-exchange', function (exchange) {\n  console.log('Exchange ' + exchange.name + ' is open');\n});\n```\n\n### exchange.on('open', callback)\n\nThe open event is emitted when the exchange is declared and ready to\nbe used. This interface is considered deprecated.\n\n\n### connection.exchange()\n### connection.exchange(name, options={}, openCallback)\n\nAn exchange can be created using `connection.exchange()`. The method returns\nan `amqp.Exchange` object.\n\nWithout any arguments, this method returns the default exchange.\nOtherwise a string, `name`, is given as the first argument and an `options`\nobject for the second. The options are\n\n- `type`: the type of exchange `'direct'`, `'fanout'`, or `'topic'` (default).\n- `passive`: boolean, default false.\n    If set, the server will not create the exchange.  The client can use\n    this to check whether an exchange exists without modifying the server\n    state.\n- `durable`: boolean, default false.\n    If set when creating a new exchange, the exchange will be marked as\n    durable.  Durable exchanges remain active when a server restarts.\n    Non-durable exchanges (transient exchanges) are purged if/when a\n    server restarts.\n- `confirm`: boolean, default false.\n    If set when connecting to a exchange the channel will send acks \n    for publishes. Published tasks will emit 'ack' when it is acked.\n- `autoDelete`: boolean, default true.\n    If set, the exchange is deleted when there are no longer queues\n    bound to it.\n- `noDeclare`: boolean, default false.\n    If set, the exchange will not be declared, this will allow the exchange\n    to be deleted if you dont know its previous options.\n- `confirm`: boolean, default false.\n    If set, the exchange will be in confirm mode, and you will get a \n    'ack'|'error' event emitted on a publish, or the callback on the publish\n    will be called.\n\nAn exchange will emit the `'open'` event when it is finally declared.\n\n\n### exchange.publish(routingKey, message, options, callback)\n\nPublishes a message to the exchange. The `routingKey` argument is a string\nwhich helps routing in `topic` and `direct` exchanges. The `message` can be\neither a Buffer or Object. A Buffer is used for sending raw bytes; an Object\nis converted to JSON.\n\n`options` is an object with any of the following\n\n- `mandatory`: boolean, default false.\n    This flag tells the server how to react if the message cannot be\n    routed to a queue.  If this flag is set, the server will return an\n    unroutable message with a Return method.  If this flag is false, the\n    server silently drops the message.\n- `immediate`: boolean, default false.\n    This flag tells the server how to react if the message cannot be\n    routed to a queue consumer immediately.  If this flag is set, the\n    server will return an undeliverable message with a Return method.\n    If this flag is false, the server will queue the message, but with\n    no guarantee that it will ever be consumed.\n- `contentType`: default `'application/octet-stream'`\n- `contentEncoding`: default null.\n- `headers`: default `{}`. Arbitrary application-specific message headers.\n- `deliveryMode`: Non-persistent (1) or persistent (2)\n- `priority`: The message priority, 0 to 9.\n- `correlationId`: default null. Application correlation identifier\n- `replyTo`: Usually used to name a reply queue for a request message.\n- `expiration`: default null. Message expiration specification\n- `messageId`: default null. Application message identifier\n- `timestamp`: default null. Message timestamp\n- `type`: default null. Message type name\n- `userId`: default null. Creating user id\n- `appId`: default null. Creating application id\n\n`callback` is a function that will get called if the exchange is in confirm mode,\nthe value sent will be true or false, this is the presense of a error so true, means\nan error occured and false, means the publish was successfull\n\n### exchange.destroy(ifUnused = true)\n\nDeletes an exchange.\nIf the optional boolean second argument is set, the server will only\ndelete the exchange if it has no queue bindings. If the exchange has queue\nbindings the server does not delete it but raises a channel exception\ninstead.\n\n### exchange.bind(srcExchange, routingKey [, callback])\n\nBinds the exchange (destination) to the given source exchange (srcExchange). \nWhen one exchange is bound to another, the destination (or receiving) exchange \nwill receive all messages published to the source exchange that match the \ngiven routingKey. \n\nThis method will emit `'exchangeBindOk'` when complete.\n\nPlease note that Exchange to Exchange Bindings (E2E) are an extension to the \nAMQP spec introduced by RabbitMQ, and that by using this feature, you will be \nreliant on RabbitMQ's AMQP implementation. For more information on E2E \nBindings with RabbitMQ see:\n\nhttp://www.rabbitmq.com/e2e.html\n\n### exchange.unbind(srcExchange, routingKey [, callback])\n\nUnbinds the exchange (destination) from the given source exchange (srcExchange). \nThis is the reverse of the exchange.bind method above, and will stop messages \nfrom srcExchange/routingKey from being sent to the destination exchange. \n\nThis method will emit `'exchangeUnbindOk'` when complete.\n\n### exchange.bind_headers(exchange, routing [, bindCallback])\n\nThis method is to be used on an \"headers\"-type exchange. The routing\nargument must contain the routing keys and the `x-match` value (`all` or `any`).\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/postwait/node-amqp",
  "_id": "amqp@0.1.8",
  "dist": {
    "shasum": "ad7833122c82e53d9dc64fcb9a367d741cb9c52e"
  },
  "_from": "amqp@0.1.8",
  "_resolved": "https://registry.npmjs.org/amqp/-/amqp-0.1.8.tgz"
}
