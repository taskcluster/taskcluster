var base      = require('taskcluster-base');

// Common schema prefix
var SCHEMA_PREFIX_CONST = 'http://schemas.taskcluster.net/queue/v1/';

/** Declaration of exchanges offered by the queue */
var exchanges = new base.Exchanges({
  title:      "Queue AMQP Exchanges",
  description: [
    "The queue, typically available at `queue.taskcluster.net`, is responsible",
    "for accepting tasks and track their state as they are executed by",
    "workers. In order ensure they are eventually resolved.",
    "",
    "This document describes AMQP exchanges offered by the queue, which allows",
    "third-party listeners to monitor tasks as they progress to resolution.",
    "These exchanges targets the following audience:",
    " * Schedulers, who takes action after tasks are completed,",
    " * Workers, who wants to listen for new or canceled tasks (optional),",
    " * Tools, that wants to update their view as task progress.",
    "",
    "You'll notice that all the exchanges in the document shares the same",
    "routing key pattern. This makes it very easy to bind to all message about",
    "a certain kind tasks. You should also note that the `routing` property",
    "of a task will be used in the routing key. This property is user-defined",
    "and may contain dots (ie. multiple routing words).",
    "",
    "**Task-Graphs**, if the task-graph scheduler, documented elsewhere, is",
    "used to schedule a task-graph, the task submitted will have their",
    "`schedulerId` set to `task-graph-scheduler`, and their `taskGroupId` to",
    "the `taskGraphId` as given to the task-graph scheduler. This is useful if",
    "you wish to listen for all messages in a specific task-graph.",
    "",
    "**Delivery Guarantees**, most operations on the queue are idempotent,",
    "which means that if repeated with the same arguments then the requests",
    "will ensure completion of the operation and return the same response.",
    "This is useful if the server crashes or the TCP connection breaks, but",
    "when re-executing an idempotent operation, the queue will also resend",
    "any related AMQP messages. Hence, messages may be repeated.",
    "",
    "This shouldn't be much of a problem, as the best you can achieve using",
    "confirm messages with AMQP is at-least-once delivery semantics. Hence,",
    "this only prevents you from obtaining at-most-once delivery semantics.",
    "",
    "**Remark**, some message generated by timeouts maybe dropped if the",
    "server crashes at wrong time. Ideally, we'll address this in the",
    "future. For now we suggest you ignore this corner case."
  ].join('\n')
});

// Export exchanges
module.exports = exchanges;

/** Common routing key construct for `exchanges.declare` */
var commonRoutingKey = [
  {
    name:             'taskId',
    summary:          "`taskId` for the task this message concerns",
    multipleWords:    false,
    required:         true,
    maxSize:          22
  }, {
    name:             'runId',
    summary:          "`runId` of latest run for the task, " +
                      "`_` if no run is exists for the task.",
    multipleWords:    false,
    required:         false,
    maxSize:          3
  }, {
    name:             'workerGroup',
    summary:          "`workerGroup` of latest run for the task, " +
                      "`_` if no run is exists for the task.",
    multipleWords:    false,
    required:         false,
    maxSize:          22
  }, {
    name:             'workerId',
    summary:          "`workerId` of latest run for the task, " +
                      "`_` if no run is exists for the task.",
    multipleWords:    false,
    required:         false,
    maxSize:          22
  }, {
    name:             'provisionerId',
    summary:          "`provisionerId` this task is targeted at.",
    multipleWords:    false,
    required:         true,
    maxSize:          22
  }, {
    name:             'workerType',
    summary:          "`workerType` this task must run on.",
    multipleWords:    false,
    required:         true,
    maxSize:          22
  }, {
    name:             'schedulerId',
    summary:          "`schedulerId` this task was created by.",
    multipleWords:    false,
    required:         true,
    maxSize:          22
  }, {
    name:             'taskGroupId',
    summary:          "`taskGroupId` this task was created in.",
    multipleWords:    false,
    required:         true,
    maxSize:          22
  }, {
    name:             'routing',
    summary:          "task-specific routing key (`task.routing`).",
    multipleWords:    true,
    required:         true,
    maxSize:          90
  }
];

/** Build an AMQP compatible message from a message */
var commonMessageBuilder = function(message) {
  message.version = 1;
  return message;
};

/** Build a message from message */
var commonRoutingKeyBuilder = function(message, routing) {
  return {
    taskId:           message.status.taskId,
    runId:            message.runId,
    workerGroup:      message.workerGroup,
    workerId:         message.workerId,
    provisionerId:    message.status.provisionerId,
    workerType:       message.status.workerType,
    schedulerId:      message.status.schedulerId,
    taskGroupId:      message.status.taskGroupId,
    routing:          routing
  };
};

/** Task defined exchange */
exchanges.declare({
  exchange:           'task-defined',
  name:               'taskDefined',
  title:              "Task Defined Messages",
  description: [
    "When a task is created or just defined a message is posted to this",
    "exchange.",
    "",
    "This message exchange is mainly useful when tasks are scheduled by a",
    "scheduler that uses `defineTask` as this does not make the task",
    "`pending`. Thus, no `taskPending` message is published.",
    "Please, note that messages are also published on this exchange if defined",
    "using `createTask`."
  ].join('\n'),
  routingKey:         commonRoutingKey,
  schema:             SCHEMA_PREFIX_CONST + 'task-defined-message.json#',
  messageBuilder:     commonMessageBuilder,
  routingKeyBuilder:  commonRoutingKeyBuilder
});

/** Task pending exchange */
exchanges.declare({
  exchange:           'task-pending',
  name:               'taskPending',
  title:              "Task Pending Messages",
  description: [
    "When a task becomes `pending` a message is posted to this exchange.",
    "",
    "This is useful for workers who doesn't want to constantly poll the queue",
    "for new tasks. The queue will also be authority for task states and",
    "claims. But using this exchange workers should be able to distribute work",
    "efficiently and they would be able to reduce their polling interval",
    "significantly without affecting general responsiveness."
  ].join('\n'),
  routingKey:         commonRoutingKey,
  schema:             SCHEMA_PREFIX_CONST + 'task-pending-message.json#',
  messageBuilder:     commonMessageBuilder,
  routingKeyBuilder:  commonRoutingKeyBuilder
});


/** Task running exchange */
exchanges.declare({
  exchange:           'task-running',
  name:               'taskRunning',
  title:              "Task Running Messages",
  description: [
    "Whenever a task is claimed by a worker, a run is started on the worker,",
    "and a message is posted on this exchange.",
    "",
    "**Notice**, that the `logsUrl` may return `404` during the run, but by",
    "the end of the run the `logsUrl` will be valid. But this may not have",
    "happened when this message is posted.",
    "",
    "The idea is that workers can choose to upload the `logs.json` file as the",
    "first thing they do, in which case it'll often be available after a few",
    "minutes. This is useful if the worker supports live logging."
  ].join('\n'),
  routingKey:         commonRoutingKey,
  schema:             SCHEMA_PREFIX_CONST + 'task-running-message.json#',
  messageBuilder:     commonMessageBuilder,
  routingKeyBuilder:  commonRoutingKeyBuilder
});


/** Task completed exchange */
exchanges.declare({
  exchange:           'task-completed',
  name:               'taskCompleted',
  title:              "Task Completed Messages",
  description: [
    "When a task is completed by a worker a message is posted this exchange.",
    "This message is routed using the `run-id`, `worker-group` and `worker-id`",
    "that completed the task. But information about additional runs is also",
    "available from the task status structure.",
    "",
    "Upon task completion a result structure is made available, you'll find",
    "the url in the `resultURL` property. See _task storage_ documentation for",
    "details on the format of the file available through `resultUrl`."
  ].join('\n'),
  routingKey:         commonRoutingKey,
  schema:             SCHEMA_PREFIX_CONST + 'task-completed-message.json#',
  messageBuilder:     commonMessageBuilder,
  routingKeyBuilder:  commonRoutingKeyBuilder
});


/** Task failed exchange */
exchanges.declare({
  exchange:           'task-failed',
  name:               'taskFailed',
  title:              "Task Failed Messages",
  description: [
    "Whenever a task is concluded to be failed a message is posted to this",
    "exchange. This happens if the task isn't completed before its `deadl√¨ne`,",
    "all retries failed (i.e. workers stopped responding) or the task was",
    "canceled by another entity.",
    "",
    "The specific _reason_ is evident from that task status structure, refer",
    "to the `reason` property."
  ].join('\n'),
  routingKey:         commonRoutingKey,
  schema:             SCHEMA_PREFIX_CONST + 'task-failed-message.json#',
  messageBuilder:     commonMessageBuilder,
  routingKeyBuilder:  commonRoutingKeyBuilder
});

