#![allow(unused_imports)]
#![cfg_attr(rustfmt, rustfmt_skip)]
/* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT */
use crate::{Client, ClientBuilder, Credentials, Retry};
use anyhow::Error;
use serde_json::Value;
use std::time::Duration;
use crate::util::urlencode;

/// Web Server Service
///
/// The web-server service provides a GraphQL gateway to Taskcluster APIs,
/// as well as profiler endpoints that generate Firefox Profiler–compatible
/// profiles from task group metadata and task logs.
pub struct WebServer {
    /// The underlying client used to make API calls for this service.
    pub client: Client
}

#[allow(non_snake_case)]
impl WebServer {
    /// Create a new WebServer instance, based on the given client builder
    pub fn new<CB: Into<ClientBuilder>>(client_builder: CB) -> Result<Self, Error> {
        Ok(Self{
            client: client_builder
                .into()
                .path_prefix("api/web-server/v1/")
                .build()?,
        })
    }

    /// Ping Server
    ///
    /// Respond without doing anything.
    /// This endpoint is used to check that the service is up.
    pub async fn ping(&self) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::ping_details();
        let body = None;
        let resp = self.client.request(method, path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the ping endpoint
    pub fn ping_url(&self) -> Result<String, Error> {
        let (path, query) = Self::ping_details();
        self.client.make_url(path, query)
    }

    /// Generate a signed URL for the ping endpoint
    pub fn ping_signed_url(&self, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::ping_details();
        self.client.make_signed_url(path, query, ttl)
    }

    /// Determine the HTTP request details for ping
    fn ping_details<'a>() -> (&'static str, Option<Vec<(&'static str, &'a str)>>) {
        let path = "ping";
        let query = None;

        (path, query)
    }

    /// Load Balancer Heartbeat
    ///
    /// Respond without doing anything.
    /// This endpoint is used to check that the service is up.
    pub async fn lbheartbeat(&self) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::lbheartbeat_details();
        let body = None;
        let resp = self.client.request(method, path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the lbheartbeat endpoint
    pub fn lbheartbeat_url(&self) -> Result<String, Error> {
        let (path, query) = Self::lbheartbeat_details();
        self.client.make_url(path, query)
    }

    /// Generate a signed URL for the lbheartbeat endpoint
    pub fn lbheartbeat_signed_url(&self, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::lbheartbeat_details();
        self.client.make_signed_url(path, query, ttl)
    }

    /// Determine the HTTP request details for lbheartbeat
    fn lbheartbeat_details<'a>() -> (&'static str, Option<Vec<(&'static str, &'a str)>>) {
        let path = "__lbheartbeat__";
        let query = None;

        (path, query)
    }

    /// Taskcluster Version
    ///
    /// Respond with the JSON version object.
    /// https://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md
    pub async fn version(&self) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::version_details();
        let body = None;
        let resp = self.client.request(method, path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the version endpoint
    pub fn version_url(&self) -> Result<String, Error> {
        let (path, query) = Self::version_details();
        self.client.make_url(path, query)
    }

    /// Generate a signed URL for the version endpoint
    pub fn version_signed_url(&self, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::version_details();
        self.client.make_signed_url(path, query, ttl)
    }

    /// Determine the HTTP request details for version
    fn version_details<'a>() -> (&'static str, Option<Vec<(&'static str, &'a str)>>) {
        let path = "__version__";
        let query = None;

        (path, query)
    }

    /// Task Group Profile
    ///
    /// Generate a Firefox Profiler–compatible profile from a task group.
    /// The profile contains scheduling and execution timing for all tasks.
    pub async fn taskGroupProfile(&self, taskGroupId: &str) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::taskGroupProfile_details(taskGroupId);
        let body = None;
        let resp = self.client.request(method, &path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the taskGroupProfile endpoint
    pub fn taskGroupProfile_url(&self, taskGroupId: &str) -> Result<String, Error> {
        let (path, query) = Self::taskGroupProfile_details(taskGroupId);
        self.client.make_url(&path, query)
    }

    /// Generate a signed URL for the taskGroupProfile endpoint
    pub fn taskGroupProfile_signed_url(&self, taskGroupId: &str, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::taskGroupProfile_details(taskGroupId);
        self.client.make_signed_url(&path, query, ttl)
    }

    /// Determine the HTTP request details for taskGroupProfile
    fn taskGroupProfile_details<'a>(taskGroupId: &'a str) -> (String, Option<Vec<(&'static str, &'a str)>>) {
        let path = format!("task-group/{}/profile", urlencode(taskGroupId));
        let query = None;

        (path, query)
    }

    /// Task Log Profile
    ///
    /// Generate a Firefox Profiler–compatible profile from a task's log output.
    /// Parses `public/logs/live.log` (or `live_backing.log`) for timing data.
    pub async fn taskProfile(&self, taskId: &str) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::taskProfile_details(taskId);
        let body = None;
        let resp = self.client.request(method, &path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the taskProfile endpoint
    pub fn taskProfile_url(&self, taskId: &str) -> Result<String, Error> {
        let (path, query) = Self::taskProfile_details(taskId);
        self.client.make_url(&path, query)
    }

    /// Generate a signed URL for the taskProfile endpoint
    pub fn taskProfile_signed_url(&self, taskId: &str, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::taskProfile_details(taskId);
        self.client.make_signed_url(&path, query, ttl)
    }

    /// Determine the HTTP request details for taskProfile
    fn taskProfile_details<'a>(taskId: &'a str) -> (String, Option<Vec<(&'static str, &'a str)>>) {
        let path = format!("task/{}/profile", urlencode(taskId));
        let query = None;

        (path, query)
    }

    /// Heartbeat
    ///
    /// Respond with a service heartbeat.
    ///
    /// This endpoint is used to check on backing services this service
    /// depends on.
    pub async fn heartbeat(&self) -> Result<(), Error> {
        let method = "GET";
        let (path, query) = Self::heartbeat_details();
        let body = None;
        let resp = self.client.request(method, path, query, body).await?;
        resp.bytes().await?;
        Ok(())
    }

    /// Generate an unsigned URL for the heartbeat endpoint
    pub fn heartbeat_url(&self) -> Result<String, Error> {
        let (path, query) = Self::heartbeat_details();
        self.client.make_url(path, query)
    }

    /// Generate a signed URL for the heartbeat endpoint
    pub fn heartbeat_signed_url(&self, ttl: Duration) -> Result<String, Error> {
        let (path, query) = Self::heartbeat_details();
        self.client.make_signed_url(path, query, ttl)
    }

    /// Determine the HTTP request details for heartbeat
    fn heartbeat_details<'a>() -> (&'static str, Option<Vec<(&'static str, &'a str)>>) {
        let path = "__heartbeat__";
        let query = None;

        (path, query)
    }
}
