// Code generated by `go generate ./apis`; DO NOT EDIT
//
//go:generate go run ../codegen/cmd/gen-services
package apis

import "github.com/taskcluster/taskcluster/v47/clients/client-shell/apis/definitions"

var services = map[string]definitions.Service{
	"Auth": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "auth",
		Title:       "Auth Service",
		Description: "Authentication related API end-points for Taskcluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authorize a request signed with Taskcluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listClients",
				Title:       "List Clients",
				Description: "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.\n\nBy default this end-point will try to return up to 1000 clients in one\nrequest. But it **may return less, even none**.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listClients` with the last `continuationToken` until you\nget a result without a `continuationToken`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/",
				Args:        []string{},
				Query: []string{
					"prefix",
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "client",
				Title:       "Get Client",
				Description: "Get information about a single client.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createClient",
				Title:       "Create Client",
				Description: "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "v1/create-client-request.json#",
			},
			definitions.Entry{
				Name:        "resetAccessToken",
				Title:       "Reset `accessToken`",
				Description: "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/reset",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "updateClient",
				Title:       "Update Client",
				Description: "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "v1/create-client-request.json#",
			},
			definitions.Entry{
				Name:        "enableClient",
				Title:       "Enable Client",
				Description: "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/enable",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "disableClient",
				Title:       "Disable Client",
				Description: "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/disable",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "deleteClient",
				Title:       "Delete Client",
				Description: "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listRoles",
				Title:       "List Roles (no pagination)",
				Description: "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This always returns all roles in a single HTTP\nrequest.\n\nTo get paginated results, use `listRoles2`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listRoles2",
				Title:       "List Roles",
				Description: "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This is similar to `listRoles` but differs in the\nformat of the response.\n\nIf no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles2/",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listRoleIds",
				Title:       "List Role IDs",
				Description: "Get a list of all role IDs.\n\nIf no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roleids/",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "role",
				Title:       "Get Role",
				Description: "Get information about a single role, including the set of scopes that the\nrole expands to.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createRole",
				Title:       "Create Role",
				Description: "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.\n\nCreation of a role that will generate an infinite expansion will result\nin an error response.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "v1/create-role-request.json#",
			},
			definitions.Entry{
				Name:        "updateRole",
				Title:       "Update Role",
				Description: "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the role's existing scopes.\n\nAn update of a role that will generate an infinite expansion will result\nin an error response.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "v1/create-role-request.json#",
			},
			definitions.Entry{
				Name:        "deleteRole",
				Title:       "Delete Role",
				Description: "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "expandScopes",
				Title:       "Expand Scopes",
				Description: "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/scopes/expand",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/scopeset.json#",
			},
			definitions.Entry{
				Name:        "currentScopes",
				Title:       "Get Current Scopes",
				Description: "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
				Stability:   "stable",
				Method:      "get",
				Route:       "/scopes/current",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "awsS3Credentials",
				Title:       "Get Temporary Read/Write Credentials S3",
				Description: "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets, as configured\nin the Taskcluster deployment\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
				Stability:   "stable",
				Method:      "get",
				Route:       "/aws/s3/<level>/<bucket>/<prefix>",
				Args: []string{
					"level",
					"bucket",
					"prefix",
				},
				Query: []string{
					"format",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureAccounts",
				Title:       "List Accounts Managed by Auth",
				Description: "Retrieve a list of all Azure accounts managed by Taskcluster Auth.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/azure/accounts",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "azureTables",
				Title:       "List Tables in an Account Managed by Auth",
				Description: "Retrieve a list of all tables in an account.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/azure/<account>/tables",
				Args: []string{
					"account",
				},
				Query: []string{
					"continuationToken",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureTableSAS",
				Title:       "Get Shared-Access-Signature for Azure Table",
				Description: "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ntable if it doesn't already exist.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/azure/<account>/table/<table>/<level>",
				Args: []string{
					"account",
					"table",
					"level",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureContainers",
				Title:       "List containers in an Account Managed by Auth",
				Description: "Retrieve a list of all containers in an account.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/azure/<account>/containers",
				Args: []string{
					"account",
				},
				Query: []string{
					"continuationToken",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureContainerSAS",
				Title:       "Get Shared-Access-Signature for Azure Container",
				Description: "Get a shared access signature (SAS) string for use with a specific Azure\nBlob Storage container.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ncontainer if it doesn't already exist.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/azure/<account>/containers/<container>/<level>",
				Args: []string{
					"account",
					"container",
					"level",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "sentryDSN",
				Title:       "Get DSN for Sentry Project",
				Description: "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
				Stability:   "stable",
				Method:      "get",
				Route:       "/sentry/<project>/dsn",
				Args: []string{
					"project",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "websocktunnelToken",
				Title:       "Get a client token for the Websocktunnel service",
				Description: "Get a temporary token suitable for use connecting to a\n[websocktunnel](https://github.com/taskcluster/taskcluster/tree/main/tools/websocktunnel) server.\n\nThe resulting token will only be accepted by servers with a matching audience\nvalue.  Reaching such a server is the callers responsibility.  In general,\na server URL or set of URLs should be provided to the caller as configuration\nalong with the audience value.\n\nThe token is valid for a limited time (on the scale of hours). Callers should\nrefresh it before expiration.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/websocktunnel/<wstAudience>/<wstClient>",
				Args: []string{
					"wstAudience",
					"wstClient",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "gcpCredentials",
				Title:       "Get Temporary GCP Credentials",
				Description: "Get temporary GCP credentials for the given serviceAccount in the given project.\n\nOnly preconfigured projects and serviceAccounts are allowed, as defined in the\ndeployment of the Taskcluster services.\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/gcp/credentials/<projectId>/<serviceAccount>",
				Args: []string{
					"projectId",
					"serviceAccount",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "authenticateHawk",
				Title:       "Authenticate Hawk Request",
				Description: "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on Taskcluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/authenticate-hawk",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/authenticate-hawk-request.json#",
			},
			definitions.Entry{
				Name:        "testAuthenticate",
				Title:       "Test Authentication",
				Description: "Utility method to test client implementations of Taskcluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/test-authenticate",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/test-authenticate-request.json#",
			},
			definitions.Entry{
				Name:        "testAuthenticateGet",
				Title:       "Test Authentication (GET)",
				Description: "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the\n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/test-authenticate-get/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Github": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "github",
		Title:       "GitHub Service",
		Description: "The github service is responsible for creating tasks in response\nto GitHub events, and posting results to the GitHub UI.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks, as well as some useful consumer APIs.\n\nWhen Github forbids an action, this service returns an HTTP 403\nwith code ForbiddenByGithub.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "githubWebHookConsumer",
				Title:       "Consume GitHub WebHook",
				Description: "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease, check run or pull request.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/github",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "builds",
				Title:       "List of Builds",
				Description: "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/builds",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
					"organization",
					"repository",
					"sha",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "badge",
				Title:       "Latest Build Status Badge",
				Description: "Checks the status of the latest build of a given branch\nand returns corresponding badge svg.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>/<branch>/badge.svg",
				Args: []string{
					"owner",
					"repo",
					"branch",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "repository",
				Title:       "Get Repository Info",
				Description: "Returns any repository metadata that is\nuseful within Taskcluster related services.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>",
				Args: []string{
					"owner",
					"repo",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "latest",
				Title:       "Latest Status for Branch",
				Description: "For a given branch of a repository, this will always point\nto a status page for the most recent task triggered by that\nbranch.\n\nNote: This is a redirect rather than a direct link.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>/<branch>/latest",
				Args: []string{
					"owner",
					"repo",
					"branch",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createStatus",
				Title:       "Post a status against a given changeset",
				Description: "For a given changeset (SHA) of a repository, this will attach a \"commit status\"\non github. These statuses are links displayed next to each revision.\nThe status is either OK (green check) or FAILURE (red cross),\nmade of a custom title and link.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/repository/<owner>/<repo>/statuses/<sha>",
				Args: []string{
					"owner",
					"repo",
					"sha",
				},
				Query: []string{},
				Input: "v1/create-status.json#",
			},
			definitions.Entry{
				Name:        "createComment",
				Title:       "Post a comment on a given GitHub Issue or Pull Request",
				Description: "For a given Issue or Pull Request of a repository, this will write a new message.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/repository/<owner>/<repo>/issues/<number>/comments",
				Args: []string{
					"owner",
					"repo",
					"number",
				},
				Query: []string{},
				Input: "v1/create-comment.json#",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Hooks": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "hooks",
		Title:       "Hooks Service",
		Description: "The hooks service provides a mechanism for creating tasks in response to events.\n",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listHookGroups",
				Title:       "List hook groups",
				Description: "This endpoint will return a list of all hook groups with at least one hook.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listHooks",
				Title:       "List hooks in a given group",
				Description: "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>",
				Args: []string{
					"hookGroupId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "hook",
				Title:       "Get hook definition",
				Description: "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "getHookStatus",
				Title:       "Get hook status",
				Description: "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.\n\nThis method is deprecated in favor of listLastFires.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/status",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createHook",
				Title:       "Create a hook",
				Description: "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/create-hook-request.json#",
			},
			definitions.Entry{
				Name:        "updateHook",
				Title:       "Update a hook",
				Description: "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/create-hook-request.json#",
			},
			definitions.Entry{
				Name:        "removeHook",
				Title:       "Delete a hook",
				Description: "This endpoint will remove a hook definition.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "triggerHook",
				Title:       "Trigger a hook",
				Description: "This endpoint will trigger the creation of a task from a hook definition.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/trigger",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/trigger-hook.json#",
			},
			definitions.Entry{
				Name:        "getTriggerToken",
				Title:       "Get a trigger token",
				Description: "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "resetTriggerToken",
				Title:       "Reset a trigger token",
				Description: "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "triggerHookWithToken",
				Title:       "Trigger a hook with a token",
				Description: "This endpoint triggers a defined hook with a valid token.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
				Args: []string{
					"hookGroupId",
					"hookId",
					"token",
				},
				Query: []string{},
				Input: "v1/trigger-hook.json#",
			},
			definitions.Entry{
				Name:        "listLastFires",
				Title:       "Get information about recent hook fires",
				Description: "This endpoint will return information about the the last few times this hook has been\nfired, including whether the hook was fired successfully or not\n\nBy default this endpoint will return up to 1000 most recent fires in one request.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/last-fires",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Index": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "index",
		Title:       "Index Service",
		Description: "The index service is responsible for indexing tasks. The service ensures that\ntasks can be located by user-defined names.\n\nAs described in the service documentation, tasks are typically indexed via Pulse\nmessages, so the most common use of API methods is to read from the index.\n\nSlashes (`/`) aren't allowed in index paths.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "findTask",
				Title:       "Find Indexed Task",
				Description: "Find a task by index path, returning the highest-rank task with that path. If no\ntask exists for the given path, this API end-point will respond with a 404 status.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<indexPath>",
				Args: []string{
					"indexPath",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listNamespaces",
				Title:       "List Namespaces",
				Description: "List the namespaces immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 namespaces. If more namespaces are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/namespaces/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listTasks",
				Title:       "List Tasks",
				Description: "List the tasks immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 tasks. If more tasks are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/tasks/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "insertTask",
				Title:       "Insert Task into Index",
				Description: "Insert a task into the index.  If the new rank is less than the existing rank\nat the given index path, the task is not indexed but the response is still 200 OK.\n\nPlease see the introduction above for information\nabout indexing successfully completed tasks automatically using custom routes.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/task/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{},
				Input: "v1/insert-task-request.json#",
			},
			definitions.Entry{
				Name:        "deleteTask",
				Title:       "Remove Task from Index",
				Description: "Remove a task from the index.  This is intended for administrative use,\nwhere an index entry is no longer appropriate.  The parent namespace is\nnot automatically deleted.  Index entries with lower rank that were\npreviously inserted will not re-appear, as they were never stored.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/task/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "findArtifactFromTask",
				Title:       "Get Artifact From Indexed Task",
				Description: "Find a task by index path and redirect to the artifact on the most recent\nrun with the given `name`.\n\nNote that multiple calls to this endpoint may return artifacts from differen tasks\nif a new task is inserted into the index between calls. Avoid using this method as\na stable link to multiple, connected files if the index path does not contain a\nunique identifier.  For example, the following two links may return unrelated files:\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/installer.exe`\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/debug-symbols.zip`\n\nThis problem be remedied by including the revision in the index path or by bundling both\ninstaller and debug symbols into a single artifact.\n\nIf no task exists for the given index path, this API end-point responds with 404.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<indexPath>/artifacts/<name>",
				Args: []string{
					"indexPath",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Notify": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "notify",
		Title:       "Notification Service",
		Description: "The notification service listens for tasks with associated notifications\nand handles requests to send emails and post pulse messages.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "email",
				Title:       "Send an Email",
				Description: "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/email",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/email-request.json#",
			},
			definitions.Entry{
				Name:        "pulse",
				Title:       "Publish a Pulse Message",
				Description: "Publish a message on pulse with the given `routingKey`.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/pulse",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/pulse-request.json#",
			},
			definitions.Entry{
				Name:        "matrix",
				Title:       "Post Matrix Message",
				Description: "Post a message to a room in Matrix. Optionally includes formatted message.\n\nThe `roomId` in the scopes is a fully formed `roomId` with leading `!` such\nas `!foo:bar.com`.\n\nNote that the matrix client used by taskcluster must be invited to a room before\nit can post there!",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/matrix",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/matrix-request.json#",
			},
			definitions.Entry{
				Name:        "slack",
				Title:       "Post Slack Message",
				Description: "Post a message to a Slack channel.\n\nThe `channelId` in the scopes is a Slack channel ID, starting with a capital C.\n\nThe Slack app can post into public channels by default but will need to be added\nto private channels before it can post messages there.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/slack",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/slack-request.json#",
			},
			definitions.Entry{
				Name:        "addDenylistAddress",
				Title:       "Denylist Given Address",
				Description: "Add the given address to the notification denylist. Addresses in the denylist will be ignored\nby the notification service.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/denylist/add",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/notification-address.json#",
			},
			definitions.Entry{
				Name:        "deleteDenylistAddress",
				Title:       "Delete Denylisted Address",
				Description: "Delete the specified address from the notification denylist.",
				Stability:   "experimental",
				Method:      "delete",
				Route:       "/denylist/delete",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/notification-address.json#",
			},
			definitions.Entry{
				Name:        "listDenylist",
				Title:       "List Denylisted Notifications",
				Description: "Lists all the denylisted addresses.\n\nBy default this end-point will try to return up to 1000 addresses in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `list` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/denylist/list",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Object": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "object",
		Title:       "Object Service",
		Description: "The object service provides HTTP-accessible storage for large blobs of data.\n\nObjects can be uploaded and downloaded, with the object data flowing directly\nfrom the storage \"backend\" to the caller, and not directly via this service.\nOnce uploaded, objects are immutable until their expiration time.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "createUpload",
				Title:       "Begin upload of a new object",
				Description: "Create a new object by initiating upload of its data.\n\nThis endpoint implements negotiation of upload methods.  It can be called\nmultiple times if necessary, either to propose new upload methods or to\nrenew credentials for an already-agreed upload.\n\nThe `name` parameter can contain any printable ASCII character (0x20 - 0x7e).\nThe `uploadId` must be supplied by the caller, and any attempts to upload\nan object with the same name but a different `uploadId` will fail.\nThus the first call to this method establishes the `uploadId` for the\nobject, and as long as that value is kept secret, no other caller can\nupload an object of that name, regardless of scopes.  Object expiration\ncannot be changed after the initial call, either.  It is possible to call\nthis method with no proposed upload methods, which has the effect of \"locking\nin\" the `expiration`, `projectId`, and `uploadId` properties and any\nsupplied hashes.\n\nUnfinished uploads expire after 1 day.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/upload/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "v1/create-upload-request.json#",
			},
			definitions.Entry{
				Name:        "finishUpload",
				Title:       "Mark an upload as complete.",
				Description: "This endpoint marks an upload as complete.  This indicates that all data has been\ntransmitted to the backend.  After this call, no further calls to `uploadObject` are\nallowed, and downloads of the object may begin.  This method is idempotent, but will\nfail if given an incorrect uploadId for an unfinished upload.\n\nIt is possible to finish an upload with no hashes specified via either\n`startUpload` or `finishUpload`.  However, many clients will refuse to\ndownload an object with no hashes.  The utility methods included with the\nclient libraries always include hashes as of version 44.0.0.\n\nNote that, once `finishUpload` is complete, the object is considered immutable.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/finish-upload/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "v1/finish-upload-request.json#",
			},
			definitions.Entry{
				Name:        "startDownload",
				Title:       "Download object data",
				Description: "Start the process of downloading an object's data.  Call this endpoint with a list of acceptable\ndownload methods, and the server will select a method and return the corresponding payload.\n\nReturns a 406 error if none of the given download methods are available.\n\nSee [Download Methods](https://docs.taskcluster.net/docs/reference/platform/object/download-methods) for more detail.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/start-download/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "v1/download-object-request.json#",
			},
			definitions.Entry{
				Name:        "object",
				Title:       "Get an object's metadata",
				Description: "Get the metadata for the named object.  This metadata is not sufficient to\nget the object's content; for that use `startDownload`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/metadata/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "download",
				Title:       "Get an object's data",
				Description: "Get the data in an object directly.  This method does not return a JSON body, but\nredirects to a location that will serve the object content directly.\n\nURLs for this endpoint, perhaps with attached authentication (`?bewit=..`),\nare typically used for downloads of objects by simple HTTP clients such as\nweb browsers, curl, or wget.\n\nThis method is limited by the common capabilities of HTTP, so it may not be\nthe most efficient, resilient, or featureful way to retrieve an artifact.\nSituations where such functionality is required should ues the\n`startDownload` API endpoint.\n\nSee [Simple Downloads](https://docs.taskcluster.net/docs/reference/platform/object/simple-downloads) for more detail.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/download/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"PurgeCache": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "purge-cache",
		Title:       "Purge Cache Service",
		Description: "The purge-cache service is responsible for tracking cache-purge requests.\n\nUser create purge requests for specific caches on specific workers, and\nthese requests are timestamped.  Workers consult the service before\nstarting a new task, and purge any caches older than the timestamp.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "purgeCache",
				Title:       "Purge Worker Cache",
				Description: "Publish a request to purge caches named `cacheName` with\non `workerPoolId` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/purge-cache/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/purge-cache-request.json#",
			},
			definitions.Entry{
				Name:        "allPurgeRequests",
				Title:       "All Open Purge Requests",
				Description: "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/purge-cache/list",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "purgeRequests",
				Title:       "Open Purge Requests for a worker pool",
				Description: "List the caches for this `workerPoolId` that should to be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/purge-cache/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{
					"since",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Queue": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "queue",
		Title:       "Queue Service",
		Description: "The queue service is responsible for accepting tasks and tracking their state\nas they are executed by workers, in order to ensure they are eventually\nresolved.\n\n## Artifact Storage Types\n\n* **Object artifacts** contain arbitrary data, stored via the object service.\n* **Redirect artifacts**, will redirect the caller to URL when fetched\nwith a a 303 (See Other) response.  Clients will not apply any kind of\nauthentication to that URL.\n* **Link artifacts**, will be treated as if the caller requested the linked\nartifact on the same task.  Links may be chained, but cycles are forbidden.\nThe caller must have scopes for the linked artifact, or a 403 response will\nbe returned.\n* **Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `424` (Failed Dependency) response. This is mainly designed to\nensure that dependent tasks can distinguish between artifacts that were\nsuppose to be generated and artifacts for which the name is misspelled.\n* **S3 artifacts** are used for static files which will be\nstored on S3. When creating an S3 artifact the queue will return a\npre-signed URL to which you can do a `PUT` request to upload your\nartifact. Note that `PUT` request **must** specify the `content-length`\nheader and **must** give the `content-type` header the same value as in\nthe request to `createArtifact`. S3 artifacts will be deprecated soon,\nand users should prefer object artifacts instead.\n\n## Artifact immutability\n\nGenerally speaking you cannot overwrite an artifact when created.\nBut if you repeat the request with the same properties the request will\nsucceed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nThe queue defines the following *immutability special cases*:\n\n* A `reference` artifact can replace an existing `reference` artifact.\n* A `link` artifact can replace an existing `reference` artifact.\n* Any artifact's `expires` can be extended (made later, but not earlier).",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "task",
				Title:       "Get Task Definition",
				Description: "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "status",
				Title:       "Get task status",
				Description: "Get task status structure from `taskId`",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/status",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listTaskGroup",
				Title:       "List Task Group",
				Description: "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task-group/<taskGroupId>/list",
				Args: []string{
					"taskGroupId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "sealTaskGroup",
				Title:       "Seal Task Group",
				Description: "Seal task group to prevent creation of new tasks.\n\nTask group can be sealed once and is irreversible. Calling it multiple times \nwill return same result and will not update it again.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/task-group/<taskGroupId>/seal",
				Args: []string{
					"taskGroupId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listDependentTasks",
				Title:       "List Dependent Tasks",
				Description: "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/dependents",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "createTask",
				Title:       "Create New Task",
				Description: "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline`**: the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**: the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice that artifacts created by a task must expire before the\ntask's expiration.\n\n**Task specific routing-keys**: using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific\nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key:\n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**: any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Scopes**: Note that the scopes required to complete this API call depend\non the content of the `scopes`, `routes`, `schedulerId`, `priority`,\n`provisionerId`, and `workerType` properties of the task definition.\n\nIf the task group was sealed, this end-point will return `409` reporting\n`RequestConflict` to indicate that it is no longer possible to add new tasks\nfor this `taskGroupId`.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "v1/create-task-request.json#",
			},
			definitions.Entry{
				Name:        "scheduleTask",
				Title:       "Schedule Defined Task",
				Description: "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/schedule",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "rerunTask",
				Title:       "Rerun a Resolved Task",
				Description: "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed. It will schedule a task that is _unscheduled_\nregardless of the state of its dependencies.\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent: if it is invoked for a task that\nis `pending` or `running`, it will just return the current task status.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/rerun",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "cancelTask",
				Title:       "Cancel Task",
				Description: "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/cancel",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "claimWork",
				Title:       "Claim Work",
				Description: "Claim pending task(s) for the given task queue.\n\nIf any work is available (even if fewer than the requested number of\ntasks, this will return immediately. Otherwise, it will block for tens of\nseconds waiting for work.  If no work appears, it will return an emtpy\nlist of tasks.  Callers should sleep a short while (to avoid denial of\nservice in an error condition) and call the endpoint again.  This is a\nsimple implementation of \"long polling\".",
				Stability:   "stable",
				Method:      "post",
				Route:       "/claim-work/<taskQueueId>",
				Args: []string{
					"taskQueueId",
				},
				Query: []string{},
				Input: "v1/claim-work-request.json#",
			},
			definitions.Entry{
				Name:        "claimTask",
				Title:       "Claim Task",
				Description: "claim a task - never documented",
				Stability:   "deprecated",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/claim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "v1/task-claim-request.json#",
			},
			definitions.Entry{
				Name:        "reclaimTask",
				Title:       "Reclaim task",
				Description: "Refresh the claim for a specific `runId` for given `taskId`. This updates\nthe `takenUntil` property and returns a new set of temporary credentials\nfor performing requests on behalf of the task. These credentials should\nbe used in-place of the credentials returned by `claimWork`.\n\nThe `reclaimTask` requests serves to:\n * Postpone `takenUntil` preventing the queue from resolving\n   `claim-expired`,\n * Refresh temporary credentials used for processing the task, and\n * Abort execution if the task/run have been resolved.\n\nIf the `takenUntil` timestamp is exceeded the queue will resolve the run\nas _exception_ with reason `claim-expired`, and proceeded to retry to the\ntask. This ensures that tasks are retried, even if workers disappear\nwithout warning.\n\nIf the task is resolved, this end-point will return `409` reporting\n`RequestConflict`. This typically happens if the task have been canceled\nor the `task.deadline` have been exceeded. If reclaiming fails, workers\nshould abort the task and forget about the given `runId`. There is no\nneed to resolve the run or upload artifacts.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/reclaim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportCompleted",
				Title:       "Report Run Completed",
				Description: "Report a task completed, resolving the run as `completed`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/completed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportFailed",
				Title:       "Report Run Failed",
				Description: "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/failed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportException",
				Title:       "Report Task Exception",
				Description: "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/exception",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "v1/task-exception-request.json#",
			},
			definitions.Entry{
				Name:        "createArtifact",
				Title:       "Create Artifact",
				Description: "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they expire. The queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This feature makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "v1/post-artifact-request.json#",
			},
			definitions.Entry{
				Name:        "finishArtifact",
				Title:       "Finish Artifact",
				Description: "This endpoint marks an artifact as present for the given task, and\nshould be called when the artifact data is fully uploaded.\n\nThe storage types `reference`, `link`, and `error` do not need to\nbe finished, as they are finished immediately by `createArtifact`.\nThe storage type `s3` does not support this functionality and cannot\nbe finished.  In all such cases, calling this method is an input error\n(400).",
				Stability:   "stable",
				Method:      "put",
				Route:       "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "v1/finish-artifact-request.json#",
			},
			definitions.Entry{
				Name:        "getArtifact",
				Title:       "Get Artifact Data from Run",
				Description: "Get artifact by `<name>` from a specific run.\n\n**Artifact Access**, in order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nTo allow access to fetch artifacts with a client like `curl` or a web\nbrowser, without using Taskcluster credentials, include a scope in the\n`anonymous` role.  The convention is to include\n`queue:get-artifact:public/*`.\n\n**Response**: the HTTP response to this method is a 303 redirect to the\nURL from which the artifact can be downloaded.  The body of that response\ncontains the data described in the output schema, contianing the same URL.\nCallers are encouraged to use whichever method of gathering the URL is\nmost convenient.  Standard HTTP clients will follow the redirect, while\nAPI client libraries will return the JSON body.\n\nIn order to download an artifact the following must be done:\n\n1. Obtain queue url.  Building a signed url with a taskcluster client is\nrecommended\n1. Make a GET request which does not follow redirects\n1. In all cases, if specified, the\nx-taskcluster-location-{content,transfer}-{sha256,length} values must be\nvalidated to be equal to the Content-Length and Sha256 checksum of the\nfinal artifact downloaded. as well as any intermediate redirects\n1. If this response is a 500-series error, retry using an exponential\nbackoff.  No more than 5 retries should be attempted\n1. If this response is a 400-series error, treat it appropriately for\nyour context.  This might be an error in responding to this request or\nan Error storage type body.  This request should not be retried.\n1. If this response is a 200-series response, the response body is the artifact.\nIf the x-taskcluster-location-{content,transfer}-{sha256,length} and\nx-taskcluster-location-content-encoding are specified, they should match\nthis response body\n1. If the response type is a 300-series redirect, the artifact will be at the\nlocation specified by the `Location` header.  There are multiple artifact storage\ntypes which use a 300-series redirect.\n1. For all redirects followed, the user must verify that the content-sha256, content-length,\ntransfer-sha256, transfer-length and content-encoding match every further request.  The final\nartifact must also be validated against the values specified in the original queue response\n1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`\nmust not occur\n\n**Headers**\nThe following important headers are set on the response to this method:\n\n* location: the url of the artifact if a redirect is to be performed\n* x-taskcluster-artifact-storage-type: the storage type.  Example: s3",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "getLatestArtifact",
				Title:       "Get Artifact Data from Latest Run",
				Description: "Get artifact by `<name>` from the last run of a task.\n\n**Artifact Access**, in order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nTo allow access to fetch artifacts with a client like `curl` or a web\nbrowser, without using Taskcluster credentials, include a scope in the\n`anonymous` role.  The convention is to include\n`queue:get-artifact:public/*`.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listArtifacts",
				Title:       "Get Artifacts from Run",
				Description: "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifacts",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listLatestArtifacts",
				Title:       "Get Artifacts from Latest Run",
				Description: "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifacts",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "artifactInfo",
				Title:       "Get Artifact Information From Run",
				Description: "Returns associated metadata for a given artifact, in the given task run.\nThe metadata is the same as that returned from `listArtifacts`, and does\nnot grant access to the artifact data.\n\nNote that this method does *not* automatically follow link artifacts.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifact-info/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "latestArtifactInfo",
				Title:       "Get Artifact Information From Latest Run",
				Description: "Returns associated metadata for a given artifact, in the latest run of the\ntask.  The metadata is the same as that returned from `listArtifacts`,\nand does not grant access to the artifact data.\n\nNote that this method does *not* automatically follow link artifacts.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifact-info/<name>",
				Args: []string{
					"taskId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "artifact",
				Title:       "Get Artifact Content From Run",
				Description: "Returns information about the content of the artifact, in the given task run.\n\nDepending on the storage type, the endpoint returns the content of the artifact\nor enough information to access that content.\n\nThis method follows link artifacts, so it will not return content\nfor a link artifact.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifact-content/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "latestArtifact",
				Title:       "Get Artifact Content From Latest Run",
				Description: "Returns information about the content of the artifact, in the latest task run.\n\nDepending on the storage type, the endpoint returns the content of the artifact\nor enough information to access that content.\n\nThis method follows link artifacts, so it will not return content\nfor a link artifact.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifact-content/<name>",
				Args: []string{
					"taskId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listProvisioners",
				Title:       "Get a list of all active provisioners",
				Description: "Get all active provisioners.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 provisioners in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getProvisioner",
				Title:       "Get an active provisioner",
				Description: "Get an active provisioner.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>",
				Args: []string{
					"provisionerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "declareProvisioner",
				Title:       "Update a provisioner",
				Description: "Declare a provisioner, supplying some details about it.\n\n`declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are\npossessed. For example, a request to update the `my-provisioner`\nprovisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope\n`queue:declare-provisioner:my-provisioner#description`.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
				Stability:   "deprecated",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>",
				Args: []string{
					"provisionerId",
				},
				Query: []string{},
				Input: "v1/update-provisioner-request.json#",
			},
			definitions.Entry{
				Name:        "pendingTasks",
				Title:       "Get Number of Pending Tasks",
				Description: "Get an approximate number of pending tasks for the given `taskQueueId`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/pending/<taskQueueId>",
				Args: []string{
					"taskQueueId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkerTypes",
				Title:       "Get a list of all active worker-types",
				Description: "Get all active worker-types for the given provisioner.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 worker-types in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types",
				Args: []string{
					"provisionerId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getWorkerType",
				Title:       "Get a worker-type",
				Description: "Get a worker-type from a provisioner.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "declareWorkerType",
				Title:       "Update a worker-type",
				Description: "Declare a workerType, supplying some details about it.\n\n`declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are\npossessed. For example, a request to update the `highmem` worker-type within the `my-provisioner`\nprovisioner with a body `{description: 'This worker type is great'}` would require you to have the scope\n`queue:declare-worker-type:my-provisioner/highmem#description`.",
				Stability:   "deprecated",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "v1/update-workertype-request.json#",
			},
			definitions.Entry{
				Name:        "listTaskQueues",
				Title:       "Get a list of all active task queues",
				Description: "Get all active task queues.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 task queues in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task-queues",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getTaskQueue",
				Title:       "Get a task queue",
				Description: "Get a task queue.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task-queues/<taskQueueId>",
				Args: []string{
					"taskQueueId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkers",
				Title:       "Get a list of all active workers of a workerType",
				Description: "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers.\nTo filter the query, you should call the end-point with `quarantined` as a query-string option with a\ntrue or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{
					"continuationToken",
					"limit",
					"quarantined",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getWorker",
				Title:       "Get a worker-type",
				Description: "Get a worker from a worker-type.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "quarantineWorker",
				Title:       "Quarantine a worker",
				Description: "Quarantine a worker",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/quarantine-worker-request.json#",
			},
			definitions.Entry{
				Name:        "declareWorker",
				Title:       "Declare a worker",
				Description: "Declare a worker, supplying some details about it.\n\n`declareWorker` allows updating one or more properties of a worker as long as the required scopes are\npossessed.",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/update-worker-request.json#",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Secrets": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "secrets",
		Title:       "Secrets Service",
		Description: "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "set",
				Title:       "Set Secret",
				Description: "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "v1/secret.json#",
			},
			definitions.Entry{
				Name:        "remove",
				Title:       "Delete Secret",
				Description: "Delete the secret associated with some key. It will succeed whether or not the secret exists",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "get",
				Title:       "Read Secret",
				Description: "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "list",
				Title:       "List Secrets",
				Description: "List the names of all secrets.\n\nBy default this end-point will try to return up to 1000 secret names in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/secrets",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"WorkerManager": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "worker-manager",
		Title:       "Worker Manager Service",
		Description: "This service manages workers, including provisioning for dynamic worker pools.\n\nMethods interacting with a provider may return a 503 response if that provider has\nnot been able to start up, such as if the service to which it interfaces has an\noutage.  Such requests can be retried as for any other 5xx response.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "lbheartbeat",
				Title:       "Load Balancer Heartbeat",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__lbheartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "version",
				Title:       "Taskcluster Version",
				Description: "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__version__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listProviders",
				Title:       "List Providers",
				Description: "Retrieve a list of providers that are available for worker pools.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/providers",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "createWorkerPool",
				Title:       "Create Worker Pool",
				Description: "Create a new worker pool. If the worker pool already exists, this will throw an error.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/create-worker-pool-request.json#",
			},
			definitions.Entry{
				Name:        "updateWorkerPool",
				Title:       "Update Worker Pool",
				Description: "Given an existing worker pool definition, this will modify it and return\nthe new definition.\n\nTo delete a worker pool, set its `providerId` to `\"null-provider\"`.\nAfter any existing workers have exited, a cleanup job will remove the\nworker pool.  During that time, the worker pool can be updated again, such\nas to set its `providerId` to a real provider.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/update-worker-pool-request.json#",
			},
			definitions.Entry{
				Name:        "deleteWorkerPool",
				Title:       "Delete Worker Pool",
				Description: "Mark a worker pool for deletion.  This is the same as updating the pool to\nset its providerId to `\"null-provider\"`, but does not require scope\n`worker-manager:provider:null-provider`.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "workerPool",
				Title:       "Get Worker Pool",
				Description: "Fetch an existing worker pool defition.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkerPools",
				Title:       "List All Worker Pools",
				Description: "Get the list of all the existing worker pools.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pools",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportWorkerError",
				Title:       "Report an error from a worker",
				Description: "Report an error that occurred on a worker.  This error will be included\nwith the other errors in `listWorkerPoolErrors(workerPoolId)`.\n\nWorkers can use this endpoint to report startup or configuration errors\nthat might be associated with the worker pool configuration and thus of\ninterest to a worker-pool administrator.\n\nNOTE: errors are publicly visible.  Ensure that none of the content\ncontains secrets or other sensitive information.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/worker-pool-errors/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/report-worker-error-request.json#",
			},
			definitions.Entry{
				Name:        "listWorkerPoolErrors",
				Title:       "List Worker Pool Errors",
				Description: "Get the list of worker pool errors.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pool-errors/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkersForWorkerGroup",
				Title:       "Workers in a specific Worker Group in a Worker Pool",
				Description: "Get the list of all the existing workers in a given group in a given worker pool.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>:/<workerGroup>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "worker",
				Title:       "Get a Worker",
				Description: "Get a single worker.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createWorker",
				Title:       "Create a Worker",
				Description: "Create a new worker.  This is only useful for worker pools where the provider\ndoes not create workers automatically, such as those with a `static` provider\ntype.  Providers that do not support creating workers will return a 400 error.\nSee the documentation for the individual providers, and in particular the\n[static provider](https://docs.taskcluster.net/docs/reference/core/worker-manager/)\nfor more information.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/create-worker-request.json#",
			},
			definitions.Entry{
				Name:        "updateWorker",
				Title:       "Update an existing Worker",
				Description: "Update an existing worker in-place.  Like `createWorker`, this is only useful for\nworker pools where the provider does not create workers automatically.\nThis method allows updating all fields in the schema unless otherwise indicated\nin the provider documentation.\nSee the documentation for the individual providers, and in particular the\n[static provider](https://docs.taskcluster.net/docs/reference/core/worker-manager/)\nfor more information.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/create-worker-request.json#",
			},
			definitions.Entry{
				Name:        "removeWorker",
				Title:       "Remove a Worker",
				Description: "Remove an existing worker.  The precise behavior of this method depends\non the provider implementing the given worker.  Some providers\ndo not support removing workers at all, and will return a 400 error.\nOthers may begin removing the worker, but it may remain available via\nthe API (perhaps even in state RUNNING) afterward.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/workers/<workerPoolId>/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkersForWorkerPool",
				Title:       "Workers in a Worker Pool",
				Description: "Get the list of all the existing workers in a given worker pool.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "registerWorker",
				Title:       "Register a running worker",
				Description: "Register a running worker.  Workers call this method on worker start-up.\n\nThis call both marks the worker as running and returns the credentials\nthe worker will require to perform its work.  The worker must provide\nsome proof of its identity, and that proof varies by provider type.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/worker/register",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/register-worker-request.json#",
			},
			definitions.Entry{
				Name:        "reregisterWorker",
				Title:       "Reregister a Worker",
				Description: "Reregister a running worker.\n\nThis will generate and return new Taskcluster credentials for the worker\non that instance to use. The credentials will not live longer the\n`registrationTimeout` for that worker. The endpoint will update `terminateAfter`\nfor the worker so that worker-manager does not terminate the instance.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/worker/reregister",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/reregister-worker-request.json#",
			},
			definitions.Entry{
				Name:        "listWorkers",
				Title:       "Get a list of all active workers of a workerType",
				Description: "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers,\nas well as the current state of the worker.\nTo filter the query, you should call the end-point with one of [`quarantined`, `workerState`]\nas a query-string option with a true or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{
					"continuationToken",
					"limit",
					"quarantined",
					"workerState",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getWorker",
				Title:       "Get a worker-type",
				Description: "Get a worker from a worker-type.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "heartbeat",
				Title:       "Heartbeat",
				Description: "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/__heartbeat__",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
}
