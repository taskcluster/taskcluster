//go:generate go run ../codegen/cmd/gen-services
// Code generated by `go generate ./apis`; DO NOT EDIT
package apis

import "github.com/taskcluster/taskcluster/v30/clients/client-shell/apis/definitions"

var services = map[string]definitions.Service{
	"Auth": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "auth",
		Title:       "Authentication API",
		Description: "Authentication related API end-points for Taskcluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authorize a request signed with Taskcluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listClients",
				Title:       "List Clients",
				Description: "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.\n\nBy default this end-point will try to return up to 1000 clients in one\nrequest. But it **may return less, even none**.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listClients` with the last `continuationToken` until you\nget a result without a `continuationToken`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/",
				Args:        []string{},
				Query: []string{
					"prefix",
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "client",
				Title:       "Get Client",
				Description: "Get information about a single client.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createClient",
				Title:       "Create Client",
				Description: "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "v1/create-client-request.json#",
			},
			definitions.Entry{
				Name:        "resetAccessToken",
				Title:       "Reset `accessToken`",
				Description: "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/reset",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "updateClient",
				Title:       "Update Client",
				Description: "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "v1/create-client-request.json#",
			},
			definitions.Entry{
				Name:        "enableClient",
				Title:       "Enable Client",
				Description: "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/enable",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "disableClient",
				Title:       "Disable Client",
				Description: "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/clients/<clientId>/disable",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "deleteClient",
				Title:       "Delete Client",
				Description: "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listRoles",
				Title:       "List Roles (no pagination)",
				Description: "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This always returns all roles in a single HTTP\nrequest.\n\nTo get paginated results, use `listRoles2`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listRoles2",
				Title:       "List Roles",
				Description: "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This is similar to `listRoles` but differs in the\nformat of the response.\n\nIf no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles2/",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listRoleIds",
				Title:       "List Role IDs",
				Description: "Get a list of all role IDs.\n\nIf no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roleids/",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "role",
				Title:       "Get Role",
				Description: "Get information about a single role, including the set of scopes that the\nrole expands to.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createRole",
				Title:       "Create Role",
				Description: "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.\n\nCreation of a role that will generate an infinite expansion will result\nin an error response.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "v1/create-role-request.json#",
			},
			definitions.Entry{
				Name:        "updateRole",
				Title:       "Update Role",
				Description: "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the role's existing scopes.\n\nAn update of a role that will generate an infinite expansion will result\nin an error response.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "v1/create-role-request.json#",
			},
			definitions.Entry{
				Name:        "deleteRole",
				Title:       "Delete Role",
				Description: "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "expandScopes",
				Title:       "Expand Scopes",
				Description: "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/scopes/expand",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/scopeset.json#",
			},
			definitions.Entry{
				Name:        "currentScopes",
				Title:       "Get Current Scopes",
				Description: "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
				Stability:   "stable",
				Method:      "get",
				Route:       "/scopes/current",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "awsS3Credentials",
				Title:       "Get Temporary Read/Write Credentials S3",
				Description: "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets, as configured\nin the Taskcluster deployment\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
				Stability:   "stable",
				Method:      "get",
				Route:       "/aws/s3/<level>/<bucket>/<prefix>",
				Args: []string{
					"level",
					"bucket",
					"prefix",
				},
				Query: []string{
					"format",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureAccounts",
				Title:       "List Accounts Managed by Auth",
				Description: "Retrieve a list of all Azure accounts managed by Taskcluster Auth.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/azure/accounts",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "azureTables",
				Title:       "List Tables in an Account Managed by Auth",
				Description: "Retrieve a list of all tables in an account.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/azure/<account>/tables",
				Args: []string{
					"account",
				},
				Query: []string{
					"continuationToken",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureTableSAS",
				Title:       "Get Shared-Access-Signature for Azure Table",
				Description: "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ntable if it doesn't already exist.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/azure/<account>/table/<table>/<level>",
				Args: []string{
					"account",
					"table",
					"level",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureContainers",
				Title:       "List containers in an Account Managed by Auth",
				Description: "Retrieve a list of all containers in an account.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/azure/<account>/containers",
				Args: []string{
					"account",
				},
				Query: []string{
					"continuationToken",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "azureContainerSAS",
				Title:       "Get Shared-Access-Signature for Azure Container",
				Description: "Get a shared access signature (SAS) string for use with a specific Azure\nBlob Storage container.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ncontainer if it doesn't already exist.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/azure/<account>/containers/<container>/<level>",
				Args: []string{
					"account",
					"container",
					"level",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "sentryDSN",
				Title:       "Get DSN for Sentry Project",
				Description: "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
				Stability:   "stable",
				Method:      "get",
				Route:       "/sentry/<project>/dsn",
				Args: []string{
					"project",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "websocktunnelToken",
				Title:       "Get a client token for the Websocktunnel service",
				Description: "Get a temporary token suitable for use connecting to a\n[websocktunnel](https://github.com/taskcluster/taskcluster/tree/master/tools/websocktunnel) server.\n\nThe resulting token will only be accepted by servers with a matching audience\nvalue.  Reaching such a server is the callers responsibility.  In general,\na server URL or set of URLs should be provided to the caller as configuration\nalong with the audience value.\n\nThe token is valid for a limited time (on the scale of hours). Callers should\nrefresh it before expiration.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/websocktunnel/<wstAudience>/<wstClient>",
				Args: []string{
					"wstAudience",
					"wstClient",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "gcpCredentials",
				Title:       "Get Temporary GCP Credentials",
				Description: "Get temporary GCP credentials for the given serviceAccount in the given project.\n\nOnly preconfigured projects and serviceAccounts are allowed, as defined in the\ndeployment of the Taskcluster services.\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/gcp/credentials/<projectId>/<serviceAccount>",
				Args: []string{
					"projectId",
					"serviceAccount",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "authenticateHawk",
				Title:       "Authenticate Hawk Request",
				Description: "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on Taskcluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/authenticate-hawk",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/authenticate-hawk-request.json#",
			},
			definitions.Entry{
				Name:        "testAuthenticate",
				Title:       "Test Authentication",
				Description: "Utility method to test client implementations of Taskcluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/test-authenticate",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/test-authenticate-request.json#",
			},
			definitions.Entry{
				Name:        "testAuthenticateGet",
				Title:       "Test Authentication (GET)",
				Description: "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the \n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/test-authenticate-get/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
		},
	},
	"Github": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "github",
		Title:       "Taskcluster GitHub API Documentation",
		Description: "The github service is responsible for creating tasks in reposnse\nto GitHub events, and posting results to the GitHub UI.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks, as well as some useful consumer APIs.\n\nWhen Github forbids an action, this service returns an HTTP 403\nwith code ForbiddenByGithub.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "githubWebHookConsumer",
				Title:       "Consume GitHub WebHook",
				Description: "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease or pull request.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/github",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "builds",
				Title:       "List of Builds",
				Description: "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/builds",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
					"organization",
					"repository",
					"sha",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "badge",
				Title:       "Latest Build Status Badge",
				Description: "Checks the status of the latest build of a given branch\nand returns corresponding badge svg.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>/<branch>/badge.svg",
				Args: []string{
					"owner",
					"repo",
					"branch",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "repository",
				Title:       "Get Repository Info",
				Description: "Returns any repository metadata that is\nuseful within Taskcluster related services.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>",
				Args: []string{
					"owner",
					"repo",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "latest",
				Title:       "Latest Status for Branch",
				Description: "For a given branch of a repository, this will always point\nto a status page for the most recent task triggered by that\nbranch.\n\nNote: This is a redirect rather than a direct link.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/repository/<owner>/<repo>/<branch>/latest",
				Args: []string{
					"owner",
					"repo",
					"branch",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createStatus",
				Title:       "Post a status against a given changeset",
				Description: "For a given changeset (SHA) of a repository, this will attach a \"commit status\"\non github. These statuses are links displayed next to each revision.\nThe status is either OK (green check) or FAILURE (red cross), \nmade of a custom title and link.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/repository/<owner>/<repo>/statuses/<sha>",
				Args: []string{
					"owner",
					"repo",
					"sha",
				},
				Query: []string{},
				Input: "v1/create-status.json#",
			},
			definitions.Entry{
				Name:        "createComment",
				Title:       "Post a comment on a given GitHub Issue or Pull Request",
				Description: "For a given Issue or Pull Request of a repository, this will write a new message.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/repository/<owner>/<repo>/issues/<number>/comments",
				Args: []string{
					"owner",
					"repo",
					"number",
				},
				Query: []string{},
				Input: "v1/create-comment.json#",
			},
		},
	},
	"Hooks": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "hooks",
		Title:       "Hooks API Documentation",
		Description: "The hooks service provides a mechanism for creating tasks in response to events.\n",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listHookGroups",
				Title:       "List hook groups",
				Description: "This endpoint will return a list of all hook groups with at least one hook.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listHooks",
				Title:       "List hooks in a given group",
				Description: "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>",
				Args: []string{
					"hookGroupId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "hook",
				Title:       "Get hook definition",
				Description: "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "getHookStatus",
				Title:       "Get hook status",
				Description: "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.\n\nThis method is deprecated in favor of listLastFires.",
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/status",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createHook",
				Title:       "Create a hook",
				Description: "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/create-hook-request.json#",
			},
			definitions.Entry{
				Name:        "updateHook",
				Title:       "Update a hook",
				Description: "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/create-hook-request.json#",
			},
			definitions.Entry{
				Name:        "removeHook",
				Title:       "Delete a hook",
				Description: "This endpoint will remove a hook definition.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "triggerHook",
				Title:       "Trigger a hook",
				Description: "This endpoint will trigger the creation of a task from a hook definition.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/trigger",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "v1/trigger-hook.json#",
			},
			definitions.Entry{
				Name:        "getTriggerToken",
				Title:       "Get a trigger token",
				Description: "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "resetTriggerToken",
				Title:       "Reset a trigger token",
				Description: "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "triggerHookWithToken",
				Title:       "Trigger a hook with a token",
				Description: "This endpoint triggers a defined hook with a valid token.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
				Args: []string{
					"hookGroupId",
					"hookId",
					"token",
				},
				Query: []string{},
				Input: "v1/trigger-hook.json#",
			},
			definitions.Entry{
				Name:        "listLastFires",
				Title:       "Get information about recent hook fires",
				Description: "This endpoint will return information about the the last few times this hook has been\nfired, including whether the hook was fired successfully or not",
				Stability:   "stable",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/last-fires",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query: []string{},
				Input: "",
			},
		},
	},
	"Index": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "index",
		Title:       "Task Index API Documentation",
		Description: "The index service is responsible for indexing tasks. The service ensures that\ntasks can be located by user-defined names.\n\nAs described in the service documentation, tasks are typically indexed via Pulse\nmessages, so the most common use of API methods is to read from the index.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "findTask",
				Title:       "Find Indexed Task",
				Description: "Find a task by index path, returning the highest-rank task with that path. If no\ntask exists for the given path, this API end-point will respond with a 404 status.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<indexPath>",
				Args: []string{
					"indexPath",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listNamespaces",
				Title:       "List Namespaces",
				Description: "List the namespaces immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 namespaces. If more namespaces are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/namespaces/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listTasks",
				Title:       "List Tasks",
				Description: "List the tasks immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 tasks. If more tasks are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/tasks/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "insertTask",
				Title:       "Insert Task into Index",
				Description: "Insert a task into the index.  If the new rank is less than the existing rank\nat the given index path, the task is not indexed but the response is still 200 OK.\n\nPlease see the introduction above for information\nabout indexing successfully completed tasks automatically using custom routes.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/task/<namespace>",
				Args: []string{
					"namespace",
				},
				Query: []string{},
				Input: "v1/insert-task-request.json#",
			},
			definitions.Entry{
				Name:        "findArtifactFromTask",
				Title:       "Get Artifact From Indexed Task",
				Description: "Find a task by index path and redirect to the artifact on the most recent\nrun with the given `name`.\n\nNote that multiple calls to this endpoint may return artifacts from differen tasks\nif a new task is inserted into the index between calls. Avoid using this method as\na stable link to multiple, connected files if the index path does not contain a\nunique identifier.  For example, the following two links may return unrelated files:\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/installer.exe`\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/debug-symbols.zip`\n\nThis problem be remedied by including the revision in the index path or by bundling both\ninstaller and debug symbols into a single artifact.\n\nIf no task exists for the given index path, this API end-point responds with 404.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<indexPath>/artifacts/<name>",
				Args: []string{
					"indexPath",
					"name",
				},
				Query: []string{},
				Input: "",
			},
		},
	},
	"Notify": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "notify",
		Title:       "Notification Service",
		Description: "The notification service listens for tasks with associated notifications\nand handles requests to send emails and post pulse messages.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "email",
				Title:       "Send an Email",
				Description: "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/email",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/email-request.json#",
			},
			definitions.Entry{
				Name:        "pulse",
				Title:       "Publish a Pulse Message",
				Description: "Publish a message on pulse with the given `routingKey`.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/pulse",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/pulse-request.json#",
			},
			definitions.Entry{
				Name:        "irc",
				Title:       "Post IRC Message",
				Description: "Post a message on IRC to a specific channel or user, or a specific user\non a specific channel.\n\nSuccess of this API method does not imply the message was successfully\nposted. This API method merely inserts the IRC message into a queue\nthat will be processed by a background process.\nThis allows us to re-send the message in face of connection issues.\n\nHowever, if the user isn't online the message will be dropped without\nerror. We maybe improve this behavior in the future. For now just keep\nin mind that IRC is a best-effort service.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/irc",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/irc-request.json#",
			},
			definitions.Entry{
				Name:        "matrix",
				Title:       "Post Matrix Message",
				Description: "Post a message to a room in Matrix. Optionally includes formatted message.\n\nThe `roomId` in the scopes is a fully formed `roomId` with leading `!` such\nas `!foo:bar.com`.\n\nNote that the matrix client used by taskcluster must be invited to a room before\nit can post there!",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/matrix",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/matrix-request.json#",
			},
			definitions.Entry{
				Name:        "addDenylistAddress",
				Title:       "Denylist Given Address",
				Description: "Add the given address to the notification denylist. The address\ncan be of either of the three supported address type namely pulse, email\nor IRC(user or channel). Addresses in the denylist will be ignored\nby the notification service.",
				Stability:   "experimental",
				Method:      "post",
				Route:       "/denylist/add",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/notification-address.json#",
			},
			definitions.Entry{
				Name:        "deleteDenylistAddress",
				Title:       "Delete Denylisted Address",
				Description: "Delete the specified address from the notification denylist.",
				Stability:   "experimental",
				Method:      "delete",
				Route:       "/denylist/delete",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/notification-address.json#",
			},
			definitions.Entry{
				Name:        "listDenylist",
				Title:       "List Denylisted Notifications",
				Description: "Lists all the denylisted addresses.\n\nBy default this end-point will try to return up to 1000 addresses in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `list` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/denylist/list",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
		},
	},
	"PurgeCache": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "purge-cache",
		Title:       "Purge Cache API",
		Description: "The purge-cache service is responsible for tracking cache-purge requests.\n\nUser create purge requests for specific caches on specific workers, and\nthese requests are timestamped.  Workers consult the service before\nstarting a new task, and purge any caches older than the timestamp.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "purgeCache",
				Title:       "Purge Worker Cache",
				Description: "Publish a request to purge caches named `cacheName` with\non `provisionerId`/`workerType` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/purge-cache/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "v1/purge-cache-request.json#",
			},
			definitions.Entry{
				Name:        "allPurgeRequests",
				Title:       "All Open Purge Requests",
				Description: "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/purge-cache/list",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "purgeRequests",
				Title:       "Open Purge Requests for a provisionerId/workerType pair",
				Description: "List the caches for this `provisionerId`/`workerType` that should to be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/purge-cache/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{
					"since",
				},
				Input: "",
			},
		},
	},
	"Queue": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "queue",
		Title:       "Queue API Documentation",
		Description: "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes the API end-points offered by the queue. These \nend-points targets the following audience:\n * Schedulers, who create tasks to be executed,\n * Workers, who execute tasks, and\n * Tools, that wants to inspect the state of a task.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "task",
				Title:       "Get Task Definition",
				Description: "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "status",
				Title:       "Get task status",
				Description: "Get task status structure from `taskId`",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/status",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listTaskGroup",
				Title:       "List Task Group",
				Description: "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task-group/<taskGroupId>/list",
				Args: []string{
					"taskGroupId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listDependentTasks",
				Title:       "List Dependent Tasks",
				Description: "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/dependents",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "createTask",
				Title:       "Create New Task",
				Description: "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline`**: the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**: the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice, that artifacts created by task must expire before the task.\n\n**Task specific routing-keys**: using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific \nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key: \n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**: any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Scopes**: Note that the scopes required to complete this API call depend\non the content of the `scopes`, `routes`, `schedulerId`, `priority`,\n`provisionerId`, and `workerType` properties of the task definition.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "v1/create-task-request.json#",
			},
			definitions.Entry{
				Name:        "scheduleTask",
				Title:       "Schedule Defined Task",
				Description: "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/schedule",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "rerunTask",
				Title:       "Rerun a Resolved Task",
				Description: "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed.\n\nThis method is deprecated in favour of creating a new task with the same\ntask definition (but with a new taskId).\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent, if you try to rerun a task that\nis not either `failed` or `completed`, this operation will just return\nthe current task status.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/rerun",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "cancelTask",
				Title:       "Cancel Task",
				Description: "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/cancel",
				Args: []string{
					"taskId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "claimWork",
				Title:       "Claim Work",
				Description: "Claim pending task(s) for the given `provisionerId`/`workerType` queue.\n\nIf any work is available (even if fewer than the requested number of\ntasks, this will return immediately. Otherwise, it will block for tens of\nseconds waiting for work.  If no work appears, it will return an emtpy\nlist of tasks.  Callers should sleep a short while (to avoid denial of\nservice in an error condition) and call the endpoint again.  This is a\nsimple implementation of \"long polling\".",
				Stability:   "stable",
				Method:      "post",
				Route:       "/claim-work/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "v1/claim-work-request.json#",
			},
			definitions.Entry{
				Name:        "claimTask",
				Title:       "Claim Task",
				Description: "claim a task - never documented",
				Stability:   "deprecated",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/claim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "v1/task-claim-request.json#",
			},
			definitions.Entry{
				Name:        "reclaimTask",
				Title:       "Reclaim task",
				Description: "Refresh the claim for a specific `runId` for given `taskId`. This updates\nthe `takenUntil` property and returns a new set of temporary credentials\nfor performing requests on behalf of the task. These credentials should\nbe used in-place of the credentials returned by `claimWork`.\n\nThe `reclaimTask` requests serves to:\n * Postpone `takenUntil` preventing the queue from resolving\n   `claim-expired`,\n * Refresh temporary credentials used for processing the task, and\n * Abort execution if the task/run have been resolved.\n\nIf the `takenUntil` timestamp is exceeded the queue will resolve the run\nas _exception_ with reason `claim-expired`, and proceeded to retry to the\ntask. This ensures that tasks are retried, even if workers disappear\nwithout warning.\n\nIf the task is resolved, this end-point will return `409` reporting\n`RequestConflict`. This typically happens if the task have been canceled\nor the `task.deadline` have been exceeded. If reclaiming fails, workers\nshould abort the task and forget about the given `runId`. There is no\nneed to resolve the run or upload artifacts.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/reclaim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportCompleted",
				Title:       "Report Run Completed",
				Description: "Report a task completed, resolving the run as `completed`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/completed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportFailed",
				Title:       "Report Run Failed",
				Description: "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/failed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportException",
				Title:       "Report Task Exception",
				Description: "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/exception",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{},
				Input: "v1/task-exception-request.json#",
			},
			definitions.Entry{
				Name:        "createArtifact",
				Title:       "Create Artifact",
				Description: "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they `expires`, the queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This features makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.\n\nWe currently support \"S3 Artifacts\" officially, with remaining support\nfor two deprecated types.  Do not use these deprecated types.\n\n**S3 artifacts**, is useful for static files which will be\nstored on S3. When creating an S3 artifact the queue will return a\npre-signed URL to which you can do a `PUT` request to upload your\nartifact. Note that `PUT` request **must** specify the `content-length`\nheader and **must** give the `content-type` header the same value as in\nthe request to `createArtifact`.\n\n**Reference artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts really only have a `url` property and\nwhen the artifact is requested the client will be redirect the URL\nprovided with a `303` (See Other) redirect. Please note that we cannot\ndelete artifacts you upload to other service, we can only delete the\nreference to the artifact, when it expires.\n\n**Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `424` (Failed Dependency) response. This is mainly designed to\nensure that dependent tasks can distinguish between artifacts that were\nsuppose to be generated and artifacts for which the name is misspelled.\n\n**Artifact immutability**, generally speaking you cannot overwrite an\nartifact when created. But if you repeat the request with the same\nproperties the request will succeed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nAs a special case the `url` property on _reference artifacts_ can be\nupdated. You should only use this to update the `url` property for\nreference artifacts your process has created.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "v1/post-artifact-request.json#",
			},
			definitions.Entry{
				Name:        "getArtifact",
				Title:       "Get Artifact from Run",
				Description: "Get artifact by `<name>` from a specific run.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with an HTTP client that can handle responses correctly.\n\n**Downloading artifacts**\nThere are some special considerations for those http clients which download\nartifacts.  This api endpoint is designed to be compatible with an HTTP 1.1\ncompliant client, but has extra features to ensure the download is valid.\nIt is strongly recommend that consumers use either taskcluster-lib-artifact (JS),\ntaskcluster-lib-artifact-go (Go) or the CLI written in Go to interact with\nartifacts.\n\nIn order to download an artifact the following must be done:\n\n1. Obtain queue url.  Building a signed url with a taskcluster client is\nrecommended\n1. Make a GET request which does not follow redirects\n1. In all cases, if specified, the\nx-taskcluster-location-{content,transfer}-{sha256,length} values must be\nvalidated to be equal to the Content-Length and Sha256 checksum of the\nfinal artifact downloaded. as well as any intermediate redirects\n1. If this response is a 500-series error, retry using an exponential\nbackoff.  No more than 5 retries should be attempted\n1. If this response is a 400-series error, treat it appropriately for\nyour context.  This might be an error in responding to this request or\nan Error storage type body.  This request should not be retried.\n1. If this response is a 200-series response, the response body is the artifact.\nIf the x-taskcluster-location-{content,transfer}-{sha256,length} and\nx-taskcluster-location-content-encoding are specified, they should match\nthis response body\n1. If the response type is a 300-series redirect, the artifact will be at the\nlocation specified by the `Location` header.  There are multiple artifact storage\ntypes which use a 300-series redirect.\n1. For all redirects followed, the user must verify that the content-sha256, content-length,\ntransfer-sha256, transfer-length and content-encoding match every further request.  The final\nartifact must also be validated against the values specified in the original queue response\n1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`\nmust not occur\n\n**Headers**\nThe following important headers are set on the response to this method:\n\n* location: the url of the artifact if a redirect is to be performed\n* x-taskcluster-artifact-storage-type: the storage type.  Example: s3\n\nThe following important headers are set on responses to this method for Blob artifacts\n\n* x-taskcluster-location-content-sha256: the SHA256 of the artifact\n*after* any content-encoding is undone.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-content-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-transfer-sha256: the SHA256 of the artifact\n*before* any content-encoding is undone.  This is the SHA256 of what is sent over\nthe wire.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-transfer-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-content-encoding: the content-encoding used.  It will either\nbe `gzip` or `identity` right now.  This is hardcoded to a value set when the artifact\nwas created and no content-negotiation occurs\n* x-taskcluster-location-content-type: the content-type of the artifact\n\n**Caching**, artifacts may be cached in data centers closer to the\nworkers in-order to reduce bandwidth costs. This can lead to longer\nresponse times. Caching can be skipped by setting the header\n`x-taskcluster-skip-cache: true`, this should only be used for resources\nwhere request volume is known to be low, and caching not useful.\n(This feature may be disabled in the future, use is sparingly!)",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "getLatestArtifact",
				Title:       "Get Artifact from Latest Run",
				Description: "Get artifact by `<name>` from the last run of a task.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listArtifacts",
				Title:       "Get Artifacts from Run",
				Description: "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifacts",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listLatestArtifacts",
				Title:       "Get Artifacts from Latest Run",
				Description: "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/artifacts",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listProvisioners",
				Title:       "Get a list of all active provisioners",
				Description: "Get all active provisioners.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 provisioners in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getProvisioner",
				Title:       "Get an active provisioner",
				Description: "Get an active provisioner.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>",
				Args: []string{
					"provisionerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "declareProvisioner",
				Title:       "Update a provisioner",
				Description: "Declare a provisioner, supplying some details about it.\n\n`declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are\npossessed. For example, a request to update the `my-provisioner`\nprovisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope\n`queue:declare-provisioner:my-provisioner#description`.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>",
				Args: []string{
					"provisionerId",
				},
				Query: []string{},
				Input: "v1/update-provisioner-request.json#",
			},
			definitions.Entry{
				Name:        "pendingTasks",
				Title:       "Get Number of Pending Tasks",
				Description: "Get an approximate number of pending tasks for the given `provisionerId`\nand `workerType`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/pending/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkerTypes",
				Title:       "Get a list of all active worker-types",
				Description: "Get all active worker-types for the given provisioner.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 worker-types in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types",
				Args: []string{
					"provisionerId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getWorkerType",
				Title:       "Get a worker-type",
				Description: "Get a worker-type from a provisioner.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "declareWorkerType",
				Title:       "Update a worker-type",
				Description: "Declare a workerType, supplying some details about it.\n\n`declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are\npossessed. For example, a request to update the `highmem` worker-type within the `my-provisioner`\nprovisioner with a body `{description: 'This worker type is great'}` would require you to have the scope\n`queue:declare-worker-type:my-provisioner/highmem#description`.",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{},
				Input: "v1/update-workertype-request.json#",
			},
			definitions.Entry{
				Name:        "listWorkers",
				Title:       "Get a list of all active workers of a workerType",
				Description: "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers.\nTo filter the query, you should call the end-point with `quarantined` as a query-string option with a\ntrue or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{
					"continuationToken",
					"limit",
					"quarantined",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "getWorker",
				Title:       "Get a worker-type",
				Description: "Get a worker from a worker-type.",
				Stability:   "experimental",
				Method:      "get",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "quarantineWorker",
				Title:       "Quarantine a worker",
				Description: "Quarantine a worker",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/quarantine-worker-request.json#",
			},
			definitions.Entry{
				Name:        "declareWorker",
				Title:       "Declare a worker",
				Description: "Declare a worker, supplying some details about it.\n\n`declareWorker` allows updating one or more properties of a worker as long as the required scopes are\npossessed.",
				Stability:   "experimental",
				Method:      "put",
				Route:       "/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>",
				Args: []string{
					"provisionerId",
					"workerType",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/update-worker-request.json#",
			},
		},
	},
	"Secrets": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "secrets",
		Title:       "Taskcluster Secrets API Documentation",
		Description: "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "set",
				Title:       "Set Secret",
				Description: "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "v1/secret.json#",
			},
			definitions.Entry{
				Name:        "remove",
				Title:       "Delete Secret",
				Description: "Delete the secret associated with some key.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "get",
				Title:       "Read Secret",
				Description: "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/secret/<name>",
				Args: []string{
					"name",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "list",
				Title:       "List Secrets",
				Description: "List the names of all secrets.\n\nBy default this end-point will try to return up to 1000 secret names in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/secrets",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
		},
	},
	"WorkerManager": definitions.Service{
		APIVersion:  "v1",
		ServiceName: "worker-manager",
		Title:       "Taskcluster Worker Manager",
		Description: "This service manages workers, including provisioning for dynamic worker pools.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
			},
			definitions.Entry{
				Name:        "listProviders",
				Title:       "List Providers",
				Description: "Retrieve a list of providers that are available for worker pools.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/providers",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "createWorkerPool",
				Title:       "Create Worker Pool",
				Description: "Create a new worker pool. If the worker pool already exists, this will throw an error.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/create-worker-pool-request.json#",
			},
			definitions.Entry{
				Name:        "updateWorkerPool",
				Title:       "Update Worker Pool",
				Description: "Given an existing worker pool definition, this will modify it and return\nthe new definition.\n\nTo delete a worker pool, set its `providerId` to `\"null-provider\"`.\nAfter any existing workers have exited, a cleanup job will remove the\nworker pool.  During that time, the worker pool can be updated again, such\nas to set its `providerId` to a real provider.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/update-worker-pool-request.json#",
			},
			definitions.Entry{
				Name:        "deleteWorkerPool",
				Title:       "Delete Worker Pool",
				Description: "Mark a worker pool for deletion.  This is the same as updating the pool to\nset its providerId to `\"null-provider\"`, but does not require scope\n`worker-manager:provider:null-provider`.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "workerPool",
				Title:       "Get Worker Pool",
				Description: "Fetch an existing worker pool defition.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pool/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkerPools",
				Title:       "List All Worker Pools",
				Description: "Get the list of all the existing worker pools.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pools",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "reportWorkerError",
				Title:       "Report an error from a worker",
				Description: "Report an error that occurred on a worker.  This error will be included\nwith the other errors in `listWorkerPoolErrors(workerPoolId)`.\n\nWorkers can use this endpoint to report startup or configuration errors\nthat might be associated with the worker pool configuration and thus of\ninterest to a worker-pool administrator.\n\nNOTE: errors are publicly visible.  Ensure that none of the content\ncontains secrets or other sensitive information.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/worker-pool-errors/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{},
				Input: "v1/report-worker-error-request.json#",
			},
			definitions.Entry{
				Name:        "listWorkerPoolErrors",
				Title:       "List Worker Pool Errors",
				Description: "Get the list of worker pool errors.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-pool-errors/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkersForWorkerGroup",
				Title:       "Workers in a specific Worker Group in a Worker Pool",
				Description: "Get the list of all the existing workers in a given group in a given worker pool.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>:/<workerGroup>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "worker",
				Title:       "Get a Worker",
				Description: "Get a single worker.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "createWorker",
				Title:       "Create a Worker",
				Description: "Create a new worker.  The precise behavior of this method depends\non the provider implementing the given worker pool.  Some providers\ndo not support creating workers at all, and will return a 400 error.",
				Stability:   "stable",
				Method:      "put",
				Route:       "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "v1/create-worker-request.json#",
			},
			definitions.Entry{
				Name:        "removeWorker",
				Title:       "Remove a Worker",
				Description: "Remove an existing worker.  The precise behavior of this method depends\non the provider implementing the given worker.  Some providers\ndo not support removing workers at all, and will return a 400 error.\nOthers may begin removing the worker, but it may remain available via\nthe API (perhaps even in state RUNNING) afterward.",
				Stability:   "stable",
				Method:      "delete",
				Route:       "/workers/<workerPoolId>/<workerGroup>/<workerId>",
				Args: []string{
					"workerPoolId",
					"workerGroup",
					"workerId",
				},
				Query: []string{},
				Input: "",
			},
			definitions.Entry{
				Name:        "listWorkersForWorkerPool",
				Title:       "Workers in a Worker Pool",
				Description: "Get the list of all the existing workers in a given worker pool.",
				Stability:   "stable",
				Method:      "get",
				Route:       "/workers/<workerPoolId>",
				Args: []string{
					"workerPoolId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input: "",
			},
			definitions.Entry{
				Name:        "registerWorker",
				Title:       "Register a running worker",
				Description: "Register a running worker.  Workers call this method on worker start-up.\n\nThis call both marks the worker as running and returns the credentials\nthe worker will require to perform its work.  The worker must provide\nsome proof of its identity, and that proof varies by provider type.",
				Stability:   "stable",
				Method:      "post",
				Route:       "/worker/register",
				Args:        []string{},
				Query:       []string{},
				Input:       "v1/register-worker-request.json#",
			},
		},
	},
}
