// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import Client from '../Client';

export default class Queue extends Client {
  constructor(options = {}) {
    super({
      serviceName: 'queue',
      serviceVersion: 'v1',
      exchangePrefix: '',
      ...options,
    });
    this.ping.entry = {"args":[],"category":"Ping Server","method":"get","name":"ping","query":[],"route":"/ping","stability":"stable","type":"function"}; // eslint-disable-line
    this.task.entry = {"args":["taskId"],"category":"Queue Service","method":"get","name":"task","output":true,"query":[],"route":"/task/<taskId>","stability":"stable","type":"function"}; // eslint-disable-line
    this.status.entry = {"args":["taskId"],"category":"Queue Service","method":"get","name":"status","output":true,"query":[],"route":"/task/<taskId>/status","stability":"stable","type":"function"}; // eslint-disable-line
    this.listTaskGroup.entry = {"args":["taskGroupId"],"category":"Queue Service","method":"get","name":"listTaskGroup","output":true,"query":["continuationToken","limit"],"route":"/task-group/<taskGroupId>/list","stability":"stable","type":"function"}; // eslint-disable-line
    this.listDependentTasks.entry = {"args":["taskId"],"category":"Queue Service","method":"get","name":"listDependentTasks","output":true,"query":["continuationToken","limit"],"route":"/task/<taskId>/dependents","stability":"stable","type":"function"}; // eslint-disable-line
    this.createTask.entry = {"args":["taskId"],"category":"Queue Service","input":true,"method":"put","name":"createTask","output":true,"query":[],"route":"/task/<taskId>","scopes":{"AllOf":[{"each":"<scope>","for":"scope","in":"scopes"},{"each":"queue:route:<route>","for":"route","in":"routes"},{"AnyOf":[{"AllOf":["queue:scheduler-id:<schedulerId>",{"AnyOf":[{"each":"queue:create-task:<priority>:<provisionerId>/<workerType>","for":"priority","in":"priorities"}]}]},{"if":"legacyScopes","then":{"AnyOf":["queue:create-task:<provisionerId>/<workerType>",{"AllOf":["queue:define-task:<provisionerId>/<workerType>","queue:task-group-id:<schedulerId>/<taskGroupId>","queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>"]}]}}]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.defineTask.entry = {"args":["taskId"],"category":"Queue Service","input":true,"method":"post","name":"defineTask","output":true,"query":[],"route":"/task/<taskId>/define","scopes":{"AllOf":[{"each":"<scope>","for":"scope","in":"scopes"},{"each":"queue:route:<route>","for":"route","in":"routes"},{"AnyOf":[{"AllOf":["queue:scheduler-id:<schedulerId>",{"AnyOf":[{"each":"queue:create-task:<priority>:<provisionerId>/<workerType>","for":"priority","in":"priorities"}]}]},{"if":"legacyScopes","then":{"AnyOf":["queue:define-task:<provisionerId>/<workerType>","queue:create-task:<provisionerId>/<workerType>",{"AllOf":["queue:define-task:<provisionerId>/<workerType>","queue:task-group-id:<schedulerId>/<taskGroupId>"]}]}}]}]},"stability":"deprecated","type":"function"}; // eslint-disable-line
    this.scheduleTask.entry = {"args":["taskId"],"category":"Queue Service","method":"post","name":"scheduleTask","output":true,"query":[],"route":"/task/<taskId>/schedule","scopes":{"AnyOf":["queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",{"AllOf":["queue:schedule-task","assume:scheduler-id:<schedulerId>/<taskGroupId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.rerunTask.entry = {"args":["taskId"],"category":"Queue Service","method":"post","name":"rerunTask","output":true,"query":[],"route":"/task/<taskId>/rerun","scopes":{"AnyOf":["queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>",{"AllOf":["queue:rerun-task","assume:scheduler-id:<schedulerId>/<taskGroupId>"]}]},"stability":"deprecated","type":"function"}; // eslint-disable-line
    this.cancelTask.entry = {"args":["taskId"],"category":"Queue Service","method":"post","name":"cancelTask","output":true,"query":[],"route":"/task/<taskId>/cancel","scopes":{"AnyOf":["queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>",{"AllOf":["queue:cancel-task","assume:scheduler-id:<schedulerId>/<taskGroupId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.claimWork.entry = {"args":["provisionerId","workerType"],"category":"Queue Service","input":true,"method":"post","name":"claimWork","output":true,"query":[],"route":"/claim-work/<provisionerId>/<workerType>","scopes":{"AllOf":["queue:claim-work:<provisionerId>/<workerType>","queue:worker-id:<workerGroup>/<workerId>"]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.claimTask.entry = {"args":["taskId","runId"],"category":"Queue Service","input":true,"method":"post","name":"claimTask","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/claim","scopes":{"AnyOf":[{"AllOf":["queue:claim-task:<provisionerId>/<workerType>","queue:worker-id:<workerGroup>/<workerId>"]},{"AllOf":["queue:claim-task","assume:worker-type:<provisionerId>/<workerType>","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"deprecated","type":"function"}; // eslint-disable-line
    this.reclaimTask.entry = {"args":["taskId","runId"],"category":"Queue Service","method":"post","name":"reclaimTask","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/reclaim","scopes":{"AnyOf":["queue:reclaim-task:<taskId>/<runId>",{"AllOf":["queue:claim-task","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.reportCompleted.entry = {"args":["taskId","runId"],"category":"Queue Service","method":"post","name":"reportCompleted","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/completed","scopes":{"AnyOf":["queue:resolve-task:<taskId>/<runId>",{"AllOf":["queue:resolve-task","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.reportFailed.entry = {"args":["taskId","runId"],"category":"Queue Service","method":"post","name":"reportFailed","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/failed","scopes":{"AnyOf":["queue:resolve-task:<taskId>/<runId>",{"AllOf":["queue:resolve-task","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.reportException.entry = {"args":["taskId","runId"],"category":"Queue Service","input":true,"method":"post","name":"reportException","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/exception","scopes":{"AnyOf":["queue:resolve-task:<taskId>/<runId>",{"AllOf":["queue:resolve-task","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.createArtifact.entry = {"args":["taskId","runId","name"],"category":"Queue Service","input":true,"method":"post","name":"createArtifact","output":true,"query":[],"route":"/task/<taskId>/runs/<runId>/artifacts/<name>","scopes":{"AnyOf":["queue:create-artifact:<taskId>/<runId>",{"AllOf":["queue:create-artifact:<name>","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"stable","type":"function"}; // eslint-disable-line
    this.completeArtifact.entry = {"args":["taskId","runId","name"],"category":"Queue Service","input":true,"method":"put","name":"completeArtifact","query":[],"route":"/task/<taskId>/runs/<runId>/artifacts/<name>","scopes":{"AnyOf":["queue:create-artifact:<taskId>/<runId>",{"AllOf":["queue:create-artifact:<name>","assume:worker-id:<workerGroup>/<workerId>"]}]},"stability":"experimental","type":"function"}; // eslint-disable-line
    this.getArtifact.entry = {"args":["taskId","runId","name"],"category":"Queue Service","method":"get","name":"getArtifact","query":[],"route":"/task/<taskId>/runs/<runId>/artifacts/<name>","scopes":{"if":"private","then":{"AllOf":["queue:get-artifact:<name>"]}},"stability":"stable","type":"function"}; // eslint-disable-line
    this.getLatestArtifact.entry = {"args":["taskId","name"],"category":"Queue Service","method":"get","name":"getLatestArtifact","query":[],"route":"/task/<taskId>/artifacts/<name>","scopes":{"if":"private","then":{"AllOf":["queue:get-artifact:<name>"]}},"stability":"stable","type":"function"}; // eslint-disable-line
    this.listArtifacts.entry = {"args":["taskId","runId"],"category":"Queue Service","method":"get","name":"listArtifacts","output":true,"query":["continuationToken","limit"],"route":"/task/<taskId>/runs/<runId>/artifacts","stability":"experimental","type":"function"}; // eslint-disable-line
    this.listLatestArtifacts.entry = {"args":["taskId"],"category":"Queue Service","method":"get","name":"listLatestArtifacts","output":true,"query":["continuationToken","limit"],"route":"/task/<taskId>/artifacts","stability":"experimental","type":"function"}; // eslint-disable-line
    this.listProvisioners.entry = {"args":[],"category":"Queue Service","method":"get","name":"listProvisioners","output":true,"query":["continuationToken","limit"],"route":"/provisioners","stability":"experimental","type":"function"}; // eslint-disable-line
    this.getProvisioner.entry = {"args":["provisionerId"],"category":"Queue Service","method":"get","name":"getProvisioner","output":true,"query":[],"route":"/provisioners/<provisionerId>","stability":"experimental","type":"function"}; // eslint-disable-line
    this.declareProvisioner.entry = {"args":["provisionerId"],"category":"Queue Service","input":true,"method":"put","name":"declareProvisioner","output":true,"query":[],"route":"/provisioners/<provisionerId>","scopes":{"AllOf":[{"each":"queue:declare-provisioner:<provisionerId>#<property>","for":"property","in":"properties"}]},"stability":"experimental","type":"function"}; // eslint-disable-line
    this.pendingTasks.entry = {"args":["provisionerId","workerType"],"category":"Queue Service","method":"get","name":"pendingTasks","output":true,"query":[],"route":"/pending/<provisionerId>/<workerType>","stability":"stable","type":"function"}; // eslint-disable-line
    this.listWorkerTypes.entry = {"args":["provisionerId"],"category":"Queue Service","method":"get","name":"listWorkerTypes","output":true,"query":["continuationToken","limit"],"route":"/provisioners/<provisionerId>/worker-types","stability":"experimental","type":"function"}; // eslint-disable-line
    this.getWorkerType.entry = {"args":["provisionerId","workerType"],"category":"Queue Service","method":"get","name":"getWorkerType","output":true,"query":[],"route":"/provisioners/<provisionerId>/worker-types/<workerType>","stability":"experimental","type":"function"}; // eslint-disable-line
    this.declareWorkerType.entry = {"args":["provisionerId","workerType"],"category":"Queue Service","input":true,"method":"put","name":"declareWorkerType","output":true,"query":[],"route":"/provisioners/<provisionerId>/worker-types/<workerType>","scopes":{"AllOf":[{"each":"queue:declare-worker-type:<provisionerId>/<workerType>#<property>","for":"property","in":"properties"}]},"stability":"experimental","type":"function"}; // eslint-disable-line
    this.listWorkers.entry = {"args":["provisionerId","workerType"],"category":"Queue Service","method":"get","name":"listWorkers","output":true,"query":["continuationToken","limit","quarantined"],"route":"/provisioners/<provisionerId>/worker-types/<workerType>/workers","stability":"experimental","type":"function"}; // eslint-disable-line
    this.getWorker.entry = {"args":["provisionerId","workerType","workerGroup","workerId"],"category":"Queue Service","method":"get","name":"getWorker","output":true,"query":[],"route":"/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>","stability":"experimental","type":"function"}; // eslint-disable-line
    this.quarantineWorker.entry = {"args":["provisionerId","workerType","workerGroup","workerId"],"category":"Queue Service","input":true,"method":"put","name":"quarantineWorker","output":true,"query":[],"route":"/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>","scopes":{"AllOf":["queue:quarantine-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>"]},"stability":"experimental","type":"function"}; // eslint-disable-line
    this.declareWorker.entry = {"args":["provisionerId","workerType","workerGroup","workerId"],"category":"Queue Service","input":true,"method":"put","name":"declareWorker","output":true,"query":[],"route":"/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>","scopes":{"AllOf":[{"each":"queue:declare-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>#<property>","for":"property","in":"properties"}]},"stability":"experimental","type":"function"}; // eslint-disable-line
  }
  /* eslint-disable max-len */
  // Respond without doing anything.
  // This endpoint is used to check that the service is up.
  /* eslint-enable max-len */
  ping(...args) {
    this.validate(this.ping.entry, args);

    return this.request(this.ping.entry, args);
  }
  /* eslint-disable max-len */
  // This end-point will return the task-definition. Notice that the task
  // definition may have been modified by queue, if an optional property is
  // not specified the queue may provide a default value.
  /* eslint-enable max-len */
  task(...args) {
    this.validate(this.task.entry, args);

    return this.request(this.task.entry, args);
  }
  /* eslint-disable max-len */
  // Get task status structure from `taskId`
  /* eslint-enable max-len */
  status(...args) {
    this.validate(this.status.entry, args);

    return this.request(this.status.entry, args);
  }
  /* eslint-disable max-len */
  // List tasks sharing the same `taskGroupId`.
  // As a task-group may contain an unbounded number of tasks, this end-point
  // may return a `continuationToken`. To continue listing tasks you must call
  // the `listTaskGroup` again with the `continuationToken` as the
  // query-string option `continuationToken`.
  // By default this end-point will try to return up to 1000 members in one
  // request. But it **may return less**, even if more tasks are available.
  // It may also return a `continuationToken` even though there are no more
  // results. However, you can only be sure to have seen all results if you
  // keep calling `listTaskGroup` with the last `continuationToken` until you
  // get a result without a `continuationToken`.
  // If you are not interested in listing all the members at once, you may
  // use the query-string option `limit` to return fewer.
  /* eslint-enable max-len */
  listTaskGroup(...args) {
    this.validate(this.listTaskGroup.entry, args);

    return this.request(this.listTaskGroup.entry, args);
  }
  /* eslint-disable max-len */
  // List tasks that depend on the given `taskId`.
  // As many tasks from different task-groups may dependent on a single tasks,
  // this end-point may return a `continuationToken`. To continue listing
  // tasks you must call `listDependentTasks` again with the
  // `continuationToken` as the query-string option `continuationToken`.
  // By default this end-point will try to return up to 1000 tasks in one
  // request. But it **may return less**, even if more tasks are available.
  // It may also return a `continuationToken` even though there are no more
  // results. However, you can only be sure to have seen all results if you
  // keep calling `listDependentTasks` with the last `continuationToken` until
  // you get a result without a `continuationToken`.
  // If you are not interested in listing all the tasks at once, you may
  // use the query-string option `limit` to return fewer.
  /* eslint-enable max-len */
  listDependentTasks(...args) {
    this.validate(this.listDependentTasks.entry, args);

    return this.request(this.listDependentTasks.entry, args);
  }
  /* eslint-disable max-len */
  // Create a new task, this is an **idempotent** operation, so repeat it if
  // you get an internal server error or network connection is dropped.
  // **Task `deadline`**: the deadline property can be no more than 5 days
  // into the future. This is to limit the amount of pending tasks not being
  // taken care of. Ideally, you should use a much shorter deadline.
  // **Task expiration**: the `expires` property must be greater than the
  // task `deadline`. If not provided it will default to `deadline` + one
  // year. Notice, that artifacts created by task must expire before the task.
  // **Task specific routing-keys**: using the `task.routes` property you may
  // define task specific routing-keys. If a task has a task specific
  // routing-key: `<route>`, then when the AMQP message about the task is
  // published, the message will be CC'ed with the routing-key:
  // `route.<route>`. This is useful if you want another component to listen
  // for completed tasks you have posted.  The caller must have scope
  // `queue:route:<route>` for each route.
  // **Dependencies**: any tasks referenced in `task.dependencies` must have
  // already been created at the time of this call.
  // **Scopes**: Note that the scopes required to complete this API call depend
  // on the content of the `scopes`, `routes`, `schedulerId`, `priority`,
  // `provisionerId`, and `workerType` properties of the task definition.
  // **Legacy Scopes**: The `queue:create-task:..` scope without a priority and
  // the `queue:define-task:..` and `queue:task-group-id:..` scopes are considered
  // legacy and should not be used. Note that the new, non-legacy scopes require
  // a `queue:scheduler-id:..` scope as well as scopes for the proper priority.
  /* eslint-enable max-len */
  createTask(...args) {
    this.validate(this.createTask.entry, args);

    return this.request(this.createTask.entry, args);
  }
  /* eslint-disable max-len */
  // **Deprecated**, this is the same as `createTask` with a **self-dependency**.
  // This is only present for legacy.
  /* eslint-enable max-len */
  defineTask(...args) {
    this.validate(this.defineTask.entry, args);

    return this.request(this.defineTask.entry, args);
  }
  /* eslint-disable max-len */
  // scheduleTask will schedule a task to be executed, even if it has
  // unresolved dependencies. A task would otherwise only be scheduled if
  // its dependencies were resolved.
  // This is useful if you have defined a task that depends on itself or on
  // some other task that has not been resolved, but you wish the task to be
  // scheduled immediately.
  // This will announce the task as pending and workers will be allowed to
  // claim it and resolve the task.
  // **Note** this operation is **idempotent** and will not fail or complain
  // if called with a `taskId` that is already scheduled, or even resolved.
  // To reschedule a task previously resolved, use `rerunTask`.
  /* eslint-enable max-len */
  scheduleTask(...args) {
    this.validate(this.scheduleTask.entry, args);

    return this.request(this.scheduleTask.entry, args);
  }
  /* eslint-disable max-len */
  // This method _reruns_ a previously resolved task, even if it was
  // _completed_. This is useful if your task completes unsuccessfully, and
  // you just want to run it from scratch again. This will also reset the
  // number of `retries` allowed.
  // This method is deprecated in favour of creating a new task with the same
  // task definition (but with a new taskId).
  // Remember that `retries` in the task status counts the number of runs that
  // the queue have started because the worker stopped responding, for example
  // because a spot node died.
  // **Remark** this operation is idempotent, if you try to rerun a task that
  // is not either `failed` or `completed`, this operation will just return
  // the current task status.
  /* eslint-enable max-len */
  rerunTask(...args) {
    this.validate(this.rerunTask.entry, args);

    return this.request(this.rerunTask.entry, args);
  }
  /* eslint-disable max-len */
  // This method will cancel a task that is either `unscheduled`, `pending` or
  // `running`. It will resolve the current run as `exception` with
  // `reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.
  // it doesn't have any runs, an initial run will be added and resolved as
  // described above. Hence, after canceling a task, it cannot be scheduled
  // with `queue.scheduleTask`, but a new run can be created with
  // `queue.rerun`. These semantics is equivalent to calling
  // `queue.scheduleTask` immediately followed by `queue.cancelTask`.
  // **Remark** this operation is idempotent, if you try to cancel a task that
  // isn't `unscheduled`, `pending` or `running`, this operation will just
  // return the current task status.
  /* eslint-enable max-len */
  cancelTask(...args) {
    this.validate(this.cancelTask.entry, args);

    return this.request(this.cancelTask.entry, args);
  }
  /* eslint-disable max-len */
  // Claim pending task(s) for the given `provisionerId`/`workerType` queue.
  // If any work is available (even if fewer than the requested number of
  // tasks, this will return immediately. Otherwise, it will block for tens of
  // seconds waiting for work.  If no work appears, it will return an emtpy
  // list of tasks.  Callers should sleep a short while (to avoid denial of
  // service in an error condition) and call the endpoint again.  This is a
  // simple implementation of "long polling".
  /* eslint-enable max-len */
  claimWork(...args) {
    this.validate(this.claimWork.entry, args);

    return this.request(this.claimWork.entry, args);
  }
  /* eslint-disable max-len */
  // claim a task - never documented
  /* eslint-enable max-len */
  claimTask(...args) {
    this.validate(this.claimTask.entry, args);

    return this.request(this.claimTask.entry, args);
  }
  /* eslint-disable max-len */
  // Refresh the claim for a specific `runId` for given `taskId`. This updates
  // the `takenUntil` property and returns a new set of temporary credentials
  // for performing requests on behalf of the task. These credentials should
  // be used in-place of the credentials returned by `claimWork`.
  // The `reclaimTask` requests serves to:
  //  * Postpone `takenUntil` preventing the queue from resolving
  //    `claim-expired`,
  //  * Refresh temporary credentials used for processing the task, and
  //  * Abort execution if the task/run have been resolved.
  // If the `takenUntil` timestamp is exceeded the queue will resolve the run
  // as _exception_ with reason `claim-expired`, and proceeded to retry to the
  // task. This ensures that tasks are retried, even if workers disappear
  // without warning.
  // If the task is resolved, this end-point will return `409` reporting
  // `RequestConflict`. This typically happens if the task have been canceled
  // or the `task.deadline` have been exceeded. If reclaiming fails, workers
  // should abort the task and forget about the given `runId`. There is no
  // need to resolve the run or upload artifacts.
  /* eslint-enable max-len */
  reclaimTask(...args) {
    this.validate(this.reclaimTask.entry, args);

    return this.request(this.reclaimTask.entry, args);
  }
  /* eslint-disable max-len */
  // Report a task completed, resolving the run as `completed`.
  /* eslint-enable max-len */
  reportCompleted(...args) {
    this.validate(this.reportCompleted.entry, args);

    return this.request(this.reportCompleted.entry, args);
  }
  /* eslint-disable max-len */
  // Report a run failed, resolving the run as `failed`. Use this to resolve
  // a run that failed because the task specific code behaved unexpectedly.
  // For example the task exited non-zero, or didn't produce expected output.
  // Do not use this if the task couldn't be run because if malformed
  // payload, or other unexpected condition. In these cases we have a task
  // exception, which should be reported with `reportException`.
  /* eslint-enable max-len */
  reportFailed(...args) {
    this.validate(this.reportFailed.entry, args);

    return this.request(this.reportFailed.entry, args);
  }
  /* eslint-disable max-len */
  // Resolve a run as _exception_. Generally, you will want to report tasks as
  // failed instead of exception. You should `reportException` if,
  //   * The `task.payload` is invalid,
  //   * Non-existent resources are referenced,
  //   * Declared actions cannot be executed due to unavailable resources,
  //   * The worker had to shutdown prematurely,
  //   * The worker experienced an unknown error, or,
  //   * The task explicitly requested a retry.
  // Do not use this to signal that some user-specified code crashed for any
  // reason specific to this code. If user-specific code hits a resource that
  // is temporarily unavailable worker should report task _failed_.
  /* eslint-enable max-len */
  reportException(...args) {
    this.validate(this.reportException.entry, args);

    return this.request(this.reportException.entry, args);
  }
  /* eslint-disable max-len */
  // This API end-point creates an artifact for a specific run of a task. This
  // should **only** be used by a worker currently operating on this task, or
  // from a process running within the task (ie. on the worker).
  // All artifacts must specify when they `expires`, the queue will
  // automatically take care of deleting artifacts past their
  // expiration point. This features makes it feasible to upload large
  // intermediate artifacts from data processing applications, as the
  // artifacts can be set to expire a few days later.
  // We currently support "S3 Artifacts" officially, with remaining support
  // for two deprecated types.  Do not use these deprecated types.
  // **S3 artifacts**, is useful for static files which will be
  // stored on S3. When creating an S3 artifact the queue will return a
  // pre-signed URL to which you can do a `PUT` request to upload your
  // artifact. Note that `PUT` request **must** specify the `content-length`
  // header and **must** give the `content-type` header the same value as in
  // the request to `createArtifact`.
  // DEPRECATED **Blob artifacts**, are useful for storing large files.  Currently, these
  // are all stored in S3 but there are facilities for adding support for other
  // backends in futre.  A call for this type of artifact must provide information
  // about the file which will be uploaded.  This includes sha256 sums and sizes.
  // This method will return a list of general form HTTP requests which are signed
  // by AWS S3 credentials managed by the Queue.  Once these requests are completed
  // the list of `ETag` values returned by the requests must be passed to the
  // queue `completeArtifact` method
  // DEPRECATED **Azure artifacts** are stored in _Azure Blob Storage_ service
  // which given the consistency guarantees and API interface offered by Azure
  // is more suitable for artifacts that will be modified during the execution
  // of the task. For example docker-worker has a feature that persists the
  // task log to Azure Blob Storage every few seconds creating a somewhat
  // live log. A request to create an Azure artifact will return a URL
  // featuring a [Shared-Access-Signature](http://msdn.microsoft.com/en-us/library/azure/dn140256.aspx),
  // refer to MSDN for further information on how to use these.
  // **Warning: azure artifact is currently an experimental feature subject
  // to changes and data-drops.**
  // **Reference artifacts**, only consists of meta-data which the queue will
  // store for you. These artifacts really only have a `url` property and
  // when the artifact is requested the client will be redirect the URL
  // provided with a `303` (See Other) redirect. Please note that we cannot
  // delete artifacts you upload to other service, we can only delete the
  // reference to the artifact, when it expires.
  // **Error artifacts**, only consists of meta-data which the queue will
  // store for you. These artifacts are only meant to indicate that you the
  // worker or the task failed to generate a specific artifact, that you
  // would otherwise have uploaded. For example docker-worker will upload an
  // error artifact, if the file it was supposed to upload doesn't exists or
  // turns out to be a directory. Clients requesting an error artifact will
  // get a `424` (Failed Dependency) response. This is mainly designed to
  // ensure that dependent tasks can distinguish between artifacts that were
  // suppose to be generated and artifacts for which the name is misspelled.
  // **Artifact immutability**, generally speaking you cannot overwrite an
  // artifact when created. But if you repeat the request with the same
  // properties the request will succeed as the operation is idempotent.
  // This is useful if you need to refresh a signed URL while uploading.
  // Do not abuse this to overwrite artifacts created by another entity!
  // Such as worker-host overwriting artifact created by worker-code.
  // As a special case the `url` property on _reference artifacts_ can be
  // updated. You should only use this to update the `url` property for
  // reference artifacts your process has created.
  /* eslint-enable max-len */
  createArtifact(...args) {
    this.validate(this.createArtifact.entry, args);

    return this.request(this.createArtifact.entry, args);
  }
  /* eslint-disable max-len */
  // This endpoint finalises an upload done through the blob `storageType`.
  // The queue will ensure that the task/run is still allowing artifacts
  // to be uploaded.  For single-part S3 blob artifacts, this endpoint
  // will simply ensure the artifact is present in S3.  For multipart S3
  // artifacts, the endpoint will perform the commit step of the multipart
  // upload flow.  As the final step for both multi and single part artifacts,
  // the `present` entity field will be set to `true` to reflect that the
  // artifact is now present and a message published to pulse.  NOTE: This
  // endpoint *must* be called for all artifacts of storageType 'blob'
  /* eslint-enable max-len */
  completeArtifact(...args) {
    this.validate(this.completeArtifact.entry, args);

    return this.request(this.completeArtifact.entry, args);
  }
  /* eslint-disable max-len */
  // Get artifact by `<name>` from a specific run.
  // **Public Artifacts**, in-order to get an artifact you need the scope
  // `queue:get-artifact:<name>`, where `<name>` is the name of the artifact.
  // But if the artifact `name` starts with `public/`, authentication and
  // authorization is not necessary to fetch the artifact.
  // **API Clients**, this method will redirect you to the artifact, if it is
  // stored externally. Either way, the response may not be JSON. So API
  // client users might want to generate a signed URL for this end-point and
  // use that URL with an HTTP client that can handle responses correctly.
  // **Downloading artifacts**
  // There are some special considerations for those http clients which download
  // artifacts.  This api endpoint is designed to be compatible with an HTTP 1.1
  // compliant client, but has extra features to ensure the download is valid.
  // It is strongly recommend that consumers use either taskcluster-lib-artifact (JS),
  // taskcluster-lib-artifact-go (Go) or the CLI written in Go to interact with
  // artifacts.
  // In order to download an artifact the following must be done:
  // 1. Obtain queue url.  Building a signed url with a taskcluster client is
  // recommended
  // 1. Make a GET request which does not follow redirects
  // 1. In all cases, if specified, the
  // x-taskcluster-location-{content,transfer}-{sha256,length} values must be
  // validated to be equal to the Content-Length and Sha256 checksum of the
  // final artifact downloaded. as well as any intermediate redirects
  // 1. If this response is a 500-series error, retry using an exponential
  // backoff.  No more than 5 retries should be attempted
  // 1. If this response is a 400-series error, treat it appropriately for
  // your context.  This might be an error in responding to this request or
  // an Error storage type body.  This request should not be retried.
  // 1. If this response is a 200-series response, the response body is the artifact.
  // If the x-taskcluster-location-{content,transfer}-{sha256,length} and
  // x-taskcluster-location-content-encoding are specified, they should match
  // this response body
  // 1. If the response type is a 300-series redirect, the artifact will be at the
  // location specified by the `Location` header.  There are multiple artifact storage
  // types which use a 300-series redirect.
  // 1. For all redirects followed, the user must verify that the content-sha256, content-length,
  // transfer-sha256, transfer-length and content-encoding match every further request.  The final
  // artifact must also be validated against the values specified in the original queue response
  // 1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`
  // must not occur
  // 1. A request which has x-taskcluster-artifact-storage-type value of `blob` and does not
  // have x-taskcluster-location-content-sha256 or x-taskcluster-location-content-length
  // must be treated as an error
  // **Headers**
  // The following important headers are set on the response to this method:
  // * location: the url of the artifact if a redirect is to be performed
  // * x-taskcluster-artifact-storage-type: the storage type.  Example: blob, s3, error
  // The following important headers are set on responses to this method for Blob artifacts
  // * x-taskcluster-location-content-sha256: the SHA256 of the artifact
  // *after* any content-encoding is undone.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})
  // * x-taskcluster-location-content-length: the number of bytes *after* any content-encoding
  // is undone
  // * x-taskcluster-location-transfer-sha256: the SHA256 of the artifact
  // *before* any content-encoding is undone.  This is the SHA256 of what is sent over
  // the wire.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})
  // * x-taskcluster-location-transfer-length: the number of bytes *after* any content-encoding
  // is undone
  // * x-taskcluster-location-content-encoding: the content-encoding used.  It will either
  // be `gzip` or `identity` right now.  This is hardcoded to a value set when the artifact
  // was created and no content-negotiation occurs
  // * x-taskcluster-location-content-type: the content-type of the artifact
  // **Caching**, artifacts may be cached in data centers closer to the
  // workers in-order to reduce bandwidth costs. This can lead to longer
  // response times. Caching can be skipped by setting the header
  // `x-taskcluster-skip-cache: true`, this should only be used for resources
  // where request volume is known to be low, and caching not useful.
  // (This feature may be disabled in the future, use is sparingly!)
  /* eslint-enable max-len */
  getArtifact(...args) {
    this.validate(this.getArtifact.entry, args);

    return this.request(this.getArtifact.entry, args);
  }
  /* eslint-disable max-len */
  // Get artifact by `<name>` from the last run of a task.
  // **Public Artifacts**, in-order to get an artifact you need the scope
  // `queue:get-artifact:<name>`, where `<name>` is the name of the artifact.
  // But if the artifact `name` starts with `public/`, authentication and
  // authorization is not necessary to fetch the artifact.
  // **API Clients**, this method will redirect you to the artifact, if it is
  // stored externally. Either way, the response may not be JSON. So API
  // client users might want to generate a signed URL for this end-point and
  // use that URL with a normal HTTP client.
  // **Remark**, this end-point is slightly slower than
  // `queue.getArtifact`, so consider that if you already know the `runId` of
  // the latest run. Otherwise, just us the most convenient API end-point.
  /* eslint-enable max-len */
  getLatestArtifact(...args) {
    this.validate(this.getLatestArtifact.entry, args);

    return this.request(this.getLatestArtifact.entry, args);
  }
  /* eslint-disable max-len */
  // Returns a list of artifacts and associated meta-data for a given run.
  // As a task may have many artifacts paging may be necessary. If this
  // end-point returns a `continuationToken`, you should call the end-point
  // again with the `continuationToken` as the query-string option:
  // `continuationToken`.
  // By default this end-point will list up-to 1000 artifacts in a single page
  // you may limit this with the query-string parameter `limit`.
  /* eslint-enable max-len */
  listArtifacts(...args) {
    this.validate(this.listArtifacts.entry, args);

    return this.request(this.listArtifacts.entry, args);
  }
  /* eslint-disable max-len */
  // Returns a list of artifacts and associated meta-data for the latest run
  // from the given task.
  // As a task may have many artifacts paging may be necessary. If this
  // end-point returns a `continuationToken`, you should call the end-point
  // again with the `continuationToken` as the query-string option:
  // `continuationToken`.
  // By default this end-point will list up-to 1000 artifacts in a single page
  // you may limit this with the query-string parameter `limit`.
  /* eslint-enable max-len */
  listLatestArtifacts(...args) {
    this.validate(this.listLatestArtifacts.entry, args);

    return this.request(this.listLatestArtifacts.entry, args);
  }
  /* eslint-disable max-len */
  // Get all active provisioners.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 provisioners in a single
  // page. You may limit this with the query-string parameter `limit`.
  /* eslint-enable max-len */
  listProvisioners(...args) {
    this.validate(this.listProvisioners.entry, args);

    return this.request(this.listProvisioners.entry, args);
  }
  /* eslint-disable max-len */
  // Get an active provisioner.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  /* eslint-enable max-len */
  getProvisioner(...args) {
    this.validate(this.getProvisioner.entry, args);

    return this.request(this.getProvisioner.entry, args);
  }
  /* eslint-disable max-len */
  // Declare a provisioner, supplying some details about it.
  // `declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are
  // possessed. For example, a request to update the `aws-provisioner-v1`
  // provisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope
  // `queue:declare-provisioner:aws-provisioner-v1#description`.
  // The term "provisioner" is taken broadly to mean anything with a provisionerId.
  // This does not necessarily mean there is an associated service performing any
  // provisioning activity.
  /* eslint-enable max-len */
  declareProvisioner(...args) {
    this.validate(this.declareProvisioner.entry, args);

    return this.request(this.declareProvisioner.entry, args);
  }
  /* eslint-disable max-len */
  // Get an approximate number of pending tasks for the given `provisionerId`
  // and `workerType`.
  // The underlying Azure Storage Queues only promises to give us an estimate.
  // Furthermore, we cache the result in memory for 20 seconds. So consumers
  // should be no means expect this to be an accurate number.
  // It is, however, a solid estimate of the number of pending tasks.
  /* eslint-enable max-len */
  pendingTasks(...args) {
    this.validate(this.pendingTasks.entry, args);

    return this.request(this.pendingTasks.entry, args);
  }
  /* eslint-disable max-len */
  // Get all active worker-types for the given provisioner.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 worker-types in a single
  // page. You may limit this with the query-string parameter `limit`.
  /* eslint-enable max-len */
  listWorkerTypes(...args) {
    this.validate(this.listWorkerTypes.entry, args);

    return this.request(this.listWorkerTypes.entry, args);
  }
  /* eslint-disable max-len */
  // Get a worker-type from a provisioner.
  /* eslint-enable max-len */
  getWorkerType(...args) {
    this.validate(this.getWorkerType.entry, args);

    return this.request(this.getWorkerType.entry, args);
  }
  /* eslint-disable max-len */
  // Declare a workerType, supplying some details about it.
  // `declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are
  // possessed. For example, a request to update the `gecko-b-1-w2008` worker-type within the `aws-provisioner-v1`
  // provisioner with a body `{description: 'This worker type is great'}` would require you to have the scope
  // `queue:declare-worker-type:aws-provisioner-v1/gecko-b-1-w2008#description`.
  /* eslint-enable max-len */
  declareWorkerType(...args) {
    this.validate(this.declareWorkerType.entry, args);

    return this.request(this.declareWorkerType.entry, args);
  }
  /* eslint-disable max-len */
  // Get a list of all active workers of a workerType.
  // `listWorkers` allows a response to be filtered by quarantined and non quarantined workers.
  // To filter the query, you should call the end-point with `quarantined` as a query-string option with a
  // true or false value.
  // The response is paged. If this end-point returns a `continuationToken`, you
  // should call the end-point again with the `continuationToken` as a query-string
  // option. By default this end-point will list up to 1000 workers in a single
  // page. You may limit this with the query-string parameter `limit`.
  /* eslint-enable max-len */
  listWorkers(...args) {
    this.validate(this.listWorkers.entry, args);

    return this.request(this.listWorkers.entry, args);
  }
  /* eslint-disable max-len */
  // Get a worker from a worker-type.
  /* eslint-enable max-len */
  getWorker(...args) {
    this.validate(this.getWorker.entry, args);

    return this.request(this.getWorker.entry, args);
  }
  /* eslint-disable max-len */
  // Quarantine a worker
  /* eslint-enable max-len */
  quarantineWorker(...args) {
    this.validate(this.quarantineWorker.entry, args);

    return this.request(this.quarantineWorker.entry, args);
  }
  /* eslint-disable max-len */
  // Declare a worker, supplying some details about it.
  // `declareWorker` allows updating one or more properties of a worker as long as the required scopes are
  // possessed.
  /* eslint-enable max-len */
  declareWorker(...args) {
    this.validate(this.declareWorker.entry, args);

    return this.request(this.declareWorker.entry, args);
  }
}
