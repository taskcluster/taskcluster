version: 91
description: migrate existing azure queue messages into new tables

migrationScript: 0091-migration.sql
downgradeScript: 0091-downgrade.sql

methods:
  # those methods and the azure messages table would be dropped in next release
  azure_queue_get:
    deprecated: true
  azure_queue_count:
    deprecated: true
  azure_queue_delete:
    deprecated: true
  azure_queue_update:
    deprecated: true
  azure_queue_put_extra:
    deprecated: true
  azure_queue_delete_expired:
    deprecated: true

  queue_pending_tasks_get:
    description: |
      Get up to `count` tasks for the pending tasks from the given taskQueueId.
      Tasks are locked and will temporarily become invisible for the `visible` period.
    mode: write
    serviceName: queue
    args: task_queue_id_in text, visible_in timestamptz, count integer
    returns: table (task_id text, run_id integer, hint_id text, pop_receipt uuid)
    body: |-
      begin
        return query
          with updated as (
            update queue_pending_tasks q
            set pop_receipt = public.gen_random_uuid(),
              visible = visible_in
            where
              q.task_id in (
                select q2.task_id
                from queue_pending_tasks q2
                where q2.task_queue_id = task_queue_id_in
                  and q2.visible <= now()
                  and q2.expires > now()
                order by q2.priority desc, q2.inserted asc
                for update skip locked
                limit count
            )
            returning q.priority, q.inserted, q.task_id, q.run_id, q.hint_id, q.pop_receipt
          )
          select u.task_id, u.run_id, u.hint_id, u.pop_receipt
          from updated as u
          order by u.priority desc, u.inserted asc;
      end

  queue_pending_tasks_put:
    description: |
      Put the task into the pending queue.
      When record already exists, we update the priority, run_id, hint_id and expiration.
      This also sends a notification to the `task_pending` channel with the `task_queue_id` as its payload.
    mode: write
    serviceName: queue
    args: task_queue_id_in text, priority_in integer, task_id_in text, run_id_in integer, hint_id_in text, expires_in timestamp
    returns: void
    body: |-
      begin
        INSERT INTO queue_pending_tasks (task_queue_id, priority, task_id, run_id, hint_id, inserted, expires, visible)
        VALUES (
          task_queue_id_in,
          priority_in,
          task_id_in,
          run_id_in,
          hint_id_in,
          now(),
          expires_in,
          now()
        )
        ON CONFLICT (task_id) DO UPDATE
          SET
            expires = greatest(coalesce(expires_in, queue_pending_tasks.expires), queue_pending_tasks.expires),
            priority = priority_in,
            run_id = greatest(run_id_in, queue_pending_tasks.run_id),
            hint_id = hint_id_in
          WHERE
            queue_pending_tasks.task_queue_id = task_queue_id_in
            AND queue_pending_tasks.task_id = task_id_in
            AND queue_pending_tasks.pop_receipt is null;

        -- notify listeners that there is a new task in the queue
        EXECUTE 'NOTIFY task_pending, ' || quote_literal(task_queue_id_in) || ';';
      end

  queue_pending_tasks_release:
    description: |
      Release task back to the queue to be picked up by another worker.
    mode: write
    serviceName: queue
    args: task_id_in text, pop_receipt_in uuid
    returns: void
    body: |-
      begin
        UPDATE queue_pending_tasks
        SET visible = now()
        WHERE task_id = task_id_in AND pop_receipt = pop_receipt_in;
      end

  queue_pending_tasks_delete:
    description: |
      Delete single pending task from the queue.
    mode: write
    serviceName: queue
    args: task_id_in text, pop_receipt_in uuid
    returns: void
    body: |-
      begin
        DELETE FROM queue_pending_tasks
        WHERE task_id = task_id_in AND pop_receipt = pop_receipt_in;
      end

  queue_pending_tasks_delete_expired:
    description: |
      Delete all expired tasks from pending queue.
    mode: write
    serviceName: queue
    args: ''
    returns: void
    body: |-
      begin
        DELETE FROM queue_pending_tasks
          WHERE expires <= now();
      end


  queue_pending_tasks_count:
    description: |
      Count the number of pending tasks for given task queue.
    mode: read
    serviceName: queue
    args: task_queue_id_in text
    returns: integer
    body: |-
      begin
        return (
          select count(*)
          from queue_pending_tasks
          where task_queue_id = task_queue_id_in
            and expires > now()
        );
      end

  # deadline queue
  queue_task_deadline_put:
    description: |
      Track task deadline upon task creation. This would stay until task
      deadline to see if it was ever scheduled or resolved.
    mode: write
    serviceName: queue
    args: task_group_id_in text, task_id_in text, scheduler_id_in text, deadline_in timestamptz, visible timestamptz
    returns: void
    body: |-
      begin
        insert into queue_task_deadlines (
          task_group_id,
          task_id,
          scheduler_id,
          created,
          deadline,
          visible
        )
        values (
          task_group_id_in,
          task_id_in,
          scheduler_id_in,
          now(),
          deadline_in,
          visible
        );
      end

  queue_task_deadline_get:
    description: |
      Get up to `count` tasks from the deadline queue
    mode: write
    serviceName: queue
    args: visible_in timestamptz, count integer
    returns: table (task_id text, task_group_id text, scheduler_id text, deadline timestamptz, pop_receipt uuid)
    body: |-
      begin
        return query
          with updated as (
            update queue_task_deadlines q
            set pop_receipt = public.gen_random_uuid(),
              visible = visible_in
            where
              q.task_id in (
                select q2.task_id
                from queue_task_deadlines q2
                where q2.visible <= now()
                order by q2.deadline
                for update skip locked
                limit count
            )
            returning q.task_id, q.task_group_id, q.scheduler_id, q.deadline, q.pop_receipt
          )
          select u.task_id, u.task_group_id, u.scheduler_id, u.deadline, u.pop_receipt
          from updated as u
          order by u.deadline;
      end

  queue_task_deadline_delete:
    description: |
      Delete single deadline task.
    mode: write
    serviceName: queue
    args: task_id_in text, pop_receipt_in uuid
    returns: void
    body: |-
      begin
        delete from queue_task_deadlines
        where task_id = task_id_in
          and pop_receipt = pop_receipt_in;
      end

  queue_task_deadline_resolved:
    description: |
      Once the task gets resolved it is no longer relevant for the deadline queue.
      Since resolved task triggered dependency resolver, its dependencies were already
      updated by DependencyTracker.
      We can safely delete given run from the deadline queue.
    mode: write
    serviceName: queue
    args: task_id_in text
    returns: void
    body: |-
      begin
        delete from queue_task_deadlines
        where task_id = task_id_in;
      end


  # claim queue
  queue_claimed_task_put:
    description: |
      Track when task was claimed and when it should be reclaimed.
      There can be only one record for a given taskId+runId combination,
      so if there is conflict, only the latest `taken_until` and `visible` values are updated.
    mode: write
    serviceName: queue
    args: task_id_in text, run_id_in integer, taken_until_in timestamptz, task_queue_id_in text, worker_group_in text, worker_id_in text
    returns: void
    body: |-
      begin
        INSERT INTO queue_claimed_tasks (
          task_id,
          run_id,
          task_queue_id,
          worker_group,
          worker_id,
          claimed,
          taken_until,
          visible
        )
        VALUES (
          task_id_in,
          run_id_in,
          task_queue_id_in,
          worker_group_in,
          worker_id_in,
          now(),
          taken_until_in,
          taken_until_in -- visible initially same as taken_until
        )
        ON CONFLICT (task_id, run_id) DO UPDATE
          SET
            taken_until = greatest(taken_until_in, queue_claimed_tasks.taken_until),
            visible = greatest(taken_until_in, queue_claimed_tasks.visible)
          WHERE
            queue_claimed_tasks.task_id = task_id_in
            AND queue_claimed_tasks.run_id = run_id_in
        ;
      end

  queue_claimed_task_get:
    description: |
      Get up to `count` tasks from the claimed queue
    mode: write
    serviceName: queue
    args: visible_in timestamptz, count integer
    returns: table (task_id text, run_id integer, taken_until timestamptz, pop_receipt uuid)
    body: |-
      begin
        return query
          with updated as (
            update queue_claimed_tasks q
            set pop_receipt = public.gen_random_uuid(),
              visible = visible_in
            where
              q.task_id in (
                select q2.task_id
                from queue_claimed_tasks q2
                where q2.visible <= now()
                order by q2.taken_until
                for update skip locked
                limit count
            )
            returning q.task_id, q.run_id, q.taken_until, q.pop_receipt
          )
          select u.task_id, u.run_id, u.taken_until, u.pop_receipt
          from updated as u
          order by u.taken_until;
      end

  queue_claimed_task_delete:
    description: |
      Delete single claimed task from the queue.
    mode: write
    serviceName: queue
    args: task_id_in text, pop_receipt_in uuid
    returns: void
    body: |-
      begin
        delete from queue_claimed_tasks
        where task_id = task_id_in
          and pop_receipt = pop_receipt_in;
      end

  queue_claimed_task_resolved:
    description: |
      Once the task gets resolved it is no longer relevant for the claim queue, since it cannot expire anymore.
      We can safely delete given run from the claim queue.
    mode: write
    serviceName: queue
    args: task_id_in text, run_id_in integer
    returns: void
    body: |-
      begin
        delete from queue_claimed_tasks
        where task_id = task_id_in
          and run_id = run_id_in;
      end


  # resolved queue
  queue_resolved_task_put:
    description: |
      Track when task was resolved.
      This is a short-lived record that is used by dependency resolver to update dependencies.
      Notification is sent to `task_resolved` channel with the `task_id` as its payload.
    mode: write
    serviceName: queue
    args: task_group_id_in text, task_id_in text, scheduler_id_in text, resolution_in text
    returns: void
    body: |-
      begin
        insert into queue_resolved_tasks (
          task_group_id,
          task_id,
          scheduler_id,
          resolution,
          resolved,
          visible
        )
        values (
          task_group_id_in,
          task_id_in,
          scheduler_id_in,
          resolution_in,
          now(),
          now()
        );

        -- notify listeners that task was resolved
        EXECUTE 'NOTIFY task_resolved';
      end

  queue_resolved_task_get:
    description: |
      Get up to `count` tasks from the resolved queue
    mode: write
    serviceName: queue
    args: visible_in timestamptz, count integer
    returns: table (task_id text, task_group_id text, scheduler_id text, resolution text, pop_receipt uuid)
    body: |-
      begin
        return query
          with updated as (
            update queue_resolved_tasks q
            set pop_receipt = public.gen_random_uuid(),
              visible = visible_in
            where
              q.task_id in (
                select q2.task_id
                from queue_resolved_tasks q2
                where q2.visible <= now()
                order by q2.visible
                for update skip locked
                limit count
            )
            returning q.task_id, q.task_group_id, q.scheduler_id, q.resolution, q.visible, q.pop_receipt
          )
          select u.task_id, u.task_group_id, u.scheduler_id, u.resolution, u.pop_receipt
          from updated as u
          order by u.visible;
      end

  queue_resolved_task_delete:
    description: |
      Delete single task from claimed queue
    mode: write
    serviceName: queue
    args: task_id_in text, pop_receipt_in uuid
    returns: void
    body: |-
      begin
        delete from queue_resolved_tasks
        where task_id = task_id_in
          and pop_receipt = pop_receipt_in;
      end
