# Monitor Library

A convenient library to wrap up all of the pieces needed for a Taskcluster service to record metrics and write structured logs.
By default it will report any errors that cause the process to exit, and report as warnings any errors that cause stats writing to not work. To
disable any of these, you can see the Options and Defaults section below.

Process monitoring can be turned on by using the `monitor.resources(<process name>)` function where `<process name>` will generally end up
being something like `web` or `worker`.

Taskcluster has some generic concepts that are able to be monitored easily using utility functions in this package. The Usage section lists these
cases and shows how to use this package to measure them.

Usage
-----

```js
const Monitor = require('taskcluster-lib-monitor');

const mon = new Monitor({
  projectName: 'taskcluster-foo',
  mock: cfg.monitor.mock,  // false in production, true in testing
  processName: 'server',       // or otherwise for e.g., periodic tasks
});
```

The available options are:

 * `projectName` - The name of this service.
 * `level` - A syslog logging level. Any messages with less severity than this level will not be logged.
 * `pretty` - Only for development use. Pretty prints logs rather than using a structured form.
 * `patchGlobal` - If true (the default), any uncaught errors in the service will be reported.
 * `processName` - If set to a string that identifies this process, cpu and memory
    usage of the process will be reported on an interval. Note: This can also be
    turned on by monitor.resources(...) later if wanted.  That allows for
    gracefully stopping as well.
 * `mock` - If true, the monitoring object will be a fake that stores data for testing but does not report it (for testing).
 * `enable` - If false, the monitoring object will only report to the console (but not store data; for deployments without monitoring).
 * `metadata` - an object of extra fields to attach to any logs generated by this object.
 * `metadata.gitVersion` -  git version (for correlating errors); or...
 * `gitVersionFile` -  file containing git version (relative to app root)

### Logging

This library allows writing logs to stdout in the [mozlog](https://wiki.mozilla.org/Firefox/Services/Logging) format.

```json
{
  "Timestamp": <time since unix epoch in nanoseconds>,
  "Type": "...",
  "Logger": "...",
  "Hostname": "...",
  "EnvVersion": "2.0",
  "Severity": ...,
  "Pid": ...,
  "Fields": {...}
}
```

It provides the following functions:

```js
  emerg(type, fields) // Not recommended for use
  alert(type, fields)
  crit(type, fields)
  err(type, fields)
  warning(type, fields)
  notice(type, fields)
  info(type, fields)
  debug(type, fields)
```

The `type` will be set in the event object as the `Type` field in the mozlog format. Everything in `fields` will be set in the `Fields`.
We default to `info` logging level so normally `debug` logs will not be logged.

### Measuring and Counting Things

To record a current measurement of a named value:

```js
monitor.measure('foo', 10);
```

To increment the count of some value:

```js
monitor.count('bar');
monitor.count('bar', 4); // increment by 4
```

To construct an object capable of measuring and counting, but which adds a
prefix to the measured and counted names, use

```js
const thingMonitor = monitor.prefix('thing');
thing.measure('foo', 11);
thing.count('bar');
```

These events will have types of `monitor.measure` and `monitor.count` respectively. The fields will have `key` and `val`.

### Reporting Errors

There are lots of options for reporting errors:

```js
// Report error as a string
monitor.reportError('Something went wrong!');
// Report error (from catch-block or something like that)
monitor.reportError(new Error("..."));
// Report an error with extra info
monitor.reportError(new Error("..."), {foo: 'bar'});
// (DEPRECATED) Report error as a warning. This will simply append 'warning' to fields
monitor.reportError(new Error("..."), 'warning');
```

### Monitoring CPU & Memory

```js
// Begin monitoring CPU & Memory
const stopMonitor = monitor.resources('web');
```
you can later call `stopMonitor()` to gracefully shut down the monitoring.

### Timing Functions/Promises

Often we wish to measure how long time an operation takes, synchronous or
asynchronous, this can done using the `monitor.timer(key, funcOrPromise)`
method. It takes a `key` (as name of the metric) and a function or promise to
measure the time of. If the function returns a promise, it'll include the time
it takes for the promise to resolve.

The following examples are valid usages:
```js
// Timing a synchronous operation
const root = monitor.timer('compute-sqrt', () => {
  return Math.sqrt(25);
})
assert(root === 5);

// Timing a single asynchronous function (promise)
const task = await monitor.timer('load-task', queue.task(taskId));
assert(task.workerType == '...'); // task is the task definition response

// Timing an asynchronous function
const task = await monitor.timer('poll-for-task', async () => {
  while (true) {
    try {
      return await queue.task(taskId);
    } catch (err) {
      // Ignore error and try again
      // In the real would you want a maximum time before you stop polling
      // And probably some sleeping between each polling attempt...
    }
  }
});
assert(task.workerType == '...'); // task is the task definition response

```

Rejected promises and errors will bubble up, and the time be will
measured and recoded just like successful functions or promises.

### Timing Handlers

A common pattern in Taskcluster projects is to have handler functions in a worker that take a message as an argument and perform some action. These
can be timed (in milliseconds) by wrapping them with `taskcluster-lib-monitor`:

```js
const monitor = new Monitor({
  projectName: 'tc-stats-collector',
});

const listener = new taskcluster.PulseListener({
  credentials: {clientId: 'test-client', accessToken: 'test'},
  queueName: 'a-queue-name',
});

const handler = function(message) {
  console.log(message);
};

listener.on('message', monitor.timedHandler('logging-listener', handler));
```

Specifically, `timedHandler` takes a function and wraps it with timing logic, returning a function with the same signature.

### Express Timing Middleware

Most Taskcluster services are Express services. We can easily time how long endpoints take to respond to requests by inserting `taskcluster-lib-monitor`
as middleware:

```js
const monitor = new Monitor({
  projectName: 'tc-stats-collector',
  credentials: {clientId: 'test-client', accessToken: 'test'},
});

// Express setup, etc.

middleware.push(monitor.expressMiddleware('name_of_function'));
```
This is already integrated in `taskcluster-lib-api` and probably doesn't need to be implemented in your service on its own.


### Timing AWS SDK Calls

Oftentimes a lot of a service's time will be spent interacting with AWS services. These interactions can be measured
as in the following example:

```js
const aws = require('aws-sdk');
const ec2 = new aws.EC2({region: 'us-west-2'});
monitor.patchAWS(ec2);
await ec2.describeAvailabilityZones().promise().catch(err => {
  debug('Ignored ec2 error, we measure duration, not success, err: ', err);
});
```

### Timing Arbitary Steps
If none of the above options are convenient for you, you can also just start and stop timers whenever you want. A timer may
only be started and measured once. Any attempts over that will cause it to throw an Error.

```js
const doodad = monitor.timeKeeper('metricName', {optional: 'extra data'});
// Do some stuff here that takes some amount of time
// ...
// Keep doing stuff here however long you like
doodad.measure();
```

### Monitoring One-Shot Processes

Many Taskcluster services use one-shot processes to expire old data.  The
expectation is that these processes will be started at specific times, do their
business, and exit.  The `oneShot` method is designed to wrap such processs
with timing and error handling support.

```javascript
  'expire-info': {
    requires: ['cfg', 'monitor'],
    setup: ({cfg, monitor}) => {
      return monitor.oneShot('expire-info', () => {
        // do the expiration stuff
      });
    },  
  },  
```

This function will:
 * time the invocation, measured as `duration`
 * count the invocation if successful, measured as `done`
 * report any errors or promise rejections
 * shut down and flush monitoring
 * call `process.exit` on success or failure
Note, then, that the function **does not return**.
