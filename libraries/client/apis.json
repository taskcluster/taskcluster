{
  "Auth": {
    "referenceUrl": "http://references.taskcluster.net/auth/v1/api.json",
    "reference": {
      "version": "0.2.0",
      "title": "Authentication API",
      "description": "Authentication related API end-points for taskcluster.",
      "baseUrl": "http://auth.taskcluster.net/v1",
      "entries": [
        {
          "type": "function",
          "method": "get",
          "route": "/client/<clientId>/scopes",
          "args": [
            "clientId"
          ],
          "name": "inspect",
          "scopes": [
            "auth:inspect",
            "auth:credentials"
          ],
          "title": "Get Client Authorized Scopes",
          "description": "Returns the scopes the client is authorized to access and the date-time\nwhere the clients authorization is set to expire.\n\nThis API end-point allows you inspect clients without getting access to\ncredentials, as provide by the `getCredentials` request below.",
          "output": "http://schemas.taskcluster.net/auth/v1/client-scopes-response.json#"
        },
        {
          "type": "function",
          "method": "get",
          "route": "/client/<clientId>/credentials",
          "args": [
            "clientId"
          ],
          "name": "getCredentials",
          "scopes": [
            "auth:credentials"
          ],
          "title": "Get Client Credentials",
          "description": "Returns the clients `accessToken` as needed for verifying signatures.\nThis API end-point also returns the list of scopes the client is\nauthorized for and the date-time where the client authorization expires\n\nRemark, **if you don't need** the `accessToken` but only want to see what\nscopes a client is authorized for, you should use the `inspect` function\ndescribed above.",
          "output": "http://schemas.taskcluster.net/auth/v1/client-credentials-response.json#"
        }
      ]
    }
  },
  "Queue": {
    "referenceUrl": "http://references.taskcluster.net/queue/v1/api.json",
    "reference": {
      "version": "0.2.0",
      "title": "Queue API Documentation",
      "description": "The queue, typically available at `queue.taskcluster.net`, is responsible\nfor accepting tasks and track their state as they are executed by\nworkers. In order ensure they are eventually resolved.\n\nThis document describes the API end-points offered by the queue. These \nend-points targets the following audience:\n * Schedulers, who create tasks to be executed,\n * Workers, who execute tasks, and\n * Tools, that wants to inspect the state of a task.",
      "baseUrl": "http://queue.taskcluster.net/v1",
      "entries": [
        {
          "type": "function",
          "method": "post",
          "route": "/task/new",
          "args": [],
          "name": "createTask",
          "title": "Create new task",
          "description": "Create a new task, the `status` of the resulting JSON is a task status\nstructure, you can find the `taskId` in this structure, enjoy.",
          "input": "http://schemas.taskcluster.net/queue/v1/task.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/create-task-response.json#"
        },
        {
          "type": "function",
          "method": "get",
          "route": "/define-tasks",
          "args": [],
          "name": "defineTasks",
          "title": "Define Tasks",
          "description": "Request a number of `taskId`s and signed URL to which the tasks can be\nuploaded. The tasks will not be scheduled, to do this you must called the\n`/task/:taskId/schedule` API end-point.\n\nThe purpose of this API end-point is allow schedulers to upload a set of\ntasks to S3 without the tasks becoming _pending_ immediately. This useful\nif you have a set of dependent tasks. Then you can upload all the tasks\nand when the dependencies of a tasks have been resolved, you can schedule\nthe task by calling `/task/:taskId/schedule`. This eliminates the need to\nstore tasks somewhere else while waiting for dependencies to resolve.\n\n**Remark** the queue does not track tasks before they have been \n_scheduled_, hence, you'll not able to call `/task/:taskId/status` with\n`taskId`s assigned here, before they are scheduled with\n`/task/:taskId/schedule`.",
          "input": "http://schemas.taskcluster.net/queue/v1/define-tasks-request.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/define-tasks-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/task/<taskId>/schedule",
          "args": [
            "taskId"
          ],
          "name": "scheduleTask",
          "title": "Schedule Defined Task",
          "description": "If you've uploaded task definitions to PUT URLs obtained from\n`/define-tasks`, then you can schedule the tasks using this method.\nThis will down fetch and validate the task definition against the\nrequired JSON schema.\n\nThis method has the same response as `/task/new`, using this method in\ncombination with `/define-tasks` is just an efficient way of storing\nand defining a set of tasks you want to schedule later.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `/task/:taskId/rerun`.",
          "output": "http://schemas.taskcluster.net/queue/v1/task-schedule-response.json#"
        },
        {
          "type": "function",
          "method": "get",
          "route": "/task/<taskId>/status",
          "args": [
            "taskId"
          ],
          "name": "getTaskStatus",
          "title": "Get task status",
          "description": "Get task status structure from `taskId`",
          "output": "http://schemas.taskcluster.net/queue/v1/task-status-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/task/<taskId>/claim",
          "args": [
            "taskId"
          ],
          "name": "claimTask",
          "title": "Claim task",
          "description": "Claim task, takes workerGroup, workerId and optionally runId as input\nreturns task status structure, runId, resultPutUrl and logsPutUrl",
          "input": "http://schemas.taskcluster.net/queue/v1/task-claim-request.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/task-claim-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/task/<taskId>/artifact-urls",
          "args": [
            "taskId"
          ],
          "name": "requestArtifactUrls",
          "title": "Get artifact urls",
          "description": "Get artifact-urls for posted artifact urls...",
          "input": "http://schemas.taskcluster.net/queue/v1/artifact-url-request.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/artifact-url-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/task/<taskId>/completed",
          "args": [
            "taskId"
          ],
          "name": "reportTaskCompleted",
          "title": "Report Completed Task",
          "description": "Report task completed...",
          "input": "http://schemas.taskcluster.net/queue/v1/task-completed-request.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/task-completed-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/claim-work/<provisionerId>/<workerType>",
          "args": [
            "provisionerId",
            "workerType"
          ],
          "name": "claimWork",
          "title": "Claim work for a worker",
          "description": "Claim work for a worker, returns information about an appropriate task\nclaimed for the worker. Similar to `/v1/task/:taskId/claim`, which can be\nused to claim a specific task, or reclaim a specific task extending the\n`takenUntil` timeout for the run.\n\n**Note**, that if no tasks are _pending_ this method will not assign a\ntask to you. Instead it will return `204` with a timeout you should wait\nbefore polling the queue again. The response has the following form:\n`{sleep: <seconds to sleep>}`. To avoid this declare a RabbitMQ queue for\nyour `workerType` claim work using `/v1/task/:taskId/claim`.",
          "input": "http://schemas.taskcluster.net/queue/v1/claim-work-request.json#",
          "output": "http://schemas.taskcluster.net/queue/v1/claim-work-response.json#"
        },
        {
          "type": "function",
          "method": "post",
          "route": "/task/<taskId>/rerun",
          "args": [
            "taskId"
          ],
          "name": "rerunTask",
          "title": "Rerun a Resolved Task",
          "description": "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed.\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent, if you try to rerun a task that\nisn't either `failed` or `completed`, this operation will just return the\ncurrent task status.",
          "output": "http://schemas.taskcluster.net/queue/v1/task-rerun-response.json#"
        },
        {
          "type": "function",
          "method": "get",
          "route": "/pending-tasks/<provisionerId>",
          "args": [
            "provisionerId"
          ],
          "name": "getPendingTasks",
          "title": "Fetch pending tasks for provisioner",
          "description": "Documented later...\n\n**Warning** this api end-point is **not stable**."
        },
        {
          "type": "function",
          "method": "get",
          "route": "/settings/amqp-connection-string",
          "args": [],
          "name": "getAMQPConnectionString",
          "title": "Fetch AMQP Connection String",
          "description": "Most hosted AMQP services requires us to specify a virtual host, \nso hardcoding the AMQP connection string into various services would be \na bad solution. Hence, we offer all authorized queue consumers to fetch \nan AMQP connection string using the API end-point.\n\n**Warning**, this API end-point is not stable, and may change in the \nfuture the strategy of not hardcoding AMQP connection details into \nvarious components obviously makes sense. But as we have no method of \nnotifying consumers that the connection string have moved. This \napproach may not be optimal either. Thus, we may be choose to remove \nthis API end-point when `pulse.mozilla.org` is a stable AMQP service \nwe can rely on.",
          "output": "http://schemas.taskcluster.net/queue/v1/amqp-connection-string-response.json#"
        }
      ]
    }
  },
  "QueueEvents": {
    "referenceUrl": "http://references.taskcluster.net/queue/v1/exchanges.json",
    "reference": {
      "version": "0.2.0",
      "title": "Queue AMQP Exchanges",
      "description": "The queue, typically available at `queue.taskcluster.net`, is responsible\nfor accepting tasks and track their state as they are executed by\nworkers. In order ensure they are eventually resolved.\n\nThis document describes AMQP exchanges offered by the queue, which allows\nthird-party listeners to monitor tasks as they progress to resolution.\nThese exchanges targets the following audience:\n * Schedulers, who takes action after tasks are completed,\n * Workers, who wants to listen for new or canceled tasks (optional),\n * Tools, that wants to update their view as task progress.\n\nYou'll notice that all the exchanges in the document shares the same\nrouting key pattern. This makes it very easy to bind to all message about\na certain kind tasks. You should also note that the `routing` property\nof a task will be used in the routing key. This property is user-defined\nand may contain dots (ie. multiple routing words).\n\n**Remark**, if the task-graph scheduler, documented elsewhere, is used to\nscheduler a task-graph, then task submitted will have their `routing` key\nprefixed by `task-graph-scheduler.<taskGraphId>.` this means that the\nfirst two words of the task `routing` key will be\n`'task-graph-scheduler'` and `taskGraphId`. This is useful if you're\ninterested in updates about a specific task-graph, and it is necessary\nto know if you're binding to the `task.routing` key and submitting tasks\nthrough the task-graph scheduler. See documentation for task-graph\nscheduler for more details.",
      "exchangePrefix": "queue/v1/",
      "entries": [
        {
          "type": "topic-exchange",
          "exchange": "task-pending",
          "name": "taskPending",
          "title": "Task Pending Messages",
          "description": "When a task becomes `pending` a message is posted to this exchange.\n\nThis is useful for workers who doesn't want to constantly poll the queue\nfor new tasks. The queue will also be authority for task states and\nclaims. But using this exchange workers should be able to distribute work\nefficiently and they would be able to reduce their polling interval\nsignificantly without affecting general responsiveness.",
          "routingKey": [
            {
              "name": "taskId",
              "summary": "`taskId` for the task this message concerns",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "runId",
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 3
            },
            {
              "name": "workerGroup",
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "workerId",
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "provisionerId",
              "summary": "`provisionerId` this task is targeted at.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "workerType",
              "summary": "`workerType` this task must run on.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "routing",
              "summary": "task-specific routing key (`task.routing`).",
              "multipleWords": true,
              "required": true,
              "maxSize": 128
            }
          ],
          "schema": "http://schemas.taskcluster.net/queue/v1/task-pending-message.json#"
        },
        {
          "type": "topic-exchange",
          "exchange": "task-running",
          "name": "taskRunning",
          "title": "Task Running Messages",
          "description": "Whenever a task is claimed by a worker, a run is started on the worker,\nand a message is posted on this exchange.\n\n**Notice**, that the `logsUrl` may return `404` during the run, but by\nthe end of the run the `logsUrl` will be valid. But this may not have\nhappened when this message is posted.\n\nThe idea is that workers can choose to upload the `logs.json` file as the\nfirst thing they do, in which case it'll often be available after a few\nminutes. This is useful if the worker supports live logging.",
          "routingKey": [
            {
              "name": "taskId",
              "summary": "`taskId` for the task this message concerns",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "runId",
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 3
            },
            {
              "name": "workerGroup",
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "workerId",
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "provisionerId",
              "summary": "`provisionerId` this task is targeted at.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "workerType",
              "summary": "`workerType` this task must run on.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "routing",
              "summary": "task-specific routing key (`task.routing`).",
              "multipleWords": true,
              "required": true,
              "maxSize": 128
            }
          ],
          "schema": "http://schemas.taskcluster.net/queue/v1/task-running-message.json#"
        },
        {
          "type": "topic-exchange",
          "exchange": "task-completed",
          "name": "taskCompleted",
          "title": "Task Completed Messages",
          "description": "When a task is completed by a worker a message is posted this exchange.\nThis message is routed using the `run-id`, `worker-group` and `worker-id`\nthat completed the task. But information about additional runs is also\navailable from the task status structure.\n\nUpon task completion a result structure is made available, you'll find\nthe url in the `resultURL` property. See _task storage_ documentation for\ndetails on the format of the file available through `resultUrl`.",
          "routingKey": [
            {
              "name": "taskId",
              "summary": "`taskId` for the task this message concerns",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "runId",
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 3
            },
            {
              "name": "workerGroup",
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "workerId",
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "provisionerId",
              "summary": "`provisionerId` this task is targeted at.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "workerType",
              "summary": "`workerType` this task must run on.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "routing",
              "summary": "task-specific routing key (`task.routing`).",
              "multipleWords": true,
              "required": true,
              "maxSize": 128
            }
          ],
          "schema": "http://schemas.taskcluster.net/queue/v1/task-completed-message.json#"
        },
        {
          "type": "topic-exchange",
          "exchange": "task-failed",
          "name": "taskFailed",
          "title": "Task Failed Messages",
          "description": "Whenever a task is concluded to be failed a message is posted to this\nexchange. This happens if the task isn't completed before its `deadlìne`,\nall retries failed (i.e. workers stopped responding) or the task was\ncanceled by another entity.\n\nThe specific _reason_ is evident from that task status structure, refer\nto the `reason` property.",
          "routingKey": [
            {
              "name": "taskId",
              "summary": "`taskId` for the task this message concerns",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "runId",
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 3
            },
            {
              "name": "workerGroup",
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "workerId",
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task.",
              "multipleWords": false,
              "required": false,
              "maxSize": 22
            },
            {
              "name": "provisionerId",
              "summary": "`provisionerId` this task is targeted at.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "workerType",
              "summary": "`workerType` this task must run on.",
              "multipleWords": false,
              "required": true,
              "maxSize": 22
            },
            {
              "name": "routing",
              "summary": "task-specific routing key (`task.routing`).",
              "multipleWords": true,
              "required": true,
              "maxSize": 128
            }
          ],
          "schema": "http://schemas.taskcluster.net/queue/v1/task-failed-message.json#"
        }
      ]
    }
  }
}