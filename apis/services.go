package apis

// Code generated by fetch-apis; DO NOT EDIT

import "github.com/taskcluster/taskcluster-cli/apis/definitions"

var services = map[string]definitions.Service{
	"Auth": definitions.Service{
		BaseURL:     "https://auth.taskcluster.net/v1",
		Title:       "Authentication API",
		Description: "Authentication related API end-points for TaskCluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authenticate request signed with TaskCluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n\n### Clients\nThe authentication service manages _clients_, at a high-level each client\nconsists of a `clientId`, an `accessToken`, scopes, and some metadata.\nThe `clientId` and `accessToken` can be used for authentication when\ncalling TaskCluster APIs.\n\nThe client's scopes control the client's access to TaskCluster resources.\nThe scopes are *expanded* by substituting roles, as defined below.\n\n### Roles\nA _role_ consists of a `roleId`, a set of scopes and a description.\nEach role constitutes a simple _expansion rule_ that says if you have\nthe scope: `assume:<roleId>` you get the set of scopes the role has.\nThink of the `assume:<roleId>` as a scope that allows a client to assume\na role.\n\nAs in scopes the `*` kleene star also have special meaning if it is\nlocated at the end of a `roleId`. If you have a role with the following\n`roleId`: `my-prefix*`, then any client which has a scope staring with\n`assume:my-prefix` will be allowed to assume the role.\n\n### Guarded Services\nThe authentication service also has API end-points for delegating access\nto some guarded service such as AWS S3, or Azure Table Storage.\nGenerally, we add API end-points to this server when we wish to use\nTaskCluster credentials to grant access to a third-party service used\nby many TaskCluster components.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "listClients",
				Title:       "List Clients",
				Description: "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/",
				Args:        []string{},
				Query: []string{
					"prefix",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/list-clients-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "client",
				Title:       "Get Client",
				Description: "Get information about a single client.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/get-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createClient",
				Title:       "Create Client",
				Description: "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
				Scopes: [][]string{
					[]string{
						"auth:create-client:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/auth/v1/create-client-request.json#",
				Output: "http://schemas.taskcluster.net/auth/v1/create-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "resetAccessToken",
				Title:       "Reset `accessToken`",
				Description: "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
				Scopes: [][]string{
					[]string{
						"auth:reset-access-token:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/clients/<clientId>/reset",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/create-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "updateClient",
				Title:       "Update Client",
				Description: "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
				Scopes: [][]string{
					[]string{
						"auth:update-client:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/auth/v1/create-client-request.json#",
				Output: "http://schemas.taskcluster.net/auth/v1/get-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "enableClient",
				Title:       "Enable Client",
				Description: "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
				Scopes: [][]string{
					[]string{
						"auth:enable-client:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/clients/<clientId>/enable",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/get-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "disableClient",
				Title:       "Disable Client",
				Description: "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
				Scopes: [][]string{
					[]string{
						"auth:disable-client:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/clients/<clientId>/disable",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/get-client-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "deleteClient",
				Title:       "Delete Client",
				Description: "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
				Scopes: [][]string{
					[]string{
						"auth:delete-client:<clientId>",
					},
				},
				Stability: "stable",
				Method:    "delete",
				Route:     "/clients/<clientId>",
				Args: []string{
					"clientId",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listRoles",
				Title:       "List Roles",
				Description: "Get a list of all roles, each role object also includes the list of\nscopes it expands to.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/auth/v1/list-roles-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "role",
				Title:       "Get Role",
				Description: "Get information about a single role, including the set of scopes that the\nrole expands to.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/get-role-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createRole",
				Title:       "Create Role",
				Description: "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.",
				Scopes: [][]string{
					[]string{
						"auth:create-role:<roleId>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/auth/v1/create-role-request.json#",
				Output: "http://schemas.taskcluster.net/auth/v1/get-role-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "updateRole",
				Title:       "Update Role",
				Description: "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the client's existing scopes.",
				Scopes: [][]string{
					[]string{
						"auth:update-role:<roleId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/auth/v1/create-role-request.json#",
				Output: "http://schemas.taskcluster.net/auth/v1/get-role-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "deleteRole",
				Title:       "Delete Role",
				Description: "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
				Scopes: [][]string{
					[]string{
						"auth:delete-role:<roleId>",
					},
				},
				Stability: "stable",
				Method:    "delete",
				Route:     "/roles/<roleId>",
				Args: []string{
					"roleId",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "expandScopes",
				Title:       "Expand Scopes",
				Description: "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/scopes/expand",
				Args:        []string{},
				Query:       []string{},
				Input:       "http://schemas.taskcluster.net/auth/v1/scopeset.json#",
				Output:      "http://schemas.taskcluster.net/auth/v1/scopeset.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "currentScopes",
				Title:       "Get Current Scopes",
				Description: "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/scopes/current",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/auth/v1/scopeset.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "awsS3Credentials",
				Title:       "Get Temporary Read/Write Credentials S3",
				Description: "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets.  To add\na bucket to that whitelist, contact the TaskCluster team, who will add it to\nthe appropriate IAM policy.  If the bucket is in a different AWS account, you\nwill also need to add a bucket policy allowing access from the TaskCluster\naccount.  That policy should look like this:\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"allow-taskcluster-auth-to-delegate-access\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::692406183521:root\"\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\",\n        \"s3:GetBucketLocation\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::<bucket>\",\n        \"arn:aws:s3:::<bucket>/*\"\n      ]\n    }\n  ]\n}\n```\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
				Scopes: [][]string{
					[]string{
						"auth:aws-s3:<level>:<bucket>/<prefix>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/aws/s3/<level>/<bucket>/<prefix>",
				Args: []string{
					"level",
					"bucket",
					"prefix",
				},
				Query: []string{
					"format",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/aws-s3-credentials-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "azureTableSAS",
				Title:       "Get Shared-Access-Signature for Azure Table",
				Description: "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.  Note, this will create the table, if it doesn't\nalready exist.",
				Scopes: [][]string{
					[]string{
						"auth:azure-table-access:<account>/<table>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/azure/<account>/table/<table>/read-write",
				Args: []string{
					"account",
					"table",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/azure-table-access-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "sentryDSN",
				Title:       "Get DSN for Sentry Project",
				Description: "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
				Scopes: [][]string{
					[]string{
						"auth:sentry:<project>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/sentry/<project>/dsn",
				Args: []string{
					"project",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/sentry-dsn-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "statsumToken",
				Title:       "Get Token for Statsum Project",
				Description: "Get temporary `token` and `baseUrl` for sending metrics to statsum.\n\nThe token is valid for 24 hours, clients should refresh after expiration.",
				Scopes: [][]string{
					[]string{
						"auth:statsum:<project>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/statsum/<project>/token",
				Args: []string{
					"project",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/auth/v1/statsum-token-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "authenticateHawk",
				Title:       "Authenticate Hawk Request",
				Description: "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on TaskCluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "post",
				Route:       "/authenticate-hawk",
				Args:        []string{},
				Query:       []string{},
				Input:       "http://schemas.taskcluster.net/auth/v1/authenticate-hawk-request.json#",
				Output:      "http://schemas.taskcluster.net/auth/v1/authenticate-hawk-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "testAuthenticate",
				Title:       "Test Authentication",
				Description: "Utility method to test client implementations of TaskCluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "post",
				Route:       "/test-authenticate",
				Args:        []string{},
				Query:       []string{},
				Input:       "http://schemas.taskcluster.net/auth/v1/test-authenticate-request.json#",
				Output:      "http://schemas.taskcluster.net/auth/v1/test-authenticate-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "testAuthenticateGet",
				Title:       "Test Authentication (GET)",
				Description: "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the \n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/test-authenticate-get/",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/auth/v1/test-authenticate-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"AuthEvents": definitions.Service{
		BaseURL:     "",
		Title:       "Auth Pulse Exchanges",
		Description: "The auth service, typically available at `auth.taskcluster.net`\nis responsible for storing credentials, managing assignment of scopes,\nand validation of request signatures from other services.\n\nThese exchanges provides notifications when credentials or roles are\nupdated. This is mostly so that multiple instances of the auth service\ncan purge their caches and synchronize state. But you are of course\nwelcome to use these for other purposes, monitoring changes for example.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "clientCreated",
				Title:       "Client Created Messages",
				Description: "Message that a new client has been created.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "clientUpdated",
				Title:       "Client Updated Messages",
				Description: "Message that a new client has been updated.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "clientDeleted",
				Title:       "Client Deleted Messages",
				Description: "Message that a new client has been deleted.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "roleCreated",
				Title:       "Role Created Messages",
				Description: "Message that a new role has been created.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "roleUpdated",
				Title:       "Role Updated Messages",
				Description: "Message that a new role has been updated.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "roleDeleted",
				Title:       "Role Deleted Messages",
				Description: "Message that a new role has been deleted.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"AwsProvisioner": definitions.Service{
		BaseURL:     "https://aws-provisioner.taskcluster.net/v1",
		Title:       "AWS Provisioner API Documentation",
		Description: "The AWS Provisioner is responsible for provisioning instances on EC2 for use in\nTaskCluster.  The provisioner maintains a set of worker configurations which\ncan be managed with an API that is typically available at\naws-provisioner.taskcluster.net/v1.  This API can also perform basic instance\nmanagement tasks in addition to maintaining the internal state of worker type\nconfiguration information.\n\nThe Provisioner runs at a configurable interval.  Each iteration of the\nprovisioner fetches a current copy the state that the AWS EC2 api reports.  In\neach iteration, we ask the Queue how many tasks are pending for that worker\ntype.  Based on the number of tasks pending and the scaling ratio, we may\nsubmit requests for new instances.  We use pricing information, capacity and\nutility factor information to decide which instance type in which region would\nbe the optimal configuration.\n\nEach EC2 instance type will declare a capacity and utility factor.  Capacity is\nthe number of tasks that a given machine is capable of running concurrently.\nUtility factor is a relative measure of performance between two instance types.\nWe multiply the utility factor by the spot price to compare instance types and\nregions when making the bidding choices.\n\nWhen a new EC2 instance is instantiated, its user data contains a token in\n`securityToken` that can be used with the `getSecret` method to retrieve\nthe worker's credentials and any needed passwords or other restricted\ninformation.  The worker is responsible for deleting the secret after\nretrieving it, to prevent dissemination of the secret to other proceses\nwhich can read the instance user data.\n",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "listWorkerTypeSummaries",
				Title:       "List worker types with details",
				Description: "Return a list of worker types, including some summary information about\ncurrent capacity for each.  While this list includes all defined worker types,\nthere may be running EC2 instances for deleted worker types that are not\nincluded here.  The list is unordered.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/list-worker-type-summaries",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-summaries-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createWorkerType",
				Title:       "Create new Worker Type",
				Description: "Create a worker type.  A worker type contains all the configuration\nneeded for the provisioner to manage the instances.  Each worker type\nknows which regions and which instance types are allowed for that\nworker type.  Remember that Capacity is the number of concurrent tasks\nthat can be run on a given EC2 resource and that Utility is the relative\nperformance rate between different instance types.  There is no way to\nconfigure different regions to have different sets of instance types\nso ensure that all instance types are available in all regions.\nThis function is idempotent.\n\nOnce a worker type is in the provisioner, a back ground process will\nbegin creating instances for it based on its capacity bounds and its\npending task count from the Queue.  It is the worker's responsibility\nto shut itself down.  The provisioner has a limit (currently 96hours)\nfor all instances to prevent zombie instances from running indefinitely.\n\nThe provisioner will ensure that all instances created are tagged with\naws resource tags containing the provisioner id and the worker type.\n\nIf provided, the secrets in the global, region and instance type sections\nare available using the secrets api.  If specified, the scopes provided\nwill be used to generate a set of temporary credentials available with\nthe other secrets.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/worker-type/<workerType>",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/aws-provisioner/v1/create-worker-type-request.json#",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "updateWorkerType",
				Title:       "Update Worker Type",
				Description: "Provide a new copy of a worker type to replace the existing one.\nThis will overwrite the existing worker type definition if there\nis already a worker type of that name.  This method will return a\n200 response along with a copy of the worker type definition created\nNote that if you are using the result of a GET on the worker-type\nend point that you will need to delete the lastModified and workerType\nkeys from the object returned, since those fields are not allowed\nthe request body for this method\n\nOtherwise, all input requirements and actions are the same as the\ncreate method.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/worker-type/<workerType>/update",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/aws-provisioner/v1/create-worker-type-request.json#",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "workerTypeLastModified",
				Title:       "Get Worker Type Last Modified Time",
				Description: "This method is provided to allow workers to see when they were\nlast modified.  The value provided through UserData can be\ncompared against this value to see if changes have been made\nIf the worker type definition has not been changed, the date\nshould be identical as it is the same stored value.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/worker-type-last-modified/<workerType>",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-last-modified.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "workerType",
				Title:       "Get Worker Type",
				Description: "Retreive a copy of the requested worker type definition.\nThis copy contains a lastModified field as well as the worker\ntype name.  As such, it will require manipulation to be able to\nuse the results of this method to submit date to the update\nmethod.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:view-worker-type:<workerType>",
					},
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/worker-type/<workerType>",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "removeWorkerType",
				Title:       "Delete Worker Type",
				Description: "Delete a worker type definition.  This method will only delete\nthe worker type definition from the storage table.  The actual\ndeletion will be handled by a background worker.  As soon as this\nmethod is called for a worker type, the background worker will\nimmediately submit requests to cancel all spot requests for this\nworker type as well as killing all instances regardless of their\nstate.  If you want to gracefully remove a worker type, you must\neither ensure that no tasks are created with that worker type name\nor you could theoretically set maxCapacity to 0, though, this is\nnot a supported or tested action",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "stable",
				Method:    "delete",
				Route:     "/worker-type/<workerType>",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listWorkerTypes",
				Title:       "List Worker Types",
				Description: "Return a list of string worker type names.  These are the names\nof all managed worker types known to the provisioner.  This does\nnot include worker types which are left overs from a deleted worker\ntype definition but are still running in AWS.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/list-worker-types",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createAmiSet",
				Title:       "Create new AMI Set",
				Description: "Create an AMI Set. An AMI Set is a collection of AMIs with a single name.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-ami-set:<amiSetId>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/ami-set/<id>",
				Args: []string{
					"id",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/aws-provisioner/v1/create-ami-set-request.json#",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "amiSet",
				Title:       "Get AMI Set",
				Description: "Retreive a copy of the requested AMI set.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ami-set/<id>",
				Args: []string{
					"id",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-ami-set-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "updateAmiSet",
				Title:       "Update AMI Set",
				Description: "Provide a new copy of an AMI Set to replace the existing one.\nThis will overwrite the existing AMI Set if there\nis already an AMI Set of that name. This method will return a\n200 response along with a copy of the AMI Set created.\nNote that if you are using the result of a GET on the ami-set\nend point that you will need to delete the lastModified and amiSet\nkeys from the object returned, since those fields are not allowed\nthe request body for this method.\n\nOtherwise, all input requirements and actions are the same as the\ncreate method.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-ami-set:<amiSetId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/ami-set/<id>/update",
				Args: []string{
					"id",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/aws-provisioner/v1/create-ami-set-request.json#",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-ami-set-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listAmiSets",
				Title:       "List AMI sets",
				Description: "Return a list of AMI sets names.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/list-ami-sets",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/aws-provisioner/v1/list-ami-sets-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "removeAmiSet",
				Title:       "Delete AMI Set",
				Description: "Delete an AMI Set.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:manage-ami-set:<amiSetId>",
					},
				},
				Stability: "stable",
				Method:    "delete",
				Route:     "/ami-set/<id>",
				Args: []string{
					"id",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createSecret",
				Title:       "Create new Secret",
				Description: "Insert a secret into the secret storage.  The supplied secrets will\nbe provided verbatime via `getSecret`, while the supplied scopes will\nbe converted into credentials by `getSecret`.\n\nThis method is not ordinarily used in production; instead, the provisioner\ncreates a new secret directly for each spot bid.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:create-secret",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/secret/<token>",
				Args: []string{
					"token",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/aws-provisioner/v1/create-secret-request.json#",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getSecret",
				Title:       "Get a Secret",
				Description: "Retrieve a secret from storage.  The result contains any passwords or\nother restricted information verbatim as well as a temporary credential\nbased on the scopes specified when the secret was created.\n\nIt is important that this secret is deleted by the consumer (`removeSecret`),\nor else the secrets will be visible to any process which can access the\nuser data associated with the instance.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/secret/<token>",
				Args: []string{
					"token",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-secret-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "instanceStarted",
				Title:       "Report an instance starting",
				Description: "An instance will report in by giving its instance id as well\nas its security token.  The token is given and checked to ensure\nthat it matches a real token that exists to ensure that random\nmachines do not check in.  We could generate a different token\nbut that seems like overkill",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/instance-started/<instanceId>/<token>",
				Args: []string{
					"instanceId",
					"token",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "removeSecret",
				Title:       "Remove a Secret",
				Description: "Remove a secret.  After this call, a call to `getSecret` with the given\ntoken will return no information.\n\nIt is very important that the consumer of a \nsecret delete the secret from storage before handing over control\nto untrusted processes to prevent credential and/or secret leakage.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "delete",
				Route:       "/secret/<token>",
				Args: []string{
					"token",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getLaunchSpecs",
				Title:       "Get All Launch Specifications for WorkerType",
				Description: "This method returns a preview of all possible launch specifications\nthat this worker type definition could submit to EC2.  It is used to\ntest worker types, nothing more\n\n**This API end-point is experimental and may be subject to change without warning.**",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:view-worker-type:<workerType>",
					},
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "experimental",
				Method:    "get",
				Route:     "/worker-type/<workerType>/launch-specifications",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/aws-provisioner/v1/get-launch-specs-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "state",
				Title:       "Get AWS State for a worker type",
				Description: "Return the state of a given workertype as stored by the provisioner. \nThis state is stored as three lists: 1 for running instances, 1 for\npending requests.  The `summary` property contains an updated summary\nsimilar to that returned from `listWorkerTypeSummaries`.",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:view-worker-type:<workerType>",
					},
					[]string{
						"aws-provisioner:manage-worker-type:<workerType>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/state/<workerType>",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Documented later...\n\n**Warning** this api end-point is **not stable**.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "backendStatus",
				Title:       "Backend Status",
				Description: "This endpoint is used to show when the last time the provisioner\nhas checked in.  A check in is done through the deadman's snitch\napi.  It is done at the conclusion of a provisioning iteration\nand used to tell if the background provisioning process is still\nrunning.\n\n**Warning** this api end-point is **not stable**.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/backend-status",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/aws-provisioner/v1/backend-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "terminateAllInstancesOfWorkerType",
				Title:       "Shutdown Every Ec2 Instance of this Worker Type",
				Description: "WARNING: YOU ALMOST CERTAINLY DO NOT WANT TO USE THIS \nShut down every single EC2 instance associated with this workerType. \nThis means every single last one.  You probably don't want to use \nthis method, which is why it has an obnoxious name.  Don't even try \nto claim you didn't know what this method does!\n\n**This API end-point is experimental and may be subject to change without warning.**",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:terminate-all-worker-type:<workerType>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/worker-type/<workerType>/terminate-all-instances",
				Args: []string{
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "shutdownEverySingleEc2InstanceManagedByThisProvisioner",
				Title:       "Shutdown Every Single Ec2 Instance Managed By This Provisioner",
				Description: "WARNING: YOU ALMOST CERTAINLY DO NOT WANT TO USE THIS \nShut down every single EC2 instance managed by this provisioner. \nThis means every single last one.  You probably don't want to use \nthis method, which is why it has an obnoxious name.  Don't even try \nto claim you didn't know what this method does!\n\n**This API end-point is experimental and may be subject to change without warning.**",
				Scopes: [][]string{
					[]string{
						"aws-provisioner:terminate-all-worker-type:*",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/shutdown/every/single/ec2/instance/managed/by/this/provisioner",
				Args:      []string{},
				Query:     []string{},
				Input:     "",
				Output:    "",
			},
		},
	},
	"AwsProvisionerEvents": definitions.Service{
		BaseURL:     "",
		Title:       "AWS Provisioner Pulse Exchanges",
		Description: "Exchanges from the provisioner... more docs later",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "workerTypeCreated",
				Title:       "WorkerType Created Message",
				Description: "When a new `workerType` is created a message will be published to this\nexchange.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "workerTypeUpdated",
				Title:       "WorkerType Updated Message",
				Description: "When a `workerType` is updated a message will be published to this\nexchange.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "workerTypeRemoved",
				Title:       "WorkerType Removed Message",
				Description: "When a `workerType` is removed a message will be published to this\nexchange.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"Github": definitions.Service{
		BaseURL:     "https://github.taskcluster.net/v1",
		Title:       "TaskCluster GitHub API Documentation",
		Description: "The github service, typically available at\n`github.taskcluster.net`, is responsible for publishing pulse\nmessages in response to GitHub events.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "githubWebHookConsumer",
				Title:       "Consume GitHub WebHook",
				Description: "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease or pull request.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "post",
				Route:       "/github",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "builds",
				Title:       "List of Builds",
				Description: "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/builds",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
					"organization",
					"repository",
					"sha",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/github/v1/build-list.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"GithubEvents": definitions.Service{
		BaseURL:     "",
		Title:       "TaskCluster-Github Exchanges",
		Description: "The github service, typically available at\n`github.taskcluster.net`, is responsible for publishing a pulse\nmessage for supported github events.\n\nThis document describes the exchange offered by the taskcluster\ngithub service",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "pullRequest",
				Title:       "GitHub Pull Request Event",
				Description: "When a GitHub pull request event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "push",
				Title:       "GitHub push Event",
				Description: "When a GitHub push event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "release",
				Title:       "GitHub release Event",
				Description: "When a GitHub release event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"Hooks": definitions.Service{
		BaseURL:     "https://hooks.taskcluster.net/v1",
		Title:       "Hooks API Documentation",
		Description: "Hooks are a mechanism for creating tasks in response to events.\n\nHooks are identified with a `hookGroupId` and a `hookId`.\n\nWhen an event occurs, the resulting task is automatically created.  The\ntask is created using the scope `assume:hook-id:<hookGroupId>/<hookId>`,\nwhich must have scopes to make the createTask call, including satisfying all\nscopes in `task.scopes`.  The new task has a `taskGroupId` equal to its\n`taskId`, as is the convention for decision tasks.\n\nHooks can have a \"schedule\" indicating specific times that new tasks should\nbe created.  Each schedule is in a simple cron format, per \nhttps://www.npmjs.com/package/cron-parser.  For example:\n * `['0 0 1 * * *']` -- daily at 1:00 UTC\n * `['0 0 9,21 * * 1-5', '0 0 12 * * 0,6']` -- weekdays at 9:00 and 21:00 UTC, weekends at noon",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "listHookGroups",
				Title:       "List hook groups",
				Description: "This endpoint will return a list of all hook groups with at least one hook.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/hooks",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/hooks/v1/list-hook-groups-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listHooks",
				Title:       "List hooks in a given group",
				Description: "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>",
				Args: []string{
					"hookGroupId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/list-hooks-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "hook",
				Title:       "Get hook definition",
				Description: "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/hook-definition.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getHookStatus",
				Title:       "Get hook status",
				Description: "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/status",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/hook-status.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getHookSchedule",
				Title:       "Get hook schedule",
				Description: "This endpoint will return the schedule and next scheduled creation time\nfor the given hook.",
				Scopes:      [][]string(nil),
				Stability:   "deprecated",
				Method:      "get",
				Route:       "/hooks/<hookGroupId>/<hookId>/schedule",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/hook-schedule.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createHook",
				Title:       "Create a hook",
				Description: "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.\n",
				Scopes: [][]string{
					[]string{
						"hooks:modify-hook:<hookGroupId>/<hookId>",
						"assume:hook-id:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "put",
				Route:     "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/hooks/v1/create-hook-request.json",
				Output: "http://schemas.taskcluster.net/hooks/v1/hook-definition.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "updateHook",
				Title:       "Update a hook",
				Description: "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
				Scopes: [][]string{
					[]string{
						"hooks:modify-hook:<hookGroupId>/<hookId>",
						"assume:hook-id:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/hooks/v1/create-hook-request.json",
				Output: "http://schemas.taskcluster.net/hooks/v1/hook-definition.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "removeHook",
				Title:       "Delete a hook",
				Description: "This endpoint will remove a hook definition.",
				Scopes: [][]string{
					[]string{
						"hooks:modify-hook:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "delete",
				Route:     "/hooks/<hookGroupId>/<hookId>",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "triggerHook",
				Title:       "Trigger a hook",
				Description: "This endpoint will trigger the creation of a task from a hook definition.",
				Scopes: [][]string{
					[]string{
						"hooks:trigger-hook:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/hooks/<hookGroupId>/<hookId>/trigger",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/hooks/v1/trigger-payload.json",
				Output: "http://schemas.taskcluster.net/hooks/v1/task-status.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getTriggerToken",
				Title:       "Get a trigger token",
				Description: "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
				Scopes: [][]string{
					[]string{
						"hooks:get-trigger-token:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "get",
				Route:     "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/trigger-token-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "resetTriggerToken",
				Title:       "Reset a trigger token",
				Description: "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
				Scopes: [][]string{
					[]string{
						"hooks:reset-trigger-token:<hookGroupId>/<hookId>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/hooks/<hookGroupId>/<hookId>/token",
				Args: []string{
					"hookGroupId",
					"hookId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/hooks/v1/trigger-token-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "triggerHookWithToken",
				Title:       "Trigger a hook with a token",
				Description: "This endpoint triggers a defined hook with a valid token.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "post",
				Route:       "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
				Args: []string{
					"hookGroupId",
					"hookId",
					"token",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/hooks/v1/trigger-payload.json",
				Output: "http://schemas.taskcluster.net/hooks/v1/task-status.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"Index": definitions.Service{
		BaseURL:     "https://index.taskcluster.net/v1",
		Title:       "Task Index API Documentation",
		Description: "The task index, typically available at `index.taskcluster.net`, is\nresponsible for indexing tasks. In order to ensure that tasks can be\nlocated by recency and/or arbitrary strings. Common use-cases includes\n\n * Locate tasks by git or mercurial `<revision>`, or\n * Locate latest task from given `<branch>`, such as a release.\n\n**Index hierarchy**, tasks are indexed in a dot `.` separated hierarchy\ncalled a namespace. For example a task could be indexed in\n`<revision>.linux-64.release-build`. In this case the following\nnamespaces is created.\n\n 1. `<revision>`, and,\n 2. `<revision>.linux-64`\n\nThe inside the namespace `<revision>` you can find the namespace\n`<revision>.linux-64` inside which you can find the indexed task\n`<revision>.linux-64.release-build`. In this example you'll be able to\nfind build for a given revision.\n\n**Task Rank**, when a task is indexed, it is assigned a `rank` (defaults\nto `0`). If another task is already indexed in the same namespace with\nthe same lower or equal `rank`, the task will be overwritten. For example\nconsider a task indexed as `mozilla-central.linux-64.release-build`, in\nthis case on might choose to use a unix timestamp or mercurial revision\nnumber as `rank`. This way the latest completed linux 64 bit release\nbuild is always available at `mozilla-central.linux-64.release-build`.\n\n**Indexed Data**, when a task is located in the index you will get the\n`taskId` and an additional user-defined JSON blob that was indexed with\ntask. You can use this to store additional information you would like to\nget additional from the index.\n\n**Entry Expiration**, all indexed entries must have an expiration date.\nTypically this defaults to one year, if not specified. If you are\nindexing tasks to make it easy to find artifacts, consider using the\nexpiration date that the artifacts is assigned.\n\n**Valid Characters**, all keys in a namespace `<key1>.<key2>` must be\nin the form `/[a-zA-Z0-9_!~*'()%-]+/`. Observe that this is URL-safe and\nthat if you strictly want to put another character you can URL encode it.\n\n**Indexing Routes**, tasks can be indexed using the API below, but the\nmost common way to index tasks is adding a custom route on the following\nform `index.<namespace>`. In-order to add this route to a task you'll\nneed the following scope `queue:route:index.<namespace>`. When a task has\nthis route, it'll be indexed when the task is **completed successfully**.\nThe task will be indexed with `rank`, `data` and `expires` as specified\nin `task.extra.index`, see example below:\n\n```js\n{\n  payload:  { /* ... */ },\n  routes: [\n    // index.<namespace> prefixed routes, tasks CC'ed such a route will\n    // be indexed under the given <namespace>\n    \"index.mozilla-central.linux-64.release-build\",\n    \"index.<revision>.linux-64.release-build\"\n  ],\n  extra: {\n    // Optional details for indexing service\n    index: {\n      // Ordering, this taskId will overwrite any thing that has\n      // rank <= 4000 (defaults to zero)\n      rank:       4000,\n\n      // Specify when the entries expires (Defaults to 1 year)\n      expires:          new Date().toJSON(),\n\n      // A little informal data to store along with taskId\n      // (less 16 kb when encoded as JSON)\n      data: {\n        hgRevision:   \"...\",\n        commitMessae: \"...\",\n        whatever...\n      }\n    },\n    // Extra properties for other services...\n  }\n  // Other task properties...\n}\n```\n\n**Remark**, when indexing tasks using custom routes, it's also possible\nto listen for messages about these tasks. Which is quite convenient, for\nexample one could bind to `route.index.mozilla-central.*.release-build`,\nand pick up all messages about release builds. Hence, it is a\ngood idea to document task index hierarchies, as these make up extension\npoints in their own.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "findTask",
				Title:       "Find Indexed Task",
				Description: "Find task by namespace, if no task existing for the given namespace, this\nAPI end-point respond `404`.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/index/v1/indexed-task-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listNamespaces",
				Title:       "List Namespaces",
				Description: "List the namespaces immediately under a given namespace. This end-point\nlist up to 1000 namespaces. If more namespaces are present a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "post",
				Route:       "/namespaces/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/index/v1/list-namespaces-request.json#",
				Output: "http://schemas.taskcluster.net/index/v1/list-namespaces-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listTasks",
				Title:       "List Tasks",
				Description: "List the tasks immediately under a given namespace. This end-point\nlist up to 1000 tasks. If more tasks are present a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "post",
				Route:       "/tasks/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/index/v1/list-tasks-request.json#",
				Output: "http://schemas.taskcluster.net/index/v1/list-tasks-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "insertTask",
				Title:       "Insert Task into Index",
				Description: "Insert a task into the index. Please see the introduction above, for how\nto index successfully completed tasks automatically, using custom routes.",
				Scopes: [][]string{
					[]string{
						"index:insert-task:<namespace>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/task/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/index/v1/insert-task-request.json#",
				Output: "http://schemas.taskcluster.net/index/v1/indexed-task-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "findArtifactFromTask",
				Title:       "Get Artifact From Indexed Task",
				Description: "Find task by namespace and redirect to artifact with given `name`,\nif no task existing for the given namespace, this API end-point respond\n`404`.",
				Scopes: [][]string{
					[]string{
						"queue:get-artifact:<name>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/task/<namespace>/artifacts/<name>",
				Args: []string{
					"namespace",
					"name",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"Login": definitions.Service{
		BaseURL:     "https://login.taskcluster.net/v1",
		Title:       "Login API",
		Description: "The Login service serves as the interface between external authentication\nsystems and TaskCluster credentials.  It acts as the server side of\nhttps://tools.taskcluster.net.  If you are working on federating logins\nwith TaskCluster, this is probably *not* the service you are looking for.\nInstead, use the federated login support in the tools site.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "credentialsFromPersonaAssertion",
				Title:       "Get TaskCluster credentials given a Persona assertion",
				Description: "Given an [assertion](https://developer.mozilla.org/en-US/Persona/Quick_setup), return an appropriate set of temporary credentials.\n\nThe supplied audience must be on a whitelist of TaskCluster-related\nsites configured in the login service.  This is not a general-purpose\nassertion-verification service!",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "post",
				Route:       "/persona",
				Args:        []string{},
				Query:       []string{},
				Input:       "http://schemas.taskcluster.net/login/v1/persona-request.json",
				Output:      "http://schemas.taskcluster.net/login/v1/credentials-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"Notify": definitions.Service{
		BaseURL:     "https://notify.taskcluster.net/v1",
		Title:       "Notification Service",
		Description: "The notification service, typically available at `notify.taskcluster.net`\nlistens for tasks with associated notifications and handles requests to\nsend emails and post pulse messages.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "email",
				Title:       "Send an Email",
				Description: "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
				Scopes: [][]string{
					[]string{
						"notify:email:<address>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/email",
				Args:      []string{},
				Query:     []string{},
				Input:     "http://schemas.taskcluster.net/notify/v1/email-request.json",
				Output:    "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "pulse",
				Title:       "Publish a Pulse Message",
				Description: "Publish a message on pulse with the given `routingKey`.",
				Scopes: [][]string{
					[]string{
						"notify:pulse:<routingKey>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/pulse",
				Args:      []string{},
				Query:     []string{},
				Input:     "http://schemas.taskcluster.net/notify/v1/pulse-request.json",
				Output:    "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "irc",
				Title:       "Post IRC Message",
				Description: "Post a message on IRC to a specific channel or user, or a specific user\non a specific channel.\n\nSuccess of this API method does not imply the message was successfully\nposted. This API method merely inserts the IRC message into a queue\nthat will be processed by a background process.\nThis allows us to re-send the message in face of connection issues.\n\nHowever, if the user isn't online the message will be dropped without\nerror. We maybe improve this behavior in the future. For now just keep\nin mind that IRC is a best-effort service.",
				Scopes: [][]string{
					[]string{
						"notify:irc-channel:<channel>",
						"notify:irc-user:<user>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/irc",
				Args:      []string{},
				Query:     []string{},
				Input:     "http://schemas.taskcluster.net/notify/v1/irc-request.json",
				Output:    "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"Pulse": definitions.Service{
		BaseURL:     "https://pulse.taskcluster.net/v1",
		Title:       "Pulse Management Service",
		Description: "The taskcluster-pulse service, typically available at `pulse.taskcluster.net`\nmanages pulse credentials for taskcluster users.\n\nA service to manage Pulse credentials for anything using\nTaskcluster credentials. This allows us self-service and\ngreater control within the Taskcluster project.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "overview",
				Title:       "Rabbit Overview",
				Description: "An overview of the Rabbit cluster",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/overview",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/pulse/v1/rabbit-overview.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "exchanges",
				Title:       "Rabbit Exchanges",
				Description: "A list of exchanges in the rabbit cluster",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/exchanges",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/pulse/v1/exchanges-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createNamespace",
				Title:       "Create a namespace",
				Description: "Creates a namespace, given the taskcluster credentials with scopes.",
				Scopes: [][]string{
					[]string{
						"pulse:namespace:<namespace>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/namespace/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/pulse/v1/namespace-request.json",
				Output: "http://schemas.taskcluster.net/pulse/v1/namespace-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "namespace",
				Title:       "Get namespace information",
				Description: "Gets a namespace, given the taskcluster credentials with scopes.",
				Scopes: [][]string{
					[]string{
						"pulse:namespace:<namespace>",
					},
				},
				Stability: "experimental",
				Method:    "get",
				Route:     "/namespace/<namespace>",
				Args: []string{
					"namespace",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"PurgeCache": definitions.Service{
		BaseURL:     "https://purge-cache.taskcluster.net/v1",
		Title:       "Purge Cache API Documentation",
		Description: "The purge-cache service, typically available at\n`purge-cache.taskcluster.net`, is responsible for publishing a pulse\nmessage for workers, so they can purge cache upon request.\n\nThis document describes the API end-point for publishing the pulse\nmessage. This is mainly intended to be used by tools.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "purgeCache",
				Title:       "Purge Worker Cache",
				Description: "Publish a purge-cache message to purge caches named `cacheName` with\n`provisionerId` and `workerType` in the routing-key. Workers should\nbe listening for this message and purge caches when they see it.",
				Scopes: [][]string{
					[]string{
						"purge-cache:<provisionerId>/<workerType>:<cacheName>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/purge-cache/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request.json#",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "allPurgeRequests",
				Title:       "All Open Purge Requests",
				Description: "This is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/purge-cache/list",
				Args:        []string{},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/purge-cache/v1/all-purge-cache-request-list.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "purgeRequests",
				Title:       "Open Purge Requests for a provisionerId/workerType pair",
				Description: "List of caches that need to be purged if they are from before\na certain time. This is safe to be used in automation from\nworkers.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/purge-cache/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query: []string{
					"since",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request-list.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"PurgeCacheEvents": definitions.Service{
		BaseURL:     "",
		Title:       "Purge-Cache Exchanges",
		Description: "The purge-cache service, typically available at\n`purge-cache.taskcluster.net`, is responsible for publishing a pulse\nmessage for workers, so they can purge cache upon request.\n\nThis document describes the exchange offered for workers by the\ncache-purge service.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "purgeCache",
				Title:       "Purge Cache Messages",
				Description: "When a cache purge is requested  a message will be posted on this\nexchange with designated `provisionerId` and `workerType` in the\nrouting-key and the name of the `cacheFolder` as payload",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"Queue": definitions.Service{
		BaseURL:     "https://queue.taskcluster.net/v1",
		Title:       "Queue API Documentation",
		Description: "The queue, typically available at `queue.taskcluster.net`, is responsible\nfor accepting tasks and track their state as they are executed by\nworkers. In order ensure they are eventually resolved.\n\nThis document describes the API end-points offered by the queue. These \nend-points targets the following audience:\n * Schedulers, who create tasks to be executed,\n * Workers, who execute tasks, and\n * Tools, that wants to inspect the state of a task.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "task",
				Title:       "Get Task Definition",
				Description: "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "status",
				Title:       "Get task status",
				Description: "Get task status structure from `taskId`",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/status",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listTaskGroup",
				Title:       "List Task Group",
				Description: "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/task-group/<taskGroupId>/list",
				Args: []string{
					"taskGroupId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/list-task-group-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listDependentTasks",
				Title:       "List Dependent Tasks",
				Description: "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/task/<taskId>/dependents",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/list-dependent-tasks-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createTask",
				Title:       "Create New Task",
				Description: "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline**, the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**, the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice, that artifacts created by task must expire before the task.\n\n**Task specific routing-keys**, using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific \nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key: \n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**, any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Important** Any scopes the task requires are also required for creating\nthe task. Please see the Request Payload (Task Definition) for details.",
				Scopes: [][]string{
					[]string{
						"queue:create-task:<provisionerId>/<workerType>",
					},
					[]string{
						"queue:define-task:<provisionerId>/<workerType>",
						"queue:task-group-id:<schedulerId>/<taskGroupId>",
						"queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/task/<taskId>",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/create-task-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "defineTask",
				Title:       "Define Task",
				Description: "**Deprecated**, this is the same as `createTask` with a **self-dependency**.\nThis is only present for legacy.",
				Scopes: [][]string{
					[]string{
						"queue:define-task:<provisionerId>/<workerType>",
					},
					[]string{
						"queue:create-task:<provisionerId>/<workerType>",
					},
					[]string{
						"queue:define-task:<provisionerId>/<workerType>",
						"queue:task-group-id:<schedulerId>/<taskGroupId>",
					},
				},
				Stability: "deprecated",
				Method:    "post",
				Route:     "/task/<taskId>/define",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/create-task-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "scheduleTask",
				Title:       "Schedule Defined Task",
				Description: "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
				Scopes: [][]string{
					[]string{
						"queue:schedule-task",
						"assume:scheduler-id:<schedulerId>/<taskGroupId>",
					},
					[]string{
						"queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/schedule",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "rerunTask",
				Title:       "Rerun a Resolved Task",
				Description: "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed.\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent, if you try to rerun a task that\nis not either `failed` or `completed`, this operation will just return\nthe current task status.",
				Scopes: [][]string{
					[]string{
						"queue:rerun-task",
						"assume:scheduler-id:<schedulerId>/<taskGroupId>",
					},
					[]string{
						"queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>",
					},
				},
				Stability: "deprecated",
				Method:    "post",
				Route:     "/task/<taskId>/rerun",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "cancelTask",
				Title:       "Cancel Task",
				Description: "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
				Scopes: [][]string{
					[]string{
						"queue:cancel-task",
						"assume:scheduler-id:<schedulerId>/<taskGroupId>",
					},
					[]string{
						"queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/cancel",
				Args: []string{
					"taskId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "pollTaskUrls",
				Title:       "Get Urls to Poll Pending Tasks",
				Description: "Get a signed URLs to get and delete messages from azure queue.\nOnce messages are polled from here, you can claim the referenced task\nwith `claimTask`, and afterwards you should always delete the message.",
				Scopes: [][]string{
					[]string{
						"queue:poll-task-urls",
						"assume:worker-type:<provisionerId>/<workerType>",
					},
					[]string{
						"queue:poll-task-urls:<provisionerId>/<workerType>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/poll-task-url/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/poll-task-urls-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "claimWork",
				Title:       "Claim Work",
				Description: "Claim any task, more to be added later... long polling up to 20s.",
				Scopes: [][]string{
					[]string{
						"queue:claim-work:<provisionerId>/<workerType>",
						"queue:worker-id:<workerGroup>/<workerId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/claim-work/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/claim-work-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/claim-work-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "claimTask",
				Title:       "Claim Task",
				Description: "claim a task, more to be added later...",
				Scopes: [][]string{
					[]string{
						"queue:claim-task",
						"assume:worker-type:<provisionerId>/<workerType>",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:claim-task:<provisionerId>/<workerType>",
						"queue:worker-id:<workerGroup>/<workerId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/claim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/task-claim-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/task-claim-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "reclaimTask",
				Title:       "Reclaim task",
				Description: "reclaim a task more to be added later...",
				Scopes: [][]string{
					[]string{
						"queue:claim-task",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:reclaim-task:<taskId>/<runId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/reclaim",
				Args: []string{
					"taskId",
					"runId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-reclaim-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "reportCompleted",
				Title:       "Report Run Completed",
				Description: "Report a task completed, resolving the run as `completed`.",
				Scopes: [][]string{
					[]string{
						"queue:resolve-task",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:resolve-task:<taskId>/<runId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/completed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "reportFailed",
				Title:       "Report Run Failed",
				Description: "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
				Scopes: [][]string{
					[]string{
						"queue:resolve-task",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:resolve-task:<taskId>/<runId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/failed",
				Args: []string{
					"taskId",
					"runId",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "reportException",
				Title:       "Report Task Exception",
				Description: "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
				Scopes: [][]string{
					[]string{
						"queue:resolve-task",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:resolve-task:<taskId>/<runId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/exception",
				Args: []string{
					"taskId",
					"runId",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/task-exception-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/task-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "createArtifact",
				Title:       "Create Artifact",
				Description: "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they `expires`, the queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This features makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.\n\nWe currently support 4 different `storageType`s, each storage type have\nslightly different features and in some cases difference semantics.\n\n**S3 artifacts**, is useful for static files which will be stored on S3.\nWhen creating an S3 artifact the queue will return a pre-signed URL\nto which you can do a `PUT` request to upload your artifact. Note\nthat `PUT` request **must** specify the `content-length` header and\n**must** give the `content-type` header the same value as in the request\nto `createArtifact`.\n\n**Azure artifacts**, are stored in _Azure Blob Storage_ service, which\ngiven the consistency guarantees and API interface offered by Azure is\nmore suitable for artifacts that will be modified during the execution\nof the task. For example docker-worker has a feature that persists the\ntask log to Azure Blob Storage every few seconds creating a somewhat\nlive log. A request to create an Azure artifact will return a URL\nfeaturing a [Shared-Access-Signature](http://msdn.microsoft.com/en-us/library/azure/dn140256.aspx),\nrefer to MSDN for further information on how to use these.\n**Warning: azure artifact is currently an experimental feature subject\nto changes and data-drops.**\n\n**Reference artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts really only have a `url` property and\nwhen the artifact is requested the client will be redirect the URL\nprovided with a `303` (See Other) redirect. Please note that we cannot\ndelete artifacts you upload to other service, we can only delete the\nreference to the artifact, when it expires.\n\n**Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `403` (Forbidden) response. This is mainly designed to ensure that\ndependent tasks can distinguish between artifacts that were suppose to\nbe generated and artifacts for which the name is misspelled.\n\n**Artifact immutability**, generally speaking you cannot overwrite an\nartifact when created. But if you repeat the request with the same\nproperties the request will succeed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nAs a special case the `url` property on _reference artifacts_ can be\nupdated. You should only use this to update the `url` property for\nreference artifacts your process has created.",
				Scopes: [][]string{
					[]string{
						"queue:create-artifact:<name>",
						"assume:worker-id:<workerGroup>/<workerId>",
					},
					[]string{
						"queue:create-artifact:<taskId>/<runId>",
					},
				},
				Stability: "stable",
				Method:    "post",
				Route:     "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/queue/v1/post-artifact-request.json#",
				Output: "http://schemas.taskcluster.net/queue/v1/post-artifact-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getArtifact",
				Title:       "Get Artifact from Run",
				Description: "Get artifact by `<name>` from a specific run.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Caching**, artifacts may be cached in data centers closer to the\nworkers in-order to reduce bandwidth costs. This can lead to longer\nresponse times. Caching can be skipped by setting the header\n`x-taskcluster-skip-cache: true`, this should only be used for resources\nwhere request volume is known to be low, and caching not useful.\n(This feature may be disabled in the future, use is sparingly!)",
				Scopes: [][]string{
					[]string{
						"queue:get-artifact:<name>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/task/<taskId>/runs/<runId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"runId",
					"name",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "getLatestArtifact",
				Title:       "Get Artifact from Latest Run",
				Description: "Get artifact by `<name>` from the last run of a task.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
				Scopes: [][]string{
					[]string{
						"queue:get-artifact:<name>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/task/<taskId>/artifacts/<name>",
				Args: []string{
					"taskId",
					"name",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listArtifacts",
				Title:       "Get Artifacts from Run",
				Description: "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task/<taskId>/runs/<runId>/artifacts",
				Args: []string{
					"taskId",
					"runId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/list-artifacts-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "listLatestArtifacts",
				Title:       "Get Artifacts from Latest Run",
				Description: "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task/<taskId>/artifacts",
				Args: []string{
					"taskId",
				},
				Query: []string{
					"continuationToken",
					"limit",
				},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/list-artifacts-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "pendingTasks",
				Title:       "Get Number of Pending Tasks",
				Description: "Get an approximate number of pending tasks for the given `provisionerId`\nand `workerType`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/pending/<provisionerId>/<workerType>",
				Args: []string{
					"provisionerId",
					"workerType",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/queue/v1/pending-tasks-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"QueueEvents": definitions.Service{
		BaseURL:     "",
		Title:       "Queue AMQP Exchanges",
		Description: "The queue, typically available at `queue.taskcluster.net`, is responsible\nfor accepting tasks and track their state as they are executed by\nworkers. In order ensure they are eventually resolved.\n\nThis document describes AMQP exchanges offered by the queue, which allows\nthird-party listeners to monitor tasks as they progress to resolution.\nThese exchanges targets the following audience:\n * Schedulers, who takes action after tasks are completed,\n * Workers, who wants to listen for new or canceled tasks (optional),\n * Tools, that wants to update their view as task progress.\n\nYou'll notice that all the exchanges in the document shares the same\nrouting key pattern. This makes it very easy to bind to all messages\nabout a certain kind tasks.\n\n**Task specific routes**, a task can define a task specific route using\nthe `task.routes` property. See task creation documentation for details\non permissions required to provide task specific routes. If a task has\nthe entry `'notify.by-email'` in as task specific route defined in\n`task.routes` all messages about this task will be CC'ed with the\nrouting-key `'route.notify.by-email'`.\n\nThese routes will always be prefixed `route.`, so that cannot interfere\nwith the _primary_ routing key as documented here. Notice that the\n_primary_ routing key is always prefixed `primary.`. This is ensured\nin the routing key reference, so API clients will do this automatically.\n\nPlease, note that the way RabbitMQ works, the message will only arrive\nin your queue once, even though you may have bound to the exchange with\nmultiple routing key patterns that matches more of the CC'ed routing\nrouting keys.\n\n**Delivery guarantees**, most operations on the queue are idempotent,\nwhich means that if repeated with the same arguments then the requests\nwill ensure completion of the operation and return the same response.\nThis is useful if the server crashes or the TCP connection breaks, but\nwhen re-executing an idempotent operation, the queue will also resend\nany related AMQP messages. Hence, messages may be repeated.\n\nThis shouldn't be much of a problem, as the best you can achieve using\nconfirm messages with AMQP is at-least-once delivery semantics. Hence,\nthis only prevents you from obtaining at-most-once delivery semantics.\n\n**Remark**, some message generated by timeouts maybe dropped if the\nserver crashes at wrong time. Ideally, we'll address this in the\nfuture. For now we suggest you ignore this corner case, and notify us\nif this corner case is of concern to you.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskDefined",
				Title:       "Task Defined Messages",
				Description: "When a task is created or just defined a message is posted to this\nexchange.\n\nThis message exchange is mainly useful when tasks are scheduled by a\nscheduler that uses `defineTask` as this does not make the task\n`pending`. Thus, no `taskPending` message is published.\nPlease, note that messages are also published on this exchange if defined\nusing `createTask`.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskPending",
				Title:       "Task Pending Messages",
				Description: "When a task becomes `pending` a message is posted to this exchange.\n\nThis is useful for workers who doesn't want to constantly poll the queue\nfor new tasks. The queue will also be authority for task states and\nclaims. But using this exchange workers should be able to distribute work\nefficiently and they would be able to reduce their polling interval\nsignificantly without affecting general responsiveness.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskRunning",
				Title:       "Task Running Messages",
				Description: "Whenever a task is claimed by a worker, a run is started on the worker,\nand a message is posted on this exchange.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "artifactCreated",
				Title:       "Artifact Creation Messages",
				Description: "Whenever the `createArtifact` end-point is called, the queue will create\na record of the artifact and post a message on this exchange. All of this\nhappens before the queue returns a signed URL for the caller to upload\nthe actual artifact with (pending on `storageType`).\n\nThis means that the actual artifact is rarely available when this message\nis posted. But it is not unreasonable to assume that the artifact will\nwill become available at some point later. Most signatures will expire in\n30 minutes or so, forcing the uploader to call `createArtifact` with\nthe same payload again in-order to continue uploading the artifact.\n\nHowever, in most cases (especially for small artifacts) it's very\nreasonable assume the artifact will be available within a few minutes.\nThis property means that this exchange is mostly useful for tools\nmonitoring task evaluation. One could also use it count number of\nartifacts per task, or _index_ artifacts though in most cases it'll be\nsmarter to index artifacts after the task in question have completed\nsuccessfully.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskCompleted",
				Title:       "Task Completed Messages",
				Description: "When a task is successfully completed by a worker a message is posted\nthis exchange.\nThis message is routed using the `runId`, `workerGroup` and `workerId`\nthat completed the task. But information about additional runs is also\navailable from the task status structure.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskFailed",
				Title:       "Task Failed Messages",
				Description: "When a task ran, but failed to complete successfully a message is posted\nto this exchange. This is same as worker ran task-specific code, but the\ntask specific code exited non-zero.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskException",
				Title:       "Task Exception Messages",
				Description: "Whenever TaskCluster fails to run a message is posted to this exchange.\nThis happens if the task isn't completed before its `deadlne`,\nall retries failed (i.e. workers stopped responding), the task was\ncanceled by another entity, or the task carried a malformed payload.\n\nThe specific _reason_ is evident from that task status structure, refer\nto the `reasonResolved` property for the last run.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskGroupResolved",
				Title:       "Task Group Resolved Messages",
				Description: "A message is published on task-group-resolved whenever all submitted\ntasks (whether scheduled or unscheduled) for a given task group have\nbeen resolved, regardless of whether they resolved as successful or\nnot. A task group may be resolved multiple times, since new tasks may\nbe submitted against an already resolved task group.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"Scheduler": definitions.Service{
		BaseURL:     "https://scheduler.taskcluster.net/v1",
		Title:       "Task-Graph Scheduler API Documentation",
		Description: "The task-graph scheduler, typically available at\n`scheduler.taskcluster.net`, is responsible for accepting task-graphs and\nscheduling tasks for evaluation by the queue as their dependencies are\nsatisfied.\n\nThis document describes API end-points offered by the task-graph\nscheduler. These end-points targets the following audience:\n * Post-commit hooks, that wants to submit task-graphs for testing,\n * End-users, who wants to execute a set of dependent tasks, and\n * Tools, that wants to inspect the state of a task-graph.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "createTaskGraph",
				Title:       "Create new task-graph",
				Description: "Create a new task-graph, the `status` of the resulting JSON is a\ntask-graph status structure, you can find the `taskGraphId` in this\nstructure.\n\n**Referencing required tasks**, it is possible to reference other tasks\nin the task-graph that must be completed successfully before a task is\nscheduled. You just specify the `taskId` in the list of `required` tasks.\nSee the example below, where the second task requires the first task.\n```js\n{\n  ...\n  tasks: [\n    {\n      taskId:     \"XgvL0qtSR92cIWpcwdGKCA\",\n      requires:   [],\n      ...\n    },\n    {\n      taskId:     \"73GsfK62QNKAk2Hg1EEZTQ\",\n      requires:   [\"XgvL0qtSR92cIWpcwdGKCA\"],\n      task: {\n        payload: {\n          env: {\n            DEPENDS_ON:  \"XgvL0qtSR92cIWpcwdGKCA\"\n          }\n          ...\n        }\n        ...\n      },\n      ...\n    }\n  ]\n}\n```\n\n**The `schedulerId` property**, defaults to the `schedulerId` of this\nscheduler in production that is `\"task-graph-scheduler\"`. This\nproperty must be either undefined or set to `\"task-graph-scheduler\"`,\notherwise the task-graph will be rejected.\n\n**The `taskGroupId` property**, defaults to the `taskGraphId` of the\ntask-graph submitted, and if provided much be the `taskGraphId` of\nthe task-graph. Otherwise the task-graph will be rejected.\n\n**Task-graph scopes**, a task-graph is assigned a set of scopes, just\nlike tasks. Tasks within a task-graph cannot have scopes beyond those\nthe task-graph has. The task-graph scheduler will execute all requests\non behalf of a task-graph using the set of scopes assigned to the\ntask-graph. Thus, if you are submitting tasks to `my-worker-type` under\n`my-provisioner` it's important that your task-graph has the scope\nrequired to define tasks for this `provisionerId` and `workerType`.\n(`queue:define-task:..` or `queue:create-task:..`; see the queue for\ndetails on scopes required). Note, the task-graph does not require\npermissions to schedule the tasks (`queue:schedule-task:..`), as this is\ndone with scopes provided by the task-graph scheduler.\n\n**Task-graph specific routing-keys**, using the `taskGraph.routes`\nproperty you may define task-graph specific routing-keys. If a task-graph\nhas a task-graph specific routing-key: `<route>`, then the poster will\nbe required to posses the scope `scheduler:route:<route>`. And when the\nan AMQP message about the task-graph is published the message will be\nCC'ed with the routing-key: `route.<route>`. This is useful if you want\nanother component to listen for completed tasks you have posted.",
				Scopes: [][]string{
					[]string{
						"scheduler:create-task-graph",
					},
				},
				Stability: "experimental",
				Method:    "put",
				Route:     "/task-graph/<taskGraphId>",
				Args: []string{
					"taskGraphId",
				},
				Query:  []string(nil),
				Input:  "http://schemas.taskcluster.net/scheduler/v1/task-graph.json#",
				Output: "http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "extendTaskGraph",
				Title:       "Extend existing task-graph",
				Description: "Add a set of tasks to an existing task-graph. The request format is very\nsimilar to the request format for creating task-graphs. But `routes`\nkey, `scopes`, `metadata` and `tags` cannot be modified.\n\n**Referencing required tasks**, just as when task-graphs are created,\neach task has a list of required tasks. It is possible to reference\nall `taskId`s within the task-graph.\n\n**Safety,** it is only _safe_ to call this API end-point while the\ntask-graph being modified is still running. If the task-graph is\n_finished_ or _blocked_, this method will leave the task-graph in this\nstate. Hence, it is only truly _safe_ to call this API end-point from\nwithin a task in the task-graph being modified.",
				Scopes: [][]string{
					[]string{
						"scheduler:extend-task-graph:<taskGraphId>",
					},
				},
				Stability: "experimental",
				Method:    "post",
				Route:     "/task-graph/<taskGraphId>/extend",
				Args: []string{
					"taskGraphId",
				},
				Query:  []string(nil),
				Input:  "http://schemas.taskcluster.net/scheduler/v1/extend-task-graph-request.json#",
				Output: "http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "status",
				Title:       "Task Graph Status",
				Description: "Get task-graph status, this will return the _task-graph status\nstructure_. which can be used to check if a task-graph is `running`,\n`blocked` or `finished`.\n\n**Note**, that `finished` implies successfully completion.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task-graph/<taskGraphId>/status",
				Args: []string{
					"taskGraphId",
				},
				Query:  []string(nil),
				Input:  "",
				Output: "http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "info",
				Title:       "Task Graph Information",
				Description: "Get task-graph information, this includes the _task-graph status\nstructure_, along with `metadata` and `tags`, but not information\nabout all tasks.\n\nIf you want more detailed information use the `inspectTaskGraph`\nend-point instead.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task-graph/<taskGraphId>/info",
				Args: []string{
					"taskGraphId",
				},
				Query:  []string(nil),
				Input:  "",
				Output: "http://schemas.taskcluster.net/scheduler/v1/task-graph-info-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "inspect",
				Title:       "Inspect Task Graph",
				Description: "Inspect a task-graph, this returns all the information the task-graph\nscheduler knows about the task-graph and the state of its tasks.\n\n**Warning**, some of these fields are borderline internal to the\ntask-graph scheduler and we may choose to change or make them internal\nlater. Also note that note all of the information is formalized yet.\nThe JSON schema will be updated to reflect formalized values, we think\nit's safe to consider the values stable.\n\nTake these considerations into account when using the API end-point,\nas we do not promise it will remain fully backward compatible in\nthe future.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task-graph/<taskGraphId>/inspect",
				Args: []string{
					"taskGraphId",
				},
				Query:  []string(nil),
				Input:  "",
				Output: "http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "inspectTask",
				Title:       "Inspect Task from a Task-Graph",
				Description: "Inspect a task from a task-graph, this returns all the information the\ntask-graph scheduler knows about the specific task.\n\n**Warning**, some of these fields are borderline internal to the\ntask-graph scheduler and we may choose to change or make them internal\nlater. Also note that note all of the information is formalized yet.\nThe JSON schema will be updated to reflect formalized values, we think\nit's safe to consider the values stable.\n\nTake these considerations into account when using the API end-point,\nas we do not promise it will remain fully backward compatible in\nthe future.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/task-graph/<taskGraphId>/inspect/<taskId>",
				Args: []string{
					"taskGraphId",
					"taskId",
				},
				Query:  []string(nil),
				Input:  "",
				Output: "http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-task-response.json",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Documented later...\n\n**Warning** this api end-point is **not stable**.",
				Scopes:      [][]string(nil),
				Stability:   "experimental",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"SchedulerEvents": definitions.Service{
		BaseURL:     "",
		Title:       "Scheduler AMQP Exchanges",
		Description: "The scheduler, typically available at `scheduler.taskcluster.net` is\nresponsible for accepting task-graphs and schedule tasks on the queue as\ntheir dependencies are completed successfully.\n\nThis document describes the AMQP exchanges offered by the scheduler,\nwhich allows third-party listeners to monitor task-graph submission and\nresolution. These exchanges targets the following audience:\n * Reporters, who displays the state of task-graphs or emails people on\n   failures, and\n * End-users, who wants notification of completed task-graphs\n\n**Remark**, the task-graph scheduler will require that the `schedulerId`\nfor tasks is set to the `schedulerId` for the task-graph scheduler. In\nproduction the `schedulerId` is typically `\"task-graph-scheduler\"`.\nFurthermore, the task-graph scheduler will also require that\n`taskGroupId` is equal to the `taskGraphId`.\n\nCombined these requirements ensures that `schedulerId` and `taskGroupId`\nhave the same position in the routing keys for the queue exchanges.\nSee queue documentation for details on queue exchanges. Hence, making\nit easy to listen for all tasks in a given task-graph.\n\nNote that routing key entries 2 through 7 used for exchanges on the\ntask-graph scheduler is hardcoded to `_`. This is done to preserve\npositional equivalence with exchanges offered by the queue.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskGraphRunning",
				Title:       "Task-Graph Running Message",
				Description: "When a task-graph is submitted it immediately starts running and a\nmessage is posted on this exchange to indicate that a task-graph have\nbeen submitted.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskGraphExtended",
				Title:       "Task-Graph Extended Message",
				Description: "When a task-graph is extended, that is additional tasks is added to the\ntask-graph, a message is posted on this exchange. This is useful if you\nare monitoring a task-graph and what to track states of the individual\ntasks in the task-graph.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskGraphBlocked",
				Title:       "Task-Graph Blocked Message",
				Description: "When a task is completed unsuccessfully and all reruns have been\nattempted, the task-graph will not complete successfully and it's\ndeclared to be _blocked_, by some task that consistently completes\nunsuccessfully.\n\nWhen a task-graph becomes blocked a messages is posted to this exchange.\nThe message features the `taskId` of the task that caused the task-graph\nto become blocked.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "taskGraphFinished",
				Title:       "Task-Graph Finished Message",
				Description: "When all tasks of a task-graph have completed successfully, the\ntask-graph is declared to be finished, and a message is posted to this\nexchange.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
	"Secrets": definitions.Service{
		BaseURL:     "https://secrets.taskcluster.net/v1",
		Title:       "TaskCluster Secrets API Documentation",
		Description: "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "function",
				Name:        "set",
				Title:       "Set Secret",
				Description: "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
				Scopes: [][]string{
					[]string{
						"secrets:set:<name>",
					},
				},
				Stability: "stable",
				Method:    "put",
				Route:     "/secret/<name>",
				Args: []string{
					"name",
				},
				Query:  []string{},
				Input:  "http://schemas.taskcluster.net/secrets/v1/secret.json#",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "remove",
				Title:       "Delete Secret",
				Description: "Delete the secret associated with some key.",
				Scopes: [][]string{
					[]string{
						"secrets:set:<name>",
					},
				},
				Stability: "stable",
				Method:    "delete",
				Route:     "/secret/<name>",
				Args: []string{
					"name",
				},
				Query:  []string{},
				Input:  "",
				Output: "",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "get",
				Title:       "Read Secret",
				Description: "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
				Scopes: [][]string{
					[]string{
						"secrets:get:<name>",
					},
				},
				Stability: "stable",
				Method:    "get",
				Route:     "/secret/<name>",
				Args: []string{
					"name",
				},
				Query:  []string{},
				Input:  "",
				Output: "http://schemas.taskcluster.net/secrets/v1/secret.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "list",
				Title:       "List Secrets",
				Description: "List the names of all secrets that you would have access to read. In\nother words, secret name `<X>` will only be returned if a) a secret\nwith name `<X>` exists, and b) you posses the scope `secrets:get:<X>`.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/secrets",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "http://schemas.taskcluster.net/secrets/v1/secret-list.json#",
			},
			definitions.Entry{
				Type:        "function",
				Name:        "ping",
				Title:       "Ping Server",
				Description: "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
				Scopes:      [][]string(nil),
				Stability:   "stable",
				Method:      "get",
				Route:       "/ping",
				Args:        []string{},
				Query:       []string{},
				Input:       "",
				Output:      "",
			},
		},
	},
	"TreeherderEvents": definitions.Service{
		BaseURL:     "",
		Title:       "Taskcluster-treeherder Pulse Exchange",
		Description: "The taskcluster-treeherder service is responsible for processing\ntask events published by TaskCluster Queue and producing job messages\nthat are consumable by Treeherder.\n\nThis exchange provides that job messages to be consumed by any queue that\nattached to the exchange.  This could be a production Treeheder instance,\na local development environment, or a custom dashboard.",
		Entries: []definitions.Entry{
			definitions.Entry{
				Type:        "topic-exchange",
				Name:        "jobs",
				Title:       "Job Messages",
				Description: "When a task run is scheduled or resolved, a message is posted to\nthis exchange in a Treeherder consumable format.",
				Scopes:      [][]string(nil),
				Stability:   "",
				Method:      "",
				Route:       "",
				Args:        []string(nil),
				Query:       []string(nil),
				Input:       "",
				Output:      "",
			},
		},
	},
}
var schemas = map[string]string{
	"http://schemas.taskcluster.net/auth/v1/authenticate-hawk-request.json#":                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hawk Signature Authentication Request\",\n    \"description\": \"Request to authenticate a hawk request.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"method\": {\n            \"type\": \"string\",\n            \"enum\": [\n                \"get\",\n                \"post\",\n                \"put\",\n                \"head\",\n                \"delete\",\n                \"options\",\n                \"trace\",\n                \"copy\",\n                \"lock\",\n                \"mkcol\",\n                \"move\",\n                \"purge\",\n                \"propfind\",\n                \"proppatch\",\n                \"unlock\",\n                \"report\",\n                \"mkactivity\",\n                \"checkout\",\n                \"merge\",\n                \"m-search\",\n                \"notify\",\n                \"subscribe\",\n                \"unsubscribe\",\n                \"patch\",\n                \"search\",\n                \"connect\"\n            ],\n            \"description\": \"HTTP method of the request being authenticated.\\n\"\n        },\n        \"resource\": {\n            \"type\": \"string\",\n            \"description\": \"Resource the request operates on including querystring. This is the\\nstring that follows the HTTP method.\\n**Note,** order of querystring elements is important.\\n\"\n        },\n        \"host\": {\n            \"type\": \"string\",\n            \"anyOf\": [\n                {\n                    \"format\": \"hostname\"\n                },\n                {\n                    \"format\": \"ipv4\"\n                }\n            ],\n            \"description\": \"Host for which the request came in, this is typically the `Host` header\\nexcluding the port if any.\\n\"\n        },\n        \"port\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 65535,\n            \"description\": \"Port on which the request came in, this is typically `80` or `443`.\\nIf you are running behind a reverse proxy look for the `x-forwarded-port`\\nheader.\\n\"\n        },\n        \"authorization\": {\n            \"type\": \"string\",\n            \"description\": \"Authorization header, **must** only be specified if request being\\nauthenticated has a `Authorization` header.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"method\",\n        \"resource\",\n        \"host\",\n        \"port\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/authenticate-hawk-request.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/authenticate-hawk-response.json#":                      "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hawk Signature Authentication Response\",\n    \"description\": \"Response from a request to authenticate a hawk request.\\n\",\n    \"type\": \"object\",\n    \"anyOf\": [\n        {\n            \"title\": \"Authentication Successful Response\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"status\": {\n                    \"description\": \"The kind of response, `auth-failed` or `auth-success`.\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"auth-success\"\n                    ]\n                },\n                \"scopes\": {\n                    \"description\": \"List of scopes the client is authorized to access.  Scopes must be\\ncomposed of printable ASCII characters and spaces.\\n\",\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"pattern\": \"^[ -~]*$\"\n                    }\n                },\n                \"scheme\": {\n                    \"description\": \"Authentication scheme the client used. Generally, you don't need to\\nread this property unless `hash` is provided and you want to validate\\nthe payload hash. Additional values may be added in the future.\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"hawk\"\n                    ]\n                },\n                \"hash\": {\n                    \"description\": \"Payload as extracted from `Authentication` header. This property is\\nonly present if a hash is available. You are not required to validate\\nthis hash, but if you do, please check `scheme` to ensure that it's\\non a scheme you support.\\n\"\n                },\n                \"clientId\": {\n                    \"description\": \"The `clientId` that made this request.  This may be the `id` supplied in\\nthe Authorization header, or in the case of a named temporary credential\\nmay be embedded in the payload.  In any case, this clientId can be used\\nfor logging, auditing, and identifying the credential but **must** not be\\nused for access control.  That's what scopes are for.\\n\",\n                    \"type\": \"string\"\n                },\n                \"expires\": {\n                    \"description\": \"The expiration time for the credentials used to make this request.\\nThis should be treated as the latest time at which the authorization\\nis valid.  For most cases, where the access being authorized occurs\\nimmediately, this field can be ignored, as the value will always be\\nin the future if the status is `auth-success`.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"status\",\n                \"scopes\",\n                \"scheme\",\n                \"clientId\",\n                \"expires\"\n            ]\n        },\n        {\n            \"title\": \"Authentication Failed Response\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"status\": {\n                    \"description\": \"The kind of response, `auth-failed` or `auth-success`.\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"auth-failed\"\n                    ]\n                },\n                \"message\": {\n                    \"type\": \"string\",\n                    \"description\": \"Message saying why the authentication failed.\\n\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"status\",\n                \"message\"\n            ]\n        }\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/authenticate-hawk-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/aws-s3-credentials-response.json#":                     "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"AWS S3 Credentials Response\",\n    \"description\": \"Response for a request to get access to an S3 bucket.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"credentials\": {\n            \"title\": \"Temporary Security Credentials\",\n            \"description\": \"Temporary STS credentials for use when operating on S3\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"accessKeyId\": {\n                    \"type\": \"string\",\n                    \"title\": \"AccessKeyId\",\n                    \"description\": \"Access key identifier that identifies the temporary security\\ncredentials.\\n\"\n                },\n                \"secretAccessKey\": {\n                    \"type\": \"string\",\n                    \"title\": \"SecretAccessKey\",\n                    \"description\": \"Secret access key used to sign requests\\n\"\n                },\n                \"sessionToken\": {\n                    \"type\": \"string\",\n                    \"title\": \"SessionToken\",\n                    \"description\": \"A token that must passed with request to use the temporary\\nsecurity credentials.\\n\"\n                }\n            },\n            \"required\": [\n                \"accessKeyId\",\n                \"secretAccessKey\",\n                \"sessionToken\"\n            ]\n        },\n        \"expires\": {\n            \"description\": \"Date and time of when the temporary credentials expires.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"credentials\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/aws-s3-credentials-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/azure-table-access-response.json#":                     "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Azure Shared-Access-Signature Response\",\n    \"description\": \"Response to a request for an Shared-Access-Signature to access and Azure\\nTable Storage table.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"sas\": {\n            \"description\": \"Shared-Access-Signature string. This is the querystring parameters to\\nbe appened after `?` or `&` depending on whether or not a querystring is\\nalready present in the URL.\\n\",\n            \"type\": \"string\"\n        },\n        \"expiry\": {\n            \"description\": \"Date and time of when the Shared-Access-Signature expires.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"sas\",\n        \"expiry\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/azure-table-access-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/create-client-request.json#":                           "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Create Client Request\",\n    \"description\": \"Properties to create a client.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"expires\": {\n            \"description\": \"Date and time where the clients access is set to expire\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"deleteOnExpiration\": {\n            \"description\": \"If `true`, the service may delete this client after it has expired.  If\\n`false` (the default), the client will remain after expiration, although\\nit cannot be used for authentication in that state.\\n\",\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"description\": {\n            \"description\": \"Description of what these credentials are used for in markdown.\\nShould include who is the owner, point of contact.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 10240\n        },\n        \"scopes\": {\n            \"description\": \"List of scopes the client has.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"expires\",\n        \"description\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/create-client-request.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/create-client-response.json#":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Create Client Response\",\n    \"description\": \"All details about a client including the `accessToken`\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"clientId\": {\n            \"description\": \"ClientId of the client\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9@/:._-]+$\"\n        },\n        \"accessToken\": {\n            \"description\": \"AccessToken used for authenticating requests, you should store this\\nyou won't be able to retrive it again!\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[a-zA-Z0-9_-]{22,66}$\"\n        },\n        \"expires\": {\n            \"description\": \"Date and time where the clients access is set to expire\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"deleteOnExpiration\": {\n            \"description\": \"If `true`, the service may delete this client after it has expired.  If\\n`false`, the client will remain after expiration, although it cannot be\\nused for authentication in that state.\\n\",\n            \"type\": \"boolean\"\n        },\n        \"description\": {\n            \"description\": \"Description of what these credentials are used for in markdown.\\nShould include who is the owner, point of contact.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 10240\n        },\n        \"created\": {\n            \"description\": \"Date and time when this client was created\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastModified\": {\n            \"description\": \"Date and time of last modification\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastDateUsed\": {\n            \"description\": \"Date of last time this client was used. Will only be updated every 6 hours\\nor so this may be off by up-to 6 hours. But it still gives a solid hint\\nas to whether or not this client is in use.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastRotated\": {\n            \"description\": \"Date and time of when the `accessToken` was reset last time.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"scopes\": {\n            \"description\": \"List of scopes the client has (unexpanded).  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        },\n        \"expandedScopes\": {\n            \"description\": \"List of scopes granted to this client by matching roles, including the\\nclient's scopes and the implicit role `client-id:<clientId>`.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope that client is granted\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            }\n        },\n        \"disabled\": {\n            \"description\": \"If true, this client is disabled and cannot be used.  This usually occurs when the\\nscopes available to the user owning the client no longer satisfy the client.\\n\",\n            \"type\": \"boolean\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"clientId\",\n        \"accessToken\",\n        \"expires\",\n        \"description\",\n        \"created\",\n        \"lastModified\",\n        \"lastDateUsed\",\n        \"lastRotated\",\n        \"scopes\",\n        \"expandedScopes\",\n        \"disabled\",\n        \"deleteOnExpiration\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/create-client-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/create-role-request.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Create Role Request\",\n    \"description\": \"Data to create or update a role.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"scopes\": {\n            \"description\": \"List of scopes the role grants access to.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope the role grants access to\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        },\n        \"description\": {\n            \"description\": \"Description of what this role is used for in markdown.\\nShould include who is the owner, point of contact.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 10240\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"scopes\",\n        \"description\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/create-role-request.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/get-client-response.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Client Response\",\n    \"description\": \"Get all details about a client, useful for tools modifying a client\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"clientId\": {\n            \"description\": \"ClientId of the client scopes is requested about\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9@/:._-]+$\"\n        },\n        \"expires\": {\n            \"description\": \"Date and time where the clients access is set to expire\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"deleteOnExpiration\": {\n            \"description\": \"If `true`, the service may delete this client after it has expired.  If\\n`false`, the client will remain after expiration, although it cannot be\\nused for authentication in that state.\\n\",\n            \"type\": \"boolean\"\n        },\n        \"description\": {\n            \"description\": \"Description of what these credentials are used for in markdown.\\nShould include who is the owner, point of contact.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 10240\n        },\n        \"created\": {\n            \"description\": \"Date and time when this client was created\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastModified\": {\n            \"description\": \"Date and time of last modification\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastDateUsed\": {\n            \"description\": \"Date of last time this client was used. Will only be updated every 6 hours\\nor so this may be off by up-to 6 hours. But it still gives a solid hint\\nas to whether or not this client is in use.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastRotated\": {\n            \"description\": \"Date and time of when the `accessToken` was reset last time.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"scopes\": {\n            \"description\": \"List of scopes the client has (unexpanded).  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        },\n        \"expandedScopes\": {\n            \"description\": \"List of scopes granted to this client by matching roles.  Scopes must be\\ncomposed of printable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope that client is granted by a role\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            }\n        },\n        \"disabled\": {\n            \"description\": \"If true, this client is disabled and cannot be used.  This usually occurs when the\\nscopes available to the user owning the client no longer satisfy the client.\\n\",\n            \"type\": \"boolean\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"clientId\",\n        \"expires\",\n        \"description\",\n        \"created\",\n        \"lastModified\",\n        \"lastDateUsed\",\n        \"lastRotated\",\n        \"scopes\",\n        \"expandedScopes\",\n        \"disabled\",\n        \"deleteOnExpiration\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/get-client-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/get-role-response.json#":                               "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Role Response\",\n    \"description\": \"Get all details about a role\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"roleId\": {\n            \"description\": \"roleId of the role requested\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[\\\\x20-\\\\x7e]+$\"\n        },\n        \"scopes\": {\n            \"description\": \"List of scopes the role grants access to.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope the role grants access to\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            }\n        },\n        \"description\": {\n            \"description\": \"Description of what this role is used for in markdown.\\nShould include who is the owner, point of contact.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 10240\n        },\n        \"created\": {\n            \"description\": \"Date and time when this role was created\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"lastModified\": {\n            \"description\": \"Date and time of last modification\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"expandedScopes\": {\n            \"description\": \"List of scopes granted anyone who assumes this role, including anything\\ngranted by roles that can be assumed when you have this role.\\nHence, this includes any scopes in-directly granted as well.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope this role grants\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"roleId\",\n        \"scopes\",\n        \"description\",\n        \"created\",\n        \"lastModified\",\n        \"expandedScopes\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/get-role-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/list-clients-response.json#":                           "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Client Response\",\n    \"description\": \"List of clients\\n\",\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"http://schemas.taskcluster.net/auth/v1/get-client-response.json#\"\n    },\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/list-clients-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/list-roles-response.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Roles Response\",\n    \"description\": \"List of roles\\n\",\n    \"type\": \"array\",\n    \"items\": {\n        \"$ref\": \"http://schemas.taskcluster.net/auth/v1/get-role-response.json#\"\n    },\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/list-roles-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/scopeset.json#":                                        "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Set of scopes\",\n    \"description\": \"A set of scopes\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"scopes\": {\n            \"description\": \"List of scopes.  Scopes must be composed of printable ASCII characters and spaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        }\n    },\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/scopeset.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/sentry-dsn-response.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Sentry DSN Response\",\n    \"description\": \"Sentry DSN for submitting errors.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"project\": {\n            \"type\": \"string\",\n            \"title\": \"Project\",\n            \"description\": \"Project name that the DSN grants access to.\\n\"\n        },\n        \"dsn\": {\n            \"type\": \"object\",\n            \"description\": \"Access credentials and urls for the Sentry project.\\nCredentials will expire in 24-48 hours, you should refresh them within\\n24 hours.\\n\",\n            \"properties\": {\n                \"secret\": {\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"description\": \"Access credential and URL for private error reports.\\nThese credentials can be used for up-to 24 hours.\\nThis is for use in serser-side applications and should **not** be\\nleaked.\\n\"\n                },\n                \"public\": {\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"description\": \"Access credential and URL for public error reports.\\nThese credentials can be used for up-to 24 hours.\\nThis is for use in client-side applications only.\\n\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"secret\",\n                \"public\"\n            ]\n        },\n        \"expires\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Expiration time for the credentials. The credentials should not be used\\nafter this time. They might not be revoked immediately, but will be at\\nsome arbitrary point after this date-time.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"project\",\n        \"dsn\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/sentry-dsn-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/statsum-token-response.json#":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Statsum Token Response\",\n    \"description\": \"Token for submitting statistics to statsum.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"project\": {\n            \"type\": \"string\",\n            \"title\": \"Project\",\n            \"description\": \"Project name that the token grants access to.\\n\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"title\": \"Access Token\",\n            \"description\": \"JWT token to be used as `Bearer <token>` when submitting data to statsum.\\n\"\n        },\n        \"expires\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"title\": \"Token Expiration\",\n            \"description\": \"Time at which the token expires and should not be used anymore.\\n\"\n        },\n        \"baseUrl\": {\n            \"type\": \"string\",\n            \"format\": \"uri\",\n            \"title\": \"BaseUrl\",\n            \"description\": \"Base URL for the statsum server this project is allocated on.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"project\",\n        \"token\",\n        \"expires\",\n        \"baseUrl\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/statsum-token-response.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/test-authenticate-request.json#":                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Test Authenticate Request\",\n    \"description\": \"Details on how the test request should be authenticated.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"clientScopes\": {\n            \"description\": \"List of scopes that should be client used should be given.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        },\n        \"requiredScopes\": {\n            \"description\": \"List of scopes the request should require.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        }\n    },\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/test-authenticate-request.json#\"\n}",
	"http://schemas.taskcluster.net/auth/v1/test-authenticate-response.json#":                      "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Test Authenticate Response\",\n    \"description\": \"Details on how the test request was authenticated.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"clientId\": {\n            \"description\": \"ClientId from the request as it will be logged\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9@/:._-]+$\"\n        },\n        \"scopes\": {\n            \"description\": \"List of scopes the request was authorized.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"description\": \"Scope\",\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"uniqueItems\": true\n        }\n    },\n    \"id\": \"http://schemas.taskcluster.net/auth/v1/test-authenticate-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/backend-status-response.json#":              "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Backend Status Response\",\n    \"description\": \"Backend Status Response\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"A string from Deadman's Snitch which describes the status.  See\\nhttps://deadmanssnitch.com/docs/api/v1#listing-your-snitches for an\\nexplanation of this value\\n\"\n        },\n        \"lastCheckedIn\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"A date when the provisioner backend process last completed an iteration.\\nThis does not imply success, rather it is to make sure that the process\\nis alive\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"lastCheckedIn\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/backend-status-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/create-ami-set-request.json#":               "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Create AMI Set Request\",\n    \"description\": \"Create a new AMI Set\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"amis\": {\n            \"type\": \"array\",\n            \"description\": \"AMIs in this set\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"region\": {\n                        \"type\": \"string\",\n                        \"description\": \"The Amazon AWS region of the AMI set\\n\"\n                    },\n                    \"hvm\": {\n                        \"type\": \"string\",\n                        \"description\": \"The AMI that uses HVM virtualization type\\n\"\n                    },\n                    \"pv\": {\n                        \"type\": \"string\",\n                        \"description\": \"The AMI that uses PV virtualization type\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"region\",\n                    \"hvm\",\n                    \"pv\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"amis\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/create-ami-set-request.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/create-secret-request.json#":                "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Secret Request\",\n    \"description\": \"A Secret\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"workerType\": {\n            \"type\": \"string\",\n            \"description\": \"A string describing what the secret will be used for\\n\"\n        },\n        \"secrets\": {\n            \"type\": \"object\",\n            \"description\": \"Free form object which contains the secrets stored\\n\"\n        },\n        \"scopes\": {\n            \"type\": \"array\",\n            \"description\": \"List of strings which are scopes for temporary credentials to give\\nto the worker through the secret system.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            }\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"description\": \"A Slug ID which is the uniquely addressable token to access this\\nset of secrets\\n\"\n        },\n        \"expiration\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"The date at which the secret is no longer guarunteed to exist\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"workerType\",\n        \"secrets\",\n        \"scopes\",\n        \"token\",\n        \"expiration\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/create-secret-request.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/create-worker-type-request.json#":           "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Create Worker Type Request\",\n    \"description\": \"A worker launchSpecification and required metadata\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"launchSpec\": {\n            \"type\": \"object\",\n            \"description\": \"Launch Specification entries which are used in all regions and all instance types\\n\"\n        },\n        \"description\": {\n            \"type\": \"string\",\n            \"description\": \"A string which describes what this image is for and hints on using it\\n\"\n        },\n        \"owner\": {\n            \"type\": \"string\",\n            \"description\": \"A string which identifies the owner of this worker type\\n\"\n        },\n        \"secrets\": {\n            \"type\": \"object\",\n            \"description\": \"Static secrets entries which are used in all regions and all instance types\\n\"\n        },\n        \"userData\": {\n            \"type\": \"object\",\n            \"description\": \"UserData entries which are used in all regions and all instance types\\n\"\n        },\n        \"scopes\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"description\": \"Scopes to issue credentials to for all regions Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\"\n        },\n        \"minCapacity\": {\n            \"type\": \"number\",\n            \"description\": \"Minimum number of capacity units to be provisioned.  A capacity unit\\nis an abstract unit of capacity, where one capacity unit is roughly\\none task which should be taken off the queue\\n\"\n        },\n        \"maxCapacity\": {\n            \"type\": \"number\",\n            \"description\": \"Maximum number of capacity units to be provisioned.\\n\"\n        },\n        \"scalingRatio\": {\n            \"type\": \"number\",\n            \"description\": \"A scaling ratio of `0.2` means that the provisioner will attempt to keep\\nthe number of pending tasks around 20% of the provisioned capacity.\\nThis results in pending tasks waiting 20% of the average task execution\\ntime before starting to run.\\nA higher scaling ratio often results in better utilization and longer\\nwaiting times. For workerTypes running long tasks a short scaling ratio\\nmay be prefered, but for workerTypes running quick tasks a higher scaling\\nratio may increase utilization without major delays.\\nIf using a scaling ratio of 0, the provisioner will attempt to keep the\\ncapacity of pending spot requests equal to the number of pending tasks.\\n\"\n        },\n        \"minPrice\": {\n            \"type\": \"number\",\n            \"description\": \"Minimum price to pay for an instance.  A Price is considered to be the\\nAmazon Spot Price multiplied by the utility factor of the InstantType\\nas specified in the instanceTypes list.  For example, if the minPrice\\nis set to $0.5 and the utility factor is 2, the actual minimum bid\\nused will be $0.25\\n\"\n        },\n        \"maxPrice\": {\n            \"type\": \"number\",\n            \"description\": \"Maximum price we'll pay.  Like minPrice, this takes into account the\\nutility factor when figuring out what the actual SpotPrice submitted\\nto Amazon will be\\n\"\n        },\n        \"canUseOndemand\": {\n            \"type\": \"boolean\",\n            \"description\": \"True if this worker type is allowed on demand instances.  Currently\\nignored\\n\"\n        },\n        \"canUseSpot\": {\n            \"type\": \"boolean\",\n            \"description\": \"True if this worker type is allowed spot instances.  Currently ignored\\nas all instances are Spot\\n\"\n        },\n        \"instanceTypes\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"description\": \"Instance Type configuration\",\n                \"properties\": {\n                    \"instanceType\": {\n                        \"description\": \"InstanceType name for Amazon.\\n\",\n                        \"type\": \"string\"\n                    },\n                    \"capacity\": {\n                        \"description\": \"This number represents the number of tasks that this instance type\\nis capable of running concurrently.  This is used by the provisioner\\nto know how many pending tasks to offset a pending instance of this\\ntype by\\n\",\n                        \"type\": \"number\"\n                    },\n                    \"utility\": {\n                        \"description\": \"This number is a relative measure of performance between two instance\\ntypes.  It is multiplied by the spot price from Amazon to figure out\\nwhich instance type is the cheapest one\\n\",\n                        \"type\": \"number\"\n                    },\n                    \"launchSpec\": {\n                        \"type\": \"object\",\n                        \"description\": \"LaunchSpecification entries unique to this InstanceType\\n\"\n                    },\n                    \"secrets\": {\n                        \"type\": \"object\",\n                        \"description\": \"Static Secrets unique to this InstanceType\\n\"\n                    },\n                    \"userData\": {\n                        \"type\": \"object\",\n                        \"description\": \"UserData entries unique to this InstanceType\\n\"\n                    },\n                    \"scopes\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"pattern\": \"^[ -~]*$\"\n                        },\n                        \"description\": \"Scopes which should be included for this InstanceType.  Scopes must\\nbe composed of printable ASCII characters and spaces.\\n\"\n                    }\n                },\n                \"required\": [\n                    \"instanceType\",\n                    \"capacity\",\n                    \"utility\",\n                    \"launchSpec\",\n                    \"secrets\",\n                    \"userData\",\n                    \"scopes\"\n                ],\n                \"additionalProperties\": false\n            }\n        },\n        \"regions\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"description\": \"Region configuration\",\n                \"properties\": {\n                    \"region\": {\n                        \"type\": \"string\",\n                        \"description\": \"The Amazon AWS Region being configured.  Example: us-west-1\\n\",\n                        \"enum\": [\n                            \"us-west-2\",\n                            \"us-east-1\",\n                            \"us-west-1\",\n                            \"eu-central-1\"\n                        ]\n                    },\n                    \"launchSpec\": {\n                        \"type\": \"object\",\n                        \"description\": \"LaunchSpecification entries unique to this Region\\n\",\n                        \"properties\": {\n                            \"ImageId\": {\n                                \"type\": \"string\",\n                                \"description\": \"Per-region AMI ImageId\"\n                            }\n                        },\n                        \"required\": [\n                            \"ImageId\"\n                        ]\n                    },\n                    \"secrets\": {\n                        \"type\": \"object\",\n                        \"description\": \"Static Secrets unique to this Region\\n\"\n                    },\n                    \"userData\": {\n                        \"type\": \"object\",\n                        \"description\": \"UserData entries unique to this Region\\n\"\n                    },\n                    \"scopes\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"pattern\": \"^[ -~]*$\"\n                        },\n                        \"description\": \"Scopes which should be included for this Region.  Scopes must be\\ncomposed of printable ASCII characters and spaces.\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"region\",\n                    \"launchSpec\",\n                    \"secrets\",\n                    \"userData\",\n                    \"scopes\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"launchSpec\",\n        \"userData\",\n        \"secrets\",\n        \"scopes\",\n        \"maxCapacity\",\n        \"scalingRatio\",\n        \"minPrice\",\n        \"maxPrice\",\n        \"instanceTypes\",\n        \"regions\",\n        \"description\",\n        \"owner\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/create-worker-type-request.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/get-ami-set-response.json#":                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get AMI Set Response\",\n    \"description\": \"An AMI Set from the provisioner\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the AMI set\\n\"\n        },\n        \"amis\": {\n            \"type\": \"array\",\n            \"description\": \"AMIs in this set\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"region\": {\n                        \"type\": \"string\",\n                        \"description\": \"The Amazon AWS region of the AMI set\\n\"\n                    },\n                    \"hvm\": {\n                        \"type\": \"string\",\n                        \"description\": \"The AMI that uses HVM virtualization type\\n\"\n                    },\n                    \"pv\": {\n                        \"type\": \"string\",\n                        \"description\": \"The AMI that uses PV virtualization type\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"region\",\n                    \"hvm\",\n                    \"pv\"\n                ]\n            }\n        },\n        \"lastModified\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"ISO Date string (e.g. new Date().toISOString()) which represents the time\\nwhen this AMI Set was last altered (inclusive of creation)\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"id\",\n        \"amis\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/get-ami-set-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/get-launch-specs-response.json#":            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get All Launch Specs Response\",\n    \"description\": \"All of the launch specifications for a worker type\\n\",\n    \"type\": \"object\",\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/get-launch-specs-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/get-secret-response.json#":                  "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Secret Response\",\n    \"description\": \"Secrets from the provisioner\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"data\": {\n            \"type\": \"object\",\n            \"description\": \"Free-form object which contains secrets from the worker type definition\\n\"\n        },\n        \"credentials\": {\n            \"type\": \"object\",\n            \"description\": \"Generated Temporary credentials from the Provisioner\\n\",\n            \"properties\": {\n                \"clientId\": {\n                    \"type\": \"string\"\n                },\n                \"accessToken\": {\n                    \"type\": \"string\"\n                },\n                \"certificate\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"required\": [\n                \"clientId\",\n                \"accessToken\",\n                \"certificate\"\n            ]\n        }\n    },\n    \"require\": [\n        \"data\",\n        \"credentials\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/get-secret-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-last-modified.json#":        "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Worker Type Response\",\n    \"description\": \"Get the last modified date of a workerType\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"workerType\": {\n            \"type\": \"string\",\n            \"description\": \"The ID of the workerType\\n\",\n            \"pattern\": \"^[A-Za-z0-9+/=_-]{1,22}$\"\n        },\n        \"lastModified\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"ISO Date string (e.g. new Date().toISOString()) which represents the time\\nwhen this worker type definition was last altered (inclusive of creation)\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"workerType\",\n        \"lastModified\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-last-modified.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-response.json#":             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Get Worker Type Response\",\n    \"description\": \"A worker launchSpecification and required metadata\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"workerType\": {\n            \"type\": \"string\",\n            \"description\": \"The ID of the workerType\\n\",\n            \"pattern\": \"^[A-Za-z0-9+/=_-]{1,22}$\"\n        },\n        \"launchSpec\": {\n            \"type\": \"object\",\n            \"description\": \"Launch Specification entries which are used in all regions and all instance types\\n\"\n        },\n        \"description\": {\n            \"type\": \"string\",\n            \"description\": \"A string which describes what this image is for and hints on using it\\n\"\n        },\n        \"owner\": {\n            \"type\": \"string\",\n            \"description\": \"A string which identifies the owner of this worker type\\n\"\n        },\n        \"secrets\": {\n            \"type\": \"object\",\n            \"description\": \"Static secrets entries which are used in all regions and all instance types\\n\"\n        },\n        \"userData\": {\n            \"type\": \"object\",\n            \"description\": \"UserData entries which are used in all regions and all instance types\\n\"\n        },\n        \"scopes\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\",\n                \"pattern\": \"^[ -~]*$\"\n            },\n            \"description\": \"Scopes to issue credentials to for all regions.  Scopes must be composed\\nof printable ASCII characters and spaces.\\n\"\n        },\n        \"minCapacity\": {\n            \"type\": \"number\",\n            \"description\": \"Minimum number of capacity units to be provisioned.  A capacity unit\\nis an abstract unit of capacity, where one capacity unit is roughly\\none task which should be taken off the queue\\n\"\n        },\n        \"maxCapacity\": {\n            \"type\": \"number\",\n            \"description\": \"Maximum number of capacity units to be provisioned.\\n\"\n        },\n        \"scalingRatio\": {\n            \"type\": \"number\",\n            \"description\": \"A scaling ratio of `0.2` means that the provisioner will attempt to keep\\nthe number of pending tasks around 20% of the provisioned capacity.\\nThis results in pending tasks waiting 20% of the average task execution\\ntime before starting to run.\\nA higher scaling ratio often results in better utilization and longer\\nwaiting times. For workerTypes running long tasks a short scaling ratio\\nmay be prefered, but for workerTypes running quick tasks a higher scaling\\nratio may increase utilization without major delays.\\nIf using a scaling ratio of 0, the provisioner will attempt to keep the\\ncapacity of pending spot requests equal to the number of pending tasks.\\n\"\n        },\n        \"minPrice\": {\n            \"type\": \"number\",\n            \"description\": \"Minimum price to pay for an instance.  A Price is considered to be the\\nAmazon Spot Price multiplied by the utility factor of the InstantType\\nas specified in the instanceTypes list.  For example, if the minPrice\\nis set to $0.5 and the utility factor is 2, the actual minimum bid\\nused will be $0.25\\n\"\n        },\n        \"maxPrice\": {\n            \"type\": \"number\",\n            \"description\": \"Maximum price we'll pay.  Like minPrice, this takes into account the\\nutility factor when figuring out what the actual SpotPrice submitted\\nto Amazon will be\\n\"\n        },\n        \"canUseOndemand\": {\n            \"type\": \"boolean\",\n            \"description\": \"True if this worker type is allowed on demand instances.  Currently\\nignored\\n\"\n        },\n        \"canUseSpot\": {\n            \"type\": \"boolean\",\n            \"description\": \"True if this worker type is allowed spot instances.  Currently ignored\\nas all instances are Spot\\n\"\n        },\n        \"lastModified\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"ISO Date string (e.g. new Date().toISOString()) which represents the time\\nwhen this worker type definition was last altered (inclusive of creation)\\n\"\n        },\n        \"instanceTypes\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"description\": \"Instance Type configuration\",\n                \"properties\": {\n                    \"instanceType\": {\n                        \"description\": \"InstanceType name for Amazon.\\n\",\n                        \"type\": \"string\"\n                    },\n                    \"capacity\": {\n                        \"description\": \"This number represents the number of tasks that this instance type\\nis capable of running concurrently.  This is used by the provisioner\\nto know how many pending tasks to offset a pending instance of this\\ntype by\\n\",\n                        \"type\": \"number\"\n                    },\n                    \"utility\": {\n                        \"description\": \"This number is a relative measure of performance between two instance\\ntypes.  It is multiplied by the spot price from Amazon to figure out\\nwhich instance type is the cheapest one\\n\",\n                        \"type\": \"number\"\n                    },\n                    \"launchSpec\": {\n                        \"type\": \"object\",\n                        \"description\": \"LaunchSpecification entries unique to this InstanceType\\n\"\n                    },\n                    \"secrets\": {\n                        \"type\": \"object\",\n                        \"description\": \"Static Secrets unique to this InstanceType\\n\"\n                    },\n                    \"userData\": {\n                        \"type\": \"object\",\n                        \"description\": \"UserData entries unique to this InstanceType\\n\"\n                    },\n                    \"scopes\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"pattern\": \"^[ -~]*$\"\n                        },\n                        \"description\": \"Scopes which should be included for this InstanceType.  Scopes must\\nbe composed of printable ASCII characters and spaces.\\n\"\n                    }\n                },\n                \"required\": [\n                    \"instanceType\",\n                    \"capacity\",\n                    \"utility\",\n                    \"launchSpec\",\n                    \"secrets\",\n                    \"userData\",\n                    \"scopes\"\n                ],\n                \"additionalProperties\": false\n            }\n        },\n        \"regions\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"description\": \"Region configuration\",\n                \"properties\": {\n                    \"region\": {\n                        \"type\": \"string\",\n                        \"description\": \"The Amazon AWS Region being configured.  Example: us-west-1\\n\"\n                    },\n                    \"launchSpec\": {\n                        \"type\": \"object\",\n                        \"description\": \"LaunchSpecification entries unique to this Region\\n\",\n                        \"properties\": {\n                            \"ImageId\": {\n                                \"type\": \"string\",\n                                \"description\": \"Per-region AMI ImageId\"\n                            }\n                        },\n                        \"required\": [\n                            \"ImageId\"\n                        ]\n                    },\n                    \"secrets\": {\n                        \"type\": \"object\",\n                        \"description\": \"Static Secrets unique to this Region\\n\"\n                    },\n                    \"userData\": {\n                        \"type\": \"object\",\n                        \"description\": \"UserData entries unique to this Region\\n\"\n                    },\n                    \"scopes\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"pattern\": \"^[ -~]*$\"\n                        },\n                        \"description\": \"Scopes which should be included for this Region.  Scopes must be\\ncomposed of printable ASCII characters and spaces.\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"region\",\n                    \"launchSpec\",\n                    \"secrets\",\n                    \"userData\",\n                    \"scopes\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"workerType\",\n        \"launchSpec\",\n        \"userData\",\n        \"secrets\",\n        \"scopes\",\n        \"minCapacity\",\n        \"maxCapacity\",\n        \"scalingRatio\",\n        \"minPrice\",\n        \"maxPrice\",\n        \"lastModified\",\n        \"instanceTypes\",\n        \"regions\",\n        \"description\",\n        \"owner\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/get-worker-type-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/list-ami-sets-response.json#":               "{\n    \"title\": \"List AMI sets\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"string\"\n    },\n    \"uniqueItems\": true,\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/list-ami-sets-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-response.json#":           "{\n    \"title\": \"List Worker Types\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"string\"\n    },\n    \"uniqueItems\": true,\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-response.json#\"\n}",
	"http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-summaries-response.json#": "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Worker Type Summaries Response\",\n    \"type\": \"array\",\n    \"uniqueItems\": true,\n    \"items\": {\n        \"$ref\": \"http://schemas.taskcluster.net/aws-provisioner/v1/worker-type-summary.json#\"\n    },\n    \"id\": \"http://schemas.taskcluster.net/aws-provisioner/v1/list-worker-types-summaries-response.json#\"\n}",
	"http://schemas.taskcluster.net/github/v1/build-list.json#":                                    "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Builds\",\n    \"description\": \"A paginated list of builds\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"continuationToken\": {\n            \"type\": \"string\",\n            \"description\": \"Passed back from Azure to allow us to page through long result sets.\"\n        },\n        \"builds\": {\n            \"type\": \"array\",\n            \"description\": \"A simple list of builds.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"organization\": {\n                        \"type\": \"string\",\n                        \"minLength\": 1,\n                        \"maxLength\": 100,\n                        \"pattern\": \"^([a-zA-Z0-9-_%]*)$\",\n                        \"description\": \"Github organization associated with the build.\"\n                    },\n                    \"repository\": {\n                        \"type\": \"string\",\n                        \"minLength\": 1,\n                        \"maxLength\": 100,\n                        \"pattern\": \"^([a-zA-Z0-9-_%]*)$\",\n                        \"description\": \"Github repository associated with the build.\"\n                    },\n                    \"sha\": {\n                        \"type\": \"string\",\n                        \"minLength\": 40,\n                        \"maxLength\": 40,\n                        \"description\": \"Github revision associated with the build.\"\n                    },\n                    \"state\": {\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"pending\",\n                            \"success\",\n                            \"error\",\n                            \"failure\"\n                        ],\n                        \"description\": \"Github status associated with the build.\"\n                    },\n                    \"taskGroupId\": {\n                        \"type\": \"string\",\n                        \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\",\n                        \"description\": \"Taskcluster task-group associated with the build.\"\n                    },\n                    \"eventType\": {\n                        \"type\": \"string\",\n                        \"description\": \"Type of Github event that triggered the build (i.e. push, pull_request.opened).\"\n                    },\n                    \"eventId\": {\n                        \"type\": \"string\",\n                        \"description\": \"The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\\n\",\n                        \"oneOf\": [\n                            {\n                                \"pattern\": \"^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$\"\n                            },\n                            {\n                                \"pattern\": \"Unknown\"\n                            }\n                        ]\n                    },\n                    \"created\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The initial creation time of the build. This is when it became pending.\\n\"\n                    },\n                    \"updated\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"The last updated of the build. If it is done, this is when it finished.\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"organization\",\n                    \"repository\",\n                    \"sha\",\n                    \"state\",\n                    \"taskGroupId\",\n                    \"eventType\",\n                    \"eventId\",\n                    \"created\",\n                    \"updated\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"builds\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/github/v1/build-list.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/create-hook-request.json":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook creation request\",\n    \"description\": \"Definition of a hook that can create tasks at defined times.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"metadata\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of the hook\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Long-form of the hook's purpose and behavior\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"Email of the person or group responsible for this hook.\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"emailOnError\": {\n                    \"title\": \"Email on error\",\n                    \"description\": \"Whether to email the owner on an error creating the task.\",\n                    \"type\": \"boolean\",\n                    \"default\": true\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\"\n            ]\n        },\n        \"schedule\": {\n            \"description\": \"Definition of the times at which a hook will result in creation of a task.\\nIf several patterns are specified, tasks will be created at any time\\nspecified by one or more patterns.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Cron Pattern\",\n                \"type\": \"string\",\n                \"description\": \"Cron-like specification for when tasks should be created.  The pattern is\\nparsed in a UTC context.\\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\\nNote that tasks may not be created at exactly the time specified.\\n\"\n            },\n            \"uniqueItems\": true,\n            \"default\": []\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Task expiration, time at which task definition and status is deleted. Notice that all artifacts for the must have an expiration that is no later than this. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n            \"type\": \"string\",\n            \"default\": \"3 months\"\n        },\n        \"deadline\": {\n            \"title\": \"Deadline\",\n            \"description\": \"Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline. Note, deadline cannot be more than 5 days into the future. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n            \"type\": \"string\",\n            \"default\": \"1 day\"\n        },\n        \"task\": {\n            \"$ref\": \"http://schemas.taskcluster.net/hooks/v1/task-template.json\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"metadata\",\n        \"task\",\n        \"deadline\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/create-hook-request.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/hook-definition.json":                                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook definition\",\n    \"description\": \"Definition of a hook that will create tasks when defined events occur.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"hookGroupId\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"hookId\": {\n            \"type\": \"string\",\n            \"maxLength\": 255\n        },\n        \"metadata\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of the hook\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Long-form of the hook's purpose and behavior\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"Email of the person or group responsible for this hook.\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"emailOnError\": {\n                    \"title\": \"Email on error\",\n                    \"description\": \"Whether to email the owner on an error creating the task.\",\n                    \"type\": \"boolean\",\n                    \"default\": true\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\"\n            ]\n        },\n        \"schedule\": {\n            \"description\": \"Definition of the times at which a hook will result in creation of a task.\\nIf several patterns are specified, tasks will be created at any time\\nspecified by one or more patterns.  Note that tasks may not be created\\nat exactly the time specified.\\n                    {$ref: \\\"http://schemas.taskcluster.net/hooks/v1/schedule.json\\\"}\\n\"\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Task expiration, time at which task definition and status is deleted. Notice that all artifacts for the must have an expiration that is no later than this. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n            \"type\": \"string\",\n            \"default\": \"3 months\"\n        },\n        \"deadline\": {\n            \"title\": \"Deadline\",\n            \"description\": \"Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline. Note, deadline cannot be more than 5 days into the future. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n            \"type\": \"string\",\n            \"default\": \"1 day\"\n        },\n        \"task\": {\n            \"$ref\": \"http://schemas.taskcluster.net/hooks/v1/task-template.json\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"hookGroupId\",\n        \"hookId\",\n        \"metadata\",\n        \"task\",\n        \"schedule\",\n        \"expires\",\n        \"deadline\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/hook-definition.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/hook-schedule.json":                                   "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook schedule response\",\n    \"description\": \"A description of when a hook's task will be created, and the next scheduled time\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"schedule\": {\n            \"$ref\": \"http://schemas.taskcluster.net/hooks/v1/schedule.json\"\n        },\n        \"nextScheduledDate\": {\n            \"description\": \"The next time this hook's task is scheduled to be created. This property\\nis only present if there is a scheduled next time. Some hooks don't have\\nany schedules.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"schedule\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/hook-schedule.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/hook-status.json":                                     "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook status response\",\n    \"description\": \"A snapshot of the current status of a hook.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"lastFire\": {\n            \"description\": \"Information about the last time this hook fired.  This property is only present\\nif the hook has fired at least once.\\n\",\n            \"type\": \"object\",\n            \"oneOf\": [\n                {\n                    \"title\": \"Successful Fire\",\n                    \"description\": \"Information about a successful firing of the hook\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"result\": {\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"success\"\n                            ]\n                        },\n                        \"taskId\": {\n                            \"description\": \"The task created\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        },\n                        \"time\": {\n                            \"description\": \"The time the task was created.  This will not necessarily match `task.created`.\\n\",\n                            \"type\": \"string\",\n                            \"format\": \"date-time\"\n                        }\n                    },\n                    \"additionalProperties\": false,\n                    \"required\": [\n                        \"result\",\n                        \"taskId\",\n                        \"time\"\n                    ]\n                },\n                {\n                    \"title\": \"Failed Fire\",\n                    \"description\": \"Information about an unsuccessful firing of the hook\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"result\": {\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"error\"\n                            ]\n                        },\n                        \"error\": {\n                            \"description\": \"The error that occurred when firing the task.  This is typically,\\nbut not always, an API error message.\\n\",\n                            \"type\": \"object\"\n                        },\n                        \"time\": {\n                            \"description\": \"The time the task was created.  This will not necessarily match `task.created`.\\n\",\n                            \"type\": \"string\",\n                            \"format\": \"date-time\"\n                        }\n                    },\n                    \"additionalProperties\": false,\n                    \"required\": [\n                        \"result\",\n                        \"error\",\n                        \"time\"\n                    ]\n                },\n                {\n                    \"title\": \"No Fire\",\n                    \"description\": \"Information about no firing of the hook (e.g., a new hook)\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"result\": {\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \"no-fire\"\n                            ]\n                        }\n                    },\n                    \"additionalProperties\": false,\n                    \"required\": [\n                        \"result\"\n                    ]\n                }\n            ]\n        },\n        \"nextScheduledDate\": {\n            \"description\": \"The next time this hook's task is scheduled to be created. This property\\nis only present if there is a scheduled next time. Some hooks don't have\\nany schedules.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"lastFire\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/hook-status.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/list-hook-groups-response.json":                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook groups\",\n    \"description\": \"List of `hookGroupIds`.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"groups\": {\n            \"title\": \"Groups\",\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"string\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"groups\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/list-hook-groups-response.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/list-hooks-response.json":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Hook list\",\n    \"description\": \"List of hooks\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"hooks\": {\n            \"title\": \"Hooks\",\n            \"type\": \"array\",\n            \"items\": {\n                \"$ref\": \"http://schemas.taskcluster.net/hooks/v1/hook-definition.json\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"hooks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/list-hooks-response.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/task-status.json":                                     "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Status Structure\",\n    \"description\": \"A representation of **task status** as known by the queue\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"taskId\": {\n                    \"title\": \"Task Identifier\",\n                    \"description\": \"Unique task identifier, this is UUID encoded as\\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\\nstripped of `=` padding.\\n\",\n                    \"type\": \"string\",\n                    \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                },\n                \"provisionerId\": {\n                    \"title\": \"Provisioner Id\",\n                    \"description\": \"Unique identifier for the provisioner that this task must be scheduled on\\n\",\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"maxLength\": 22,\n                    \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                },\n                \"workerType\": {\n                    \"title\": \"Worker Type\",\n                    \"description\": \"Identifier for worker type within the specified provisioner\\n\",\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"maxLength\": 22,\n                    \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                },\n                \"schedulerId\": {\n                    \"title\": \"Scheduler Identifier\",\n                    \"description\": \"Identifier for the scheduler that _defined_ this task.\\n\",\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"maxLength\": 22,\n                    \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                },\n                \"taskGroupId\": {\n                    \"title\": \"Task-Group Identifier\",\n                    \"description\": \"Identifier for a group of tasks scheduled together with this task, by\\nscheduler identified by `schedulerId`. For tasks scheduled by the\\ntask-graph scheduler, this is the `taskGraphId`.\\n\",\n                    \"type\": \"string\",\n                    \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                },\n                \"deadline\": {\n                    \"title\": \"Deadline\",\n                    \"description\": \"Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline. Note, deadline cannot be more than 5 days into the future. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n                    \"type\": \"string\",\n                    \"default\": \"1 day\"\n                },\n                \"expires\": {\n                    \"title\": \"Expiration\",\n                    \"description\": \"Task expiration, time at which task definition and status is deleted. Notice that all artifacts for the must have an expiration that is no later than this. Must be specified as `A years B months C days D hours E minutes F seconds`, though you may leave out zeros. For more details see: `taskcluster.fromNow` in [taskcluster-client](https://github.com/taskcluster/taskcluster-client)\\n\",\n                    \"type\": \"string\",\n                    \"default\": \"3 months\"\n                },\n                \"retriesLeft\": {\n                    \"title\": \"Retries Left\",\n                    \"description\": \"Number of retries left for the task in case of infrastructure issues\\n\",\n                    \"type\": \"integer\",\n                    \"minimum\": 0,\n                    \"maximum\": 999\n                },\n                \"state\": {\n                    \"title\": \"State\",\n                    \"description\": \"State of this task. This is just an auxiliary property derived from state\\nof latests run, or `unscheduled` if none.\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"unscheduled\",\n                        \"pending\",\n                        \"running\",\n                        \"completed\",\n                        \"failed\",\n                        \"exception\"\n                    ]\n                },\n                \"runs\": {\n                    \"title\": \"List of Runs\",\n                    \"description\": \"List of runs, ordered so that index `i` has `runId == i`\\n\",\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"title\": \"Run Information\",\n                        \"description\": \"JSON object with information about a run\\n\",\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"runId\": {\n                                \"title\": \"Run Identifier\",\n                                \"description\": \"Id of this task run, `run-id`s always starts from `0`\\n\",\n                                \"type\": \"integer\",\n                                \"minimum\": 0,\n                                \"maximum\": 1000\n                            },\n                            \"state\": {\n                                \"title\": \"Run State\",\n                                \"description\": \"State of this run\\n\",\n                                \"type\": \"string\",\n                                \"enum\": [\n                                    \"pending\",\n                                    \"running\",\n                                    \"completed\",\n                                    \"failed\",\n                                    \"exception\"\n                                ]\n                            },\n                            \"reasonCreated\": {\n                                \"title\": \"Reason Created\",\n                                \"description\": \"Reason for the creation of this run,\\n**more reasons may be added in the future**.\\n\",\n                                \"type\": \"string\",\n                                \"enum\": [\n                                    \"scheduled\",\n                                    \"retry\",\n                                    \"task-retry\",\n                                    \"rerun\",\n                                    \"exception\"\n                                ]\n                            },\n                            \"reasonResolved\": {\n                                \"title\": \"Reason Resolved\",\n                                \"description\": \"Reason that run was resolved, this is mainly\\nuseful for runs resolved as `exception`.\\nNote, **more reasons may be added in the future**, also this\\nproperty is only available after the run is resolved.\\n\",\n                                \"type\": \"string\",\n                                \"enum\": [\n                                    \"completed\",\n                                    \"failed\",\n                                    \"deadline-exceeded\",\n                                    \"canceled\",\n                                    \"superseded\",\n                                    \"claim-expired\",\n                                    \"worker-shutdown\",\n                                    \"malformed-payload\",\n                                    \"resource-unavailable\",\n                                    \"internal-error\",\n                                    \"intermittent-task\"\n                                ]\n                            },\n                            \"workerGroup\": {\n                                \"title\": \"Worker Group\",\n                                \"description\": \"Identifier for group that worker who executes this run is a part of,\\nthis identifier is mainly used for efficient routing.\\nNote, this property is only present after the run is claimed.\\n\",\n                                \"type\": \"string\",\n                                \"minLength\": 1,\n                                \"maxLength\": 22,\n                                \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                            },\n                            \"workerId\": {\n                                \"title\": \"Worker Identifier\",\n                                \"description\": \"Identifier for worker evaluating this run within given\\n`workerGroup`. Note, this property is only available after the run\\nhas been claimed.\\n\",\n                                \"type\": \"string\",\n                                \"minLength\": 1,\n                                \"maxLength\": 22,\n                                \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                            },\n                            \"takenUntil\": {\n                                \"title\": \"Taken Until\",\n                                \"description\": \"Time at which the run expires and is resolved as `failed`, if the\\nrun isn't reclaimed. Note, only present after the run has been\\nclaimed.\\n\",\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                            },\n                            \"scheduled\": {\n                                \"title\": \"Scheduled\",\n                                \"description\": \"Date-time at which this run was scheduled, ie. when the run was\\ncreated in state `pending`.\\n\",\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                            },\n                            \"started\": {\n                                \"title\": \"Started\",\n                                \"description\": \"Date-time at which this run was claimed, ie. when the run changed\\nstate from `pending` to `running`. This property is only present\\nafter the run has been claimed.\\n\",\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                            },\n                            \"resolved\": {\n                                \"title\": \"Resolved\",\n                                \"description\": \"Date-time at which this run was resolved, ie. when the run changed\\nstate from `running` to either `completed`, `failed` or `exception`.\\nThis property is only present after the run as been resolved.\\n\",\n                                \"type\": \"string\",\n                                \"format\": \"date-time\"\n                            }\n                        },\n                        \"additionalProperties\": false,\n                        \"required\": [\n                            \"runId\",\n                            \"state\",\n                            \"reasonCreated\",\n                            \"scheduled\"\n                        ]\n                    }\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"taskId\",\n                \"provisionerId\",\n                \"workerType\",\n                \"schedulerId\",\n                \"taskGroupId\",\n                \"deadline\",\n                \"expires\",\n                \"retriesLeft\",\n                \"state\",\n                \"runs\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/task-status.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/trigger-payload.json":                                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"trigger payload\",\n    \"description\": \"Trigger payload\\n\",\n    \"type\": \"object\",\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/trigger-payload.json#\"\n}",
	"http://schemas.taskcluster.net/hooks/v1/trigger-token-response.json":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"trigger token response\",\n    \"description\": \"Secret token for a trigger\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"token\": {\n            \"title\": \"Token\",\n            \"type\": \"string\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"token\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/hooks/v1/trigger-token-response.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/indexed-task-response.json#":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Indexed Task Response\",\n    \"description\": \"Representation of an indexed task.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"namespace\": {\n            \"title\": \"Namespace\",\n            \"description\": \"Namespace of the indexed task, used to find the indexed task in the index.\\n\",\n            \"type\": \"string\",\n            \"maxLength\": 255\n        },\n        \"taskId\": {\n            \"title\": \"Task Identifier\",\n            \"description\": \"Unique task identifier, this is UUID encoded as\\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\\nstripped of `=` padding.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"rank\": {\n            \"title\": \"Rank\",\n            \"description\": \"If multiple tasks are indexed with the same `namespace` the task with the\\nhighest `rank` will be stored and returned in later requests. If two tasks\\nhas the same `rank` the latest task will be stored.\\n\",\n            \"type\": \"number\"\n        },\n        \"data\": {\n            \"title\": \"Task Specific Data\",\n            \"description\": \"Data that was reported with the task. This is an arbitrary JSON object.\\n\",\n            \"type\": \"object\"\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Date at which this entry expires from the task index.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"namespace\",\n        \"taskId\",\n        \"rank\",\n        \"data\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/index/v1/indexed-task-response.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/insert-task-request.json#":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Insert Task Request\",\n    \"description\": \"Representation of an a task to be indexed.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"taskId\": {\n            \"title\": \"Task Identifier\",\n            \"description\": \"Unique task identifier, this is UUID encoded as\\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\\nstripped of `=` padding.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"rank\": {\n            \"title\": \"Rank\",\n            \"description\": \"If multiple tasks are indexed with the same `namespace` the task with the\\nhighest `rank` will be stored and returned in later requests. If two tasks\\nhas the same `rank` the latest task will be stored.\\n\",\n            \"type\": \"number\"\n        },\n        \"data\": {\n            \"title\": \"Task Specific Data\",\n            \"description\": \"This is an arbitrary JSON object. Feel free to put whatever data you want\\nhere, but do limit it, you'll get errors if you store more than 32KB.\\nSo stay well, below that limit.\\n\",\n            \"type\": \"object\"\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Date at which this entry expires from the task index.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"taskId\",\n        \"rank\",\n        \"data\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/index/v1/insert-task-request.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/list-namespaces-request.json#":                        "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Namespaces Request\",\n    \"description\": \"Request to list namespaces within a given namespace.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"limit\": {\n            \"title\": \"Result limit\",\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 1000,\n            \"default\": 1000,\n            \"description\": \"Maximum number of results per page. If there are more results than this\\na continuation token will be return.\\n\"\n        },\n        \"continuationToken\": {\n            \"title\": \"Continuation Token\",\n            \"type\": \"string\",\n            \"description\": \"A continuation token previously returned in a response to this list\\nrequest. This property is optional and should not be provided for first\\nrequests.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"id\": \"http://schemas.taskcluster.net/index/v1/list-namespaces-request.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/list-namespaces-response.json#":                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Namespaces Response\",\n    \"description\": \"Response from a request to list namespaces within a given namespace.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"namespaces\": {\n            \"title\": \"Namespaces\",\n            \"description\": \"List of namespaces.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Namespace\",\n                \"description\": \"Representation of a namespace that contains indexed tasks.\\n\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"namespace\": {\n                        \"title\": \"Namespace\",\n                        \"description\": \"Fully qualified name of the namespace, you can use this to list\\nnamespaces or tasks under this namespace.\\n\",\n                        \"type\": \"string\",\n                        \"maxLength\": 255\n                    },\n                    \"name\": {\n                        \"title\": \"Name\",\n                        \"type\": \"string\",\n                        \"description\": \"Name of namespace within it's parent namespace.\\n\"\n                    },\n                    \"expires\": {\n                        \"title\": \"Expiration\",\n                        \"description\": \"Date at which this entry, and by implication all entries below it,\\nexpires from the task index.\\n\",\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"namespace\",\n                    \"name\",\n                    \"expires\"\n                ]\n            }\n        },\n        \"continuationToken\": {\n            \"title\": \"Continuation Token\",\n            \"type\": \"string\",\n            \"description\": \"A continuation token is returned if there are more results than listed\\nhere. You can optionally provide the token in the request payload to\\nload the additional results.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"namespaces\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/index/v1/list-namespaces-response.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/list-tasks-request.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Tasks Request\",\n    \"description\": \"Request to list tasks within a given namespace.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"limit\": {\n            \"title\": \"Result limit\",\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 1000,\n            \"default\": 1000,\n            \"description\": \"Maximum number of results per page. If there are more results than this\\na continuation token will be return.\\n\"\n        },\n        \"continuationToken\": {\n            \"title\": \"Continuation Token\",\n            \"type\": \"string\",\n            \"description\": \"A continuation token previously returned in a response to this list\\nrequest. This property is optional and should not be provided for first\\nrequests.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"id\": \"http://schemas.taskcluster.net/index/v1/list-tasks-request.json#\"\n}",
	"http://schemas.taskcluster.net/index/v1/list-tasks-response.json#":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Tasks Response\",\n    \"description\": \"Representation of an indexed task.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"tasks\": {\n            \"title\": \"Tasks\",\n            \"description\": \"List of tasks.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task\",\n                \"description\": \"Representation of a task.\\n\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"namespace\": {\n                        \"title\": \"Namespace\",\n                        \"description\": \"Namespace of the indexed task, used to find the indexed task in the\\nindex.\\n\",\n                        \"type\": \"string\",\n                        \"maxLength\": 255\n                    },\n                    \"taskId\": {\n                        \"title\": \"Task Identifier\",\n                        \"description\": \"Unique task identifier, this is UUID encoded as\\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\\nstripped of `=` padding.\\n\",\n                        \"type\": \"string\",\n                        \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                    },\n                    \"rank\": {\n                        \"title\": \"Rank\",\n                        \"description\": \"If multiple tasks are indexed with the same `namespace` the task\\nwith the highest `rank` will be stored and returned in later\\nrequests. If two tasks has the same `rank` the latest task will be\\nstored.\\n\",\n                        \"type\": \"number\"\n                    },\n                    \"data\": {\n                        \"title\": \"Task Specific Data\",\n                        \"description\": \"Data that was reported with the task. This is an arbitrary JSON\\nobject.\\n\",\n                        \"type\": \"object\"\n                    },\n                    \"expires\": {\n                        \"title\": \"Expiration\",\n                        \"description\": \"Date at which this entry expires from the task index.\\n\",\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"namespace\",\n                    \"taskId\",\n                    \"rank\",\n                    \"data\",\n                    \"expires\"\n                ]\n            }\n        },\n        \"continuationToken\": {\n            \"title\": \"Continuation Token\",\n            \"type\": \"string\",\n            \"description\": \"A continuation token is returned if there are more results than listed\\nhere. You can optionally provide the token in the request payload to\\nload the additional results.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"tasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/index/v1/list-tasks-response.json#\"\n}",
	"http://schemas.taskcluster.net/login/v1/credentials-response.json":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Credentials Response\",\n    \"description\": \"A response containing temporary credentials.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"clientId\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9@/:._-]+$\"\n        },\n        \"accessToken\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-zA-Z0-9_-]{22,66}$\"\n        },\n        \"certificate\": {\n            \"type\": \"string\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"clientId\",\n        \"accessToken\",\n        \"certificate\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/login/v1/credentials-response.json#\"\n}",
	"http://schemas.taskcluster.net/login/v1/persona-request.json":                                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Persona Assertion Request\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"assertion\": {\n            \"description\": \"The Persona assertion from `navigator.id.get`\\n\",\n            \"type\": \"string\"\n        },\n        \"audience\": {\n            \"description\": \"The audience against which to verify the assertion, in the format\\n`https://site.com:443`.  This must be from a whitelist of sites\\nconfigured in the login service.\\n\",\n            \"type\": \"string\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"assertion\",\n        \"audience\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/login/v1/persona-request.json#\"\n}",
	"http://schemas.taskcluster.net/notify/v1/email-request.json":                                  "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Send Email Request\",\n    \"description\": \"Request to send an email\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"address\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"E-mail address to which the message should be sent\\n\"\n        },\n        \"subject\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"minLength\": 1,\n            \"description\": \"Subject line of the e-mail, this is plain-text\\n\"\n        },\n        \"content\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 102400,\n            \"description\": \"Content of the e-mail as **markdown**, will be rendered to HTML before\\nthe email is sent. Notice that markdown allows for a few HTML tags, but\\nwon't allow inclusion of script tags and other unpleasantries.\\n\"\n        },\n        \"link\": {\n            \"type\": \"object\",\n            \"description\": \"Optional link that can be added as a button to the email.\\n\",\n            \"properties\": {\n                \"text\": {\n                    \"type\": \"string\",\n                    \"maxLength\": 40,\n                    \"minLength\": 1,\n                    \"description\": \"Text to display on link.\\n\"\n                },\n                \"href\": {\n                    \"type\": \"string\",\n                    \"maxLength\": 1024,\n                    \"minLength\": 1,\n                    \"format\": \"uri\",\n                    \"description\": \"Where the link should point to.\\n\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"text\",\n                \"href\"\n            ]\n        },\n        \"replyTo\": {\n            \"type\": \"string\",\n            \"format\": \"email\",\n            \"description\": \"Reply-to e-mail (this property is optional)\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"address\",\n        \"subject\",\n        \"content\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/notify/v1/email-request.json#\"\n}",
	"http://schemas.taskcluster.net/notify/v1/irc-request.json":                                    "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Post IRC Message Request\",\n    \"description\": \"Request to post a message on IRC.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"channel\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[#&][^ ,\\\\u0007]{1,199}$\",\n            \"description\": \"Channel to post the message in. Please note that you **must** supply\\neither `user` or `channel`, you cannot supply both.\\n\"\n        },\n        \"user\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z\\\\[\\\\]\\\\\\\\~_\\\\^{|}][A-Za-z0-9\\\\-\\\\[\\\\]\\\\\\\\~_\\\\^{|}]{0,254}$\",\n            \"maxLength\": 255,\n            \"minLength\": 1,\n            \"description\": \"User to post the message to. Please note that you **must** supply\\neither `user` or `channel`, you cannot supply both.\\n\"\n        },\n        \"message\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 510,\n            \"description\": \"IRC message to send as plain text.\\n\"\n        }\n    },\n    \"maxProperties\": 2,\n    \"additionalProperties\": false,\n    \"required\": [\n        \"message\"\n    ],\n    \"oneOf\": [\n        {\n            \"required\": [\n                \"channel\"\n            ]\n        },\n        {\n            \"required\": [\n                \"user\"\n            ]\n        }\n    ],\n    \"id\": \"http://schemas.taskcluster.net/notify/v1/irc-request.json#\"\n}",
	"http://schemas.taskcluster.net/notify/v1/pulse-request.json":                                  "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Post Pulse Message Request\",\n    \"description\": \"Request to post a message on pulse.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"routingKey\": {\n            \"type\": \"string\",\n            \"maxLength\": 255,\n            \"description\": \"Routing-key to use when posting the message.\\n\"\n        },\n        \"message\": {\n            \"type\": \"object\",\n            \"description\": \"IRC message to send as plain text.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"routingKey\",\n        \"message\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/notify/v1/pulse-request.json#\"\n}",
	"http://schemas.taskcluster.net/pulse/v1/exchanges-response.json":                              "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"RabbitMQ Exchanges\",\n    \"description\": \"An array of RabbitMQ exchanges containing the details of RabbitMQ exchanges\\n\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"title\": \"Exchange\",\n        \"properties\": {\n            \"name\": {\n                \"type\": \"string\",\n                \"title\": \"Name\",\n                \"description\": \"The exchange's name\"\n            },\n            \"vhost\": {\n                \"type\": \"string\",\n                \"title\": \"Virtual Host\",\n                \"description\": \"The exchange's vhost\"\n            },\n            \"type\": {\n                \"type\": \"string\",\n                \"title\": \"Type\",\n                \"description\": \"The exchange's type\"\n            },\n            \"durable\": {\n                \"type\": \"boolean\",\n                \"title\": \"Durable\",\n                \"description\": \"Whether or not the exchange survives broker restart\"\n            },\n            \"auto-delete\": {\n                \"type\": \"boolean\",\n                \"title\": \"Auto-Delete\",\n                \"description\": \"Whether or not the exchange deletes when all queues are finished using it\"\n            },\n            \"arguments\": {\n                \"type\": \"object\",\n                \"title\": \"Arguments\",\n                \"properties\": {}\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"name\",\n        \"vhost\",\n        \"type\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/pulse/v1/exchanges-response.json#\"\n}",
	"http://schemas.taskcluster.net/pulse/v1/namespace-request.json":                               "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Namespace Creation Request\",\n    \"description\": \"Namespace creation request\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contact\": {\n            \"type\": \"object\",\n            \"title\": \"Contact Information\",\n            \"description\": \"The contact information which will be handed off to the notification service\",\n            \"oneOf\": [\n                {\n                    \"$ref\": \"http://schemas.taskcluster.net/pulse/v1/irc-request.json#\"\n                },\n                {\n                    \"$ref\": \"http://schemas.taskcluster.net/pulse/v1/email-request.json#\"\n                }\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"contact\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/pulse/v1/namespace-request.json#\"\n}",
	"http://schemas.taskcluster.net/pulse/v1/namespace-response.json":                              "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Namespace Creation Response\",\n    \"description\": \"Namespace creation response\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"namespace\": {\n            \"type\": \"string\",\n            \"title\": \"Namespace\",\n            \"description\": \"The name of the namespace created\"\n        },\n        \"username\": {\n            \"type\": \"string\",\n            \"title\": \"Username\",\n            \"description\": \"The username created for authentication\"\n        },\n        \"password\": {\n            \"type\": \"string\",\n            \"title\": \"Password\",\n            \"description\": \"The password created for authentication\"\n        },\n        \"contact\": {\n            \"type\": \"object\",\n            \"title\": \"Contact Information\",\n            \"description\": \"The contact information which will be handed off to the notification service\",\n            \"oneOf\": [\n                {\n                    \"$ref\": \"http://schemas.taskcluster.net/pulse/v1/irc-request.json#\"\n                },\n                {\n                    \"$ref\": \"http://schemas.taskcluster.net/pulse/v1/email-request.json#\"\n                }\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"namespace\",\n        \"username\",\n        \"password\",\n        \"contact\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/pulse/v1/namespace-response.json#\"\n}",
	"http://schemas.taskcluster.net/pulse/v1/rabbit-overview.json":                                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Rabbit Overview Response\",\n    \"description\": \"Rabbit overview response\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"rabbitmq_version\": {\n            \"type\": \"string\",\n            \"title\": \"RabbitMQ Version\",\n            \"description\": \"The version of RabbitMQ\",\n            \"minLength\": 1\n        },\n        \"cluster_name\": {\n            \"type\": \"string\",\n            \"title\": \"Cluster Name\",\n            \"description\": \"The name of the cluster\",\n            \"minLength\": 1\n        },\n        \"management_version\": {\n            \"type\": \"string\",\n            \"title\": \"Management Version\",\n            \"description\": \"The version of the management\",\n            \"minLength\": 1\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"rabbitmq_version\",\n        \"cluster_name\",\n        \"management_version\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/pulse/v1/rabbit-overview.json#\"\n}",
	"http://schemas.taskcluster.net/purge-cache/v1/all-purge-cache-request-list.json#":             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Open All Purge Requests List\",\n    \"description\": \"A list of currently open purge-cache requests. Should not be used by workers.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"continuationToken\": {\n            \"type\": \"string\",\n            \"description\": \"Passed back from Azure to allow us to page through long result sets.\"\n        },\n        \"requests\": {\n            \"type\": \"array\",\n            \"description\": \"A simple list of purge-cache requests.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"provisionerId\": {\n                        \"type\": \"string\",\n                        \"description\": \"ProvisionerId associated with the workerType.\"\n                    },\n                    \"workerType\": {\n                        \"type\": \"string\",\n                        \"description\": \"Workertype cache exists on.\"\n                    },\n                    \"cacheName\": {\n                        \"type\": \"string\",\n                        \"description\": \"Name of cache to purge.\"\n                    },\n                    \"before\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"All caches that match this provisionerId, workerType, and cacheName must be destroyed if they were created _before_ this time.\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"provisionerId\",\n                    \"workerType\",\n                    \"cacheName\",\n                    \"before\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"requests\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/purge-cache/v1/all-purge-cache-request-list.json#\"\n}",
	"http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request-list.json#":                 "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Open Purge Request List\",\n    \"description\": \"A list of currently open purge-cache requests.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"cacheHit\": {\n            \"type\": \"boolean\",\n            \"description\": \"True if the cache has been used in this request.\"\n        },\n        \"requests\": {\n            \"type\": \"array\",\n            \"description\": \"A simple list of purge-cache requests.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"provisionerId\": {\n                        \"type\": \"string\",\n                        \"description\": \"ProvisionerId associated with the workerType.\"\n                    },\n                    \"workerType\": {\n                        \"type\": \"string\",\n                        \"description\": \"Workertype cache exists on.\"\n                    },\n                    \"cacheName\": {\n                        \"type\": \"string\",\n                        \"description\": \"Name of cache to purge.\"\n                    },\n                    \"before\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"All caches that match this provisionerId, workerType, and cacheName must be destroyed if they were created _before_ this time.\\n\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"provisionerId\",\n                    \"workerType\",\n                    \"cacheName\",\n                    \"before\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"requests\",\n        \"cacheHit\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request-list.json#\"\n}",
	"http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request.json#":                      "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Purge Cache Request\",\n    \"description\": \"Request that a message be published to purge a specific cache.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"cacheName\": {\n            \"type\": \"string\",\n            \"description\": \"Name of cache to purge. Notice that if a `workerType` have multiple kinds\\nof caches (with independent names), it should purge all caches identified\\nby `cacheName` regardless of cache type.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"cacheName\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/purge-cache/v1/purge-cache-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/claim-work-request.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Claim Work Request\",\n    \"description\": \"Request to claim a task for a worker to process.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"workerGroup\": {\n            \"description\": \"Identifier for group that worker claiming the task is a part of.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerId\": {\n            \"description\": \"Identifier for worker within the given workerGroup\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"tasks\": {\n            \"description\": \"Number of tasks to attempt to claim.\\n\",\n            \"default\": 1,\n            \"type\": \"integer\",\n            \"minimum\": 1,\n            \"maximum\": 32\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"workerGroup\",\n        \"workerId\",\n        \"tasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/claim-work-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/claim-work-response.json#":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Claim Work Response\",\n    \"description\": \"Response to an attempt to claim tasks for a worker to process.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"tasks\": {\n            \"type\": \"array\",\n            \"description\": \"List of task claims, may be empty if no tasks was claimed, in which case\\nthe worker should sleep a tiny bit before polling again.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n                    },\n                    \"runId\": {\n                        \"description\": \"`run-id` assigned to this run of the task\\n\",\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 1000\n                    },\n                    \"workerGroup\": {\n                        \"description\": \"Identifier for the worker-group within which this run started.\\n\",\n                        \"type\": \"string\",\n                        \"minLength\": 1,\n                        \"maxLength\": 22,\n                        \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                    },\n                    \"workerId\": {\n                        \"description\": \"Identifier for the worker executing this run.\\n\",\n                        \"type\": \"string\",\n                        \"minLength\": 1,\n                        \"maxLength\": 22,\n                        \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n                    },\n                    \"takenUntil\": {\n                        \"description\": \"Time at which the run expires and is resolved as `exception`,\\nwith reason `claim-expired` if the run haven't been reclaimed.\\n\",\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                    },\n                    \"task\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task.json#\"\n                    },\n                    \"credentials\": {\n                        \"type\": \"object\",\n                        \"description\": \"Temporary credentials granting `task.scopes` and the scope:\\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\\nthe task, upload artifacts and report task resolution.\\n\\nThe temporary credentials are set to expire after `takenUntil`. They\\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\\ncoming close `takenUntil` won't have problems even if there is a little\\nclock drift.\\n\\nWorkers should use these credentials when making requests on behalf of\\na task. This includes requests to create artifacts, reclaiming the task\\nreporting the task `completed`, `failed` or `exception`.\\n\\nNote, a new set of temporary credentials is issued when the worker\\nreclaims the task.\\n\",\n                        \"properties\": {\n                            \"clientId\": {\n                                \"type\": \"string\",\n                                \"minLength\": 1,\n                                \"description\": \"The `clientId` for the temporary credentials.\\n\"\n                            },\n                            \"accessToken\": {\n                                \"type\": \"string\",\n                                \"minLength\": 1,\n                                \"description\": \"The `accessToken` for the temporary credentials.\\n\"\n                            },\n                            \"certificate\": {\n                                \"type\": \"string\",\n                                \"minLength\": 1,\n                                \"description\": \"The `certificate` for the temporary credentials, these are required\\nfor the temporary credentials to work.\\n\"\n                            }\n                        },\n                        \"required\": [\n                            \"clientId\",\n                            \"accessToken\",\n                            \"certificate\"\n                        ]\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"status\",\n                    \"runId\",\n                    \"workerGroup\",\n                    \"workerId\",\n                    \"takenUntil\",\n                    \"task\",\n                    \"credentials\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"tasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/claim-work-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/create-task-request.json#":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Definition Request\",\n    \"description\": \"Definition of a task that can be scheduled\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"provisionerId\": {\n            \"title\": \"Provisioner Id\",\n            \"description\": \"Unique identifier for a provisioner, that can supply specified\\n`workerType`\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerType\": {\n            \"title\": \"Worker Type\",\n            \"description\": \"Unique identifier for a worker-type within a specific provisioner\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"schedulerId\": {\n            \"title\": \"Scheduler Identifier\",\n            \"description\": \"Identifier for the scheduler that _defined_ this task, this can be an\\nidentifier for a user or a service like the `\\\"task-graph-scheduler\\\"`.\\n**Task submitter required scopes**\\n`queue:assume:scheduler-id:<schedulerId>/<taskGroupId>`.\\nThis scope is also necessary to _schedule_ a defined task, or _rerun_ a\\ntask.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\",\n            \"default\": \"-\"\n        },\n        \"taskGroupId\": {\n            \"title\": \"Task-Group Identifier\",\n            \"description\": \"Identifier for a group of tasks scheduled together with this task, by\\nscheduler identified by `schedulerId`. For tasks scheduled by the\\ntask-graph scheduler, this is the `taskGraphId`.  Defaults to `taskId` if\\nproperty isn't specified.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"dependencies\": {\n            \"title\": \"Task Dependencies\",\n            \"description\": \"List of dependent tasks. These must either be _completed_ or _resolved_\\nbefore this task is scheduled. See `requires` for semantics.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"title\": \"Task Dependency\",\n                \"description\": \"The `taskId` of a task that must be resolved before this task is\\nscheduled.\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n            },\n            \"maxItems\": 100,\n            \"uniqueItems\": true\n        },\n        \"requires\": {\n            \"title\": \"Dependency Requirement Semantics\",\n            \"description\": \"The tasks relation to its dependencies. This property specifies the\\nsemantics of the `task.dependencies` property.\\nIf `all-completed` is given the task will be scheduled when all\\ndependencies are resolved _completed_ (successful resolution).\\nIf `all-resolved` is given the task will be scheduled when all dependencies\\nhave been resolved, regardless of what their resolution is.\\n\",\n            \"type\": \"string\",\n            \"enum\": [\n                \"all-completed\",\n                \"all-resolved\"\n            ],\n            \"default\": \"all-completed\"\n        },\n        \"routes\": {\n            \"title\": \"Task Specific Routes\",\n            \"description\": \"List of task specific routes, AMQP messages will be CC'ed to these routes.\\n**Task submitter required scopes** `queue:route:<route>` for\\neach route given.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"title\": \"Task Specific Route\",\n                \"description\": \"A task specific route, AMQP messages will be CC'ed with a routing key\\nmatching `route.<task-specific route>`. It's possible to dot (`.`) in\\nthe task specific route to make sub-keys, etc. See the RabbitMQ\\n[tutorial](http://www.rabbitmq.com/tutorials/tutorial-five-python.html)\\nfor examples on how to use routing-keys.\\n\",\n                \"type\": \"string\",\n                \"maxLength\": 249,\n                \"minLength\": 1\n            },\n            \"maxItems\": 64,\n            \"uniqueItems\": true\n        },\n        \"priority\": {\n            \"title\": \"Task Priority\",\n            \"description\": \"Priority of task, this defaults to `normal`. Additional levels may be\\nadded later.\\n**Task submitter required scopes** `queue:task-priority:high` for high\\npriority tasks.\\n\",\n            \"type\": \"string\",\n            \"enum\": [\n                \"high\",\n                \"normal\"\n            ],\n            \"default\": \"normal\"\n        },\n        \"retries\": {\n            \"title\": \"Retries\",\n            \"description\": \"Number of times to retry the task in case of infrastructure issues.\\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\\nthese events are to be expected.\\n\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 49,\n            \"default\": 5\n        },\n        \"created\": {\n            \"title\": \"Created\",\n            \"description\": \"Creation time of task\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"deadline\": {\n            \"title\": \"Deadline\",\n            \"description\": \"Deadline of the task, `pending` and `running` runs are\\nresolved as **exception** if not resolved by other means\\nbefore the deadline. Note, deadline cannot be more than\\n5 days into the future\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Task expiration, time at which task definition and status is deleted.\\nNotice that all artifacts for the task must have an expiration that is no\\nlater than this. If this property isn't it will be set to `deadline`\\nplus one year (this default may subject to change).\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"scopes\": {\n            \"title\": \"Scopes\",\n            \"description\": \"List of scopes (or scope-patterns) that the task is\\nauthorized to use.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"title\": \"Scope\",\n                \"description\": \"A scope (or scope-patterns) which the task is\\nauthorized to use. This can be a string or a string\\nending with `*` which will authorize all scopes for\\nwhich the string is a prefix.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n**Task submitter required scopes** The same scope-pattern(s) given\\n(otherwise a task could be submitted to perform an action that the\\ntask submitter is not authorized to perform).\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[\\\\x20-\\\\x7e]*$\"\n            }\n        },\n        \"payload\": {\n            \"title\": \"Task Payload\",\n            \"description\": \"Task-specific payload following worker-specific format. For example the\\n`docker-worker` requires keys like: `image`, `commands` and\\n`features`. Refer to the documentation of `docker-worker` for details.\\n\",\n            \"type\": \"object\"\n        },\n        \"metadata\": {\n            \"title\": \"Meta-data\",\n            \"description\": \"Required task metadata\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of task, used to very briefly given an idea about\\nwhat the task does.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Human readable description of the task, please **explain** what the\\ntask does. A few lines of documentation is not going to hurt you.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"E-mail of person who caused this task, e.g. the person who did\\n`hg push`. The person we should contact to ask why this task is here.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"maxLength\": 255\n                },\n                \"source\": {\n                    \"title\": \"Source\",\n                    \"description\": \"Link to source of this task, should specify a file, revision and\\nrepository. This should be place someone can go an do a git/hg blame\\nto who came up with recipe for this task.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\",\n                \"source\"\n            ]\n        },\n        \"tags\": {\n            \"title\": \"Tags\",\n            \"description\": \"Arbitrary key-value tags (only strings limited to 4k). These can be used\\nto attach informal meta-data to a task. Use this for informal tags that\\ntasks can be classified by. You can also think of strings here as\\ncandidates for formal meta-data. Something like\\n`purpose: 'build' || 'test'` is a good example.\\n\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"string\",\n                \"maxLength\": 4096\n            },\n            \"default\": {}\n        },\n        \"extra\": {\n            \"title\": \"Extra Data\",\n            \"description\": \"Object with properties that can hold any kind of extra data that should be\\nassociated with the task. This can be data for the task which doesn't\\nfit into `payload`, or it can supplementary data for use in services\\nlistening for events from this task. For example this could be details to\\ndisplay on _treeherder_, or information for indexing the task. Please, try\\nto put all related information under one property, so `extra` data keys\\nfor treeherder reporting and task indexing don't conflict, hence, we have\\nreusable services. **Warning**, do not stuff large data-sets in here,\\ntask definitions should not take-up multiple MiBs.\\n\",\n            \"type\": \"object\",\n            \"default\": {}\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"provisionerId\",\n        \"workerType\",\n        \"created\",\n        \"deadline\",\n        \"payload\",\n        \"metadata\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/create-task-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/list-artifacts-response.json#":                        "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Artifacts Response\",\n    \"description\": \"List of artifacts for a given `taskId` and `runId`.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"artifacts\": {\n            \"title\": \"Artifact List\",\n            \"description\": \"List of artifacts for given `taskId` and `runId`.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Artifact\",\n                \"description\": \"Information about an artifact for the given `taskId` and `runId`.\\n\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"storageType\": {\n                        \"title\": \"Artifact Storage-Type\",\n                        \"description\": \"This is the `storageType` for the request that was used to create\\nthe artifact.\\n\",\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"s3\",\n                            \"azure\",\n                            \"reference\",\n                            \"error\"\n                        ]\n                    },\n                    \"name\": {\n                        \"title\": \"Artifact Name\",\n                        \"description\": \"Name of the artifact that was created, this is useful if you want to\\nattempt to fetch the artifact.\\n\",\n                        \"type\": \"string\",\n                        \"maxLength\": 1024\n                    },\n                    \"expires\": {\n                        \"title\": \"Artifact Expiration\",\n                        \"description\": \"Date and time after which the artifact created will be automatically\\ndeleted by the queue.\\n\",\n                        \"type\": \"string\",\n                        \"format\": \"date-time\"\n                    },\n                    \"contentType\": {\n                        \"title\": \"Content-Type\",\n                        \"description\": \"Mimetype for the artifact that was created.\\n\",\n                        \"type\": \"string\",\n                        \"maxLength\": 255\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"storageType\",\n                    \"name\",\n                    \"expires\",\n                    \"contentType\"\n                ]\n            }\n        },\n        \"continuationToken\": {\n            \"type\": \"string\",\n            \"title\": \"Continuation Token\",\n            \"description\": \"Opaque `continuationToken` to be given as query-string option to get the\\nnext set of artifacts.\\nThis property is only present if another request is necessary to fetch all\\nresults. In practice the next request with a `continuationToken` may not\\nreturn additional results, but it can. Thus, you can only be sure to have\\nall the results if you've called with `continuationToken` until you get a\\nresult without a `continuationToken`.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"artifacts\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/list-artifacts-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/list-dependent-tasks-response.json#":                  "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Dependent Tasks Response\",\n    \"description\": \"Response from a `listDependentTasks` request.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"taskId\": {\n            \"title\": \"Task Identifier\",\n            \"description\": \"Identifier for the task whose dependents are being listed.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"tasks\": {\n            \"type\": \"array\",\n            \"title\": \"Tasks that depends on `taskId`\",\n            \"description\": \"List of tasks that have `taskId` in the `task.dependencies` property.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"title\": \"Task definition and status\",\n                \"description\": \"Task Definition and task status structure.\\n\",\n                \"properties\": {\n                    \"task\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task.json#\"\n                    },\n                    \"status\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"task\",\n                    \"status\"\n                ]\n            }\n        },\n        \"continuationToken\": {\n            \"type\": \"string\",\n            \"title\": \"Continuation Token\",\n            \"description\": \"Opaque `continuationToken` to be given as query-string option to get the\\nnext set of dependent tasks.\\nThis property is only present if another request is necessary to fetch all\\nresults. In practice the next request with a `continuationToken` may not\\nreturn additional results, but it can. Thus, you can only be sure to have\\nall the results if you've called `listDependentTasks` with\\n`continuationToken` until you get a result without a `continuationToken`.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"taskId\",\n        \"tasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/list-dependent-tasks-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/list-task-group-response.json#":                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"List Task-Group Response\",\n    \"description\": \"Response from a `listTaskGroup` request.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"taskGroupId\": {\n            \"title\": \"Task-Group Identifier\",\n            \"description\": \"Identifier for the task-group being listed.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"tasks\": {\n            \"type\": \"array\",\n            \"title\": \"Tasks from the Task-Group\",\n            \"description\": \"List of tasks in this task-group.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"title\": \"Task definition and status\",\n                \"description\": \"Task Definition and task status structure.\\n\",\n                \"properties\": {\n                    \"task\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task.json#\"\n                    },\n                    \"status\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"task\",\n                    \"status\"\n                ]\n            }\n        },\n        \"continuationToken\": {\n            \"type\": \"string\",\n            \"title\": \"Continuation Token\",\n            \"description\": \"Opaque `continuationToken` to be given as query-string option to get the\\nnext set of tasks in the task-group.\\nThis property is only present if another request is necessary to fetch all\\nresults. In practice the next request with a `continuationToken` may not\\nreturn additional results, but it can. Thus, you can only be sure to have\\nall the results if you've called `listTaskGroup` with `continuationToken`\\nuntil you get a result without a `continuationToken`.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"taskGroupId\",\n        \"tasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/list-task-group-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/pending-tasks-response.json#":                         "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Count Pending Tasks Response\",\n    \"description\": \"Response to a request for the number of pending tasks for a given\\n`provisionerId` and `workerType`.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"provisionerId\": {\n            \"title\": \"Provisioner Id\",\n            \"description\": \"Unique identifier for the provisioner\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerType\": {\n            \"title\": \"Worker Type\",\n            \"description\": \"Identifier for worker type within the specified provisioner\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"pendingTasks\": {\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"title\": \"Number of Pending Tasks\",\n            \"description\": \"An approximate number of pending tasks for the given `provisionerId` and\\n`workerType`. This is based on Azure Queue Storage meta-data API, thus,\\nnumber of reported here may be higher than actual number of pending tasks.\\nBut there cannot be more pending tasks reported here. Ie. this is an\\n**upper-bound** on the number of pending tasks.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"provisionerId\",\n        \"workerType\",\n        \"pendingTasks\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/pending-tasks-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/poll-task-urls-response.json#":                        "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Poll Task Urls Response\",\n    \"description\": \"Response to request for poll task urls.\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"queues\": {\n            \"type\": \"array\",\n            \"title\": \"Queues To Poll From\",\n            \"description\": \"List of signed URLs for queues to poll tasks from, they must be called\\nin the order they are given. As the first entry in this array **may**\\nhave higher priority.\\n\",\n            \"items\": {\n                \"type\": \"object\",\n                \"title\": \"Signed URLs for a queue\",\n                \"description\": \"Object holding two signed URLs for an azure queue, one for fetching\\nmessages, and another for deleting messages. Remember to `claimTask`\\nbefore deleting the message, and delete message even if the `claimTask`\\noperation fails with a 400 status code. Don't delete it on other status\\ncodes!\\n\",\n                \"properties\": {\n                    \"signedPollUrl\": {\n                        \"type\": \"string\",\n                        \"format\": \"uri\",\n                        \"title\": \"Signed Get Message URL\",\n                        \"description\": \"Signed URL to get message from the Azure Queue Storage queue,\\nthat holds messages for the given `provisionerId` and `workerType`.\\nNote that this URL returns XML, see documentation for the Azure\\nQueue Storage\\n[REST API](http://msdn.microsoft.com/en-us/library/azure/dd179474.aspx)\\nfor details.\\nWhen you have a message you can use `claimTask` to claim the task.\\nYou will need to parse the XML response and base64 decode and\\nJSON parse the `MessageText`.\\nAfter you have called `claimTask` you **must** us the\\n`signedDeleteUrl` to delete the message.\\n**Remark**, you are allowed to append `&numofmessages=N`,\\nwhere N < 32, to the URLs if you wish to obtain more than one\\nmessage at the time.\\n\"\n                    },\n                    \"signedDeleteUrl\": {\n                        \"type\": \"string\",\n                        \"pattern\": \"^https://\",\n                        \"title\": \"Signed Delete Message URL\",\n                        \"description\": \"Signed URL to delete messages that have been received using the\\n`signedPollUrl`. You **must** do this to avoid receiving the same\\nmessage again.\\nTo use this URL you must substitute `{{messageId}}` and\\n`{{popReceipt}}` with `MessageId` and `PopReceipt` from the XML\\nresponse the `signedPollUrl` gave you. It is important that you\\n`encodeURIComponent` both `MessageId` and `PopReceipt` prior to\\nsubstitution, otherwise you will experience intermittent failures!\\nNote this URL only works with `DELETE` request.\\n\"\n                    }\n                },\n                \"required\": [\n                    \"signedPollUrl\",\n                    \"signedDeleteUrl\"\n                ]\n            }\n        },\n        \"expires\": {\n            \"title\": \"Signed URL Expiration\",\n            \"description\": \"Date and time after which the signed URLs provided in this response\\nexpires and not longer works for authentication.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"queues\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/poll-task-urls-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/post-artifact-request.json#":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Post Artifact Request\",\n    \"description\": \"Request a authorization to put and artifact or posting of a URL as an artifact. Note that the `storageType` property is referenced in the response as well.\",\n    \"type\": \"object\",\n    \"oneOf\": [\n        {\n            \"title\": \"S3 Artifact Request\",\n            \"description\": \"Request for a signed PUT URL that will allow you to upload an artifact\\nto an S3 bucket managed by the queue.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `'s3'`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"s3\"\n                    ]\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which the artifact should be deleted. Note, that\\nthese will be collected over time, and artifacts may remain\\navailable after expiration. S3 based artifacts are identified in\\nazure table storage and explicitly deleted on S3 after expiration.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"contentType\": {\n                    \"description\": \"Artifact mime-type, when uploading artifact to the signed\\n`PUT` URL returned from this request this must given with the\\n `ContentType` header. Please, provide correct mime-type,\\n this make tooling a lot easier, specifically,\\n always using `application/json` for JSON artifacts.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"expires\",\n                \"contentType\"\n            ]\n        },\n        {\n            \"title\": \"Azure Artifact Request\",\n            \"description\": \"Request for an Azure Shared Access Signature (SAS) that will allow\\nyou to upload an artifact to an Azure blob storage container managed\\nby the queue.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `azure`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"azure\"\n                    ]\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which the artifact should be deleted.\\nNote, that these will be collected over time, and artifacts may\\nremain available after expiration. Azure based artifacts are\\nidentified in azure table storage and explicitly deleted in the\\nazure storage container after expiration.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"contentType\": {\n                    \"description\": \"Artifact mime-type, when uploading artifact please use the same\\n`Content-Type`, consistently using the correct mime-type make\\ntooling a lot easier, specifically, always using `application/json`\\nfor JSON artifacts.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"expires\",\n                \"contentType\"\n            ]\n        },\n        {\n            \"title\": \"Redirect Artifact Request\",\n            \"description\": \"Request the queue to redirect to a URL for a given artifact.\\nThis allows you to reference artifacts that aren't managed by the queue.\\nThe queue will still authenticate the request, so depending on the level\\nof secrecy required, secret URLs **might** work. Note, this is mainly\\nuseful for public artifacts, for example temporary files directly\\nstored on the worker host and only available there for a specific\\namount of time.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `reference`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"reference\"\n                    ]\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which the queue should no longer redirect to this URL.\\nNote, that the queue will and cannot delete the resource your URL\\nreferences, you are responsible for doing that yourself.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"contentType\": {\n                    \"description\": \"Artifact mime-type for the resource to which the queue should\\nredirect. Please use the same `Content-Type`, consistently using\\nthe correct mime-type make tooling a lot easier, specifically,\\nalways using `application/json` for JSON artifacts.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"url\": {\n                    \"description\": \"URL to which the queue should redirect using a `303` (See other)\\nredirect.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"expires\",\n                \"url\",\n                \"contentType\"\n            ]\n        },\n        {\n            \"title\": \"Error Artifact Request\",\n            \"description\": \"Request the queue to reply `403` (forbidden) with `reason` and `message`\\nto any `GET` request for this artifact. This is mainly useful as a way\\nfor a task to declare that it failed to provide an artifact it wanted\\nto upload.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `error`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"error\"\n                    ]\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which the queue should stop replying with the error\\nand forget about the artifact.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"reason\": {\n                    \"description\": \"Reason why the artifact doesn't exist.\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"file-missing-on-worker\",\n                        \"invalid-resource-on-worker\",\n                        \"too-large-file-on-worker\"\n                    ]\n                },\n                \"message\": {\n                    \"description\": \"Human readable explanation of why the artifact is missing\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"expires\",\n                \"reason\",\n                \"message\"\n            ]\n        }\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/post-artifact-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/post-artifact-response.json#":                         "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Post Artifact Response\",\n    \"description\": \"Response to a request for posting an artifact.\\nNote that the `storageType` property is referenced in the request as well.\\n\",\n    \"type\": \"object\",\n    \"oneOf\": [\n        {\n            \"title\": \"S3 Artifact Response\",\n            \"description\": \"Response to a request for a signed PUT URL that will allow you to\\nupload an artifact to an S3 bucket managed by the queue.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `'s3'`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"s3\"\n                    ]\n                },\n                \"putUrl\": {\n                    \"description\": \"URL to which a `PUT` request can be made to upload the artifact\\nrequested. Note, the `Content-Length` must be specified correctly,\\nand the `ContentType` header must be set the value specified below.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\"\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which the signed `putUrl` no longer works\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"contentType\": {\n                    \"description\": \"Artifact mime-type, must be specified as header when uploading with\\nthe signed `putUrl`.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"putUrl\",\n                \"expires\",\n                \"contentType\"\n            ]\n        },\n        {\n            \"title\": \"Azure Artifact Response\",\n            \"description\": \"Response to a request for an Azure Shared Access Signature (SAS)\\nthat will allow you to upload an artifact to an Azure blob storage\\ncontainer managed by the queue.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `azure`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"azure\"\n                    ]\n                },\n                \"expires\": {\n                    \"description\": \"Date-time after which Shared Access Signature (SAS) will\\nseize to work.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"date-time\"\n                },\n                \"contentType\": {\n                    \"description\": \"Artifact mime-type, should be specified with the\\n`x-ms-blob-content-type` when committing the block.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"putUrl\": {\n                    \"description\": \"Shared Access Signature (SAS) with write permissions, see\\n[Azure REST API]\\n(http://msdn.microsoft.com/en-US/library/azure/dn140256.aspx)\\nreference for details on how to use this.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\",\n                \"expires\",\n                \"contentType\",\n                \"putUrl\"\n            ]\n        },\n        {\n            \"title\": \"Redirect Artifact Response\",\n            \"description\": \"Response to a request for the queue to redirect to a URL for a given\\nartifact.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `reference`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"reference\"\n                    ]\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\"\n            ]\n        },\n        {\n            \"title\": \"Error Artifact Response\",\n            \"description\": \"Response to a request for the queue to reply `403` (forbidden) with\\n`reason` and `message` to any `GET` request for this artifact.\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"storageType\": {\n                    \"description\": \"Artifact storage type, in this case `error`\\n\",\n                    \"type\": \"string\",\n                    \"enum\": [\n                        \"error\"\n                    ]\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"storageType\"\n            ]\n        }\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/post-artifact-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task-claim-request.json#":                             "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Claim Request\",\n    \"description\": \"Request to claim (or reclaim) a task\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"workerGroup\": {\n            \"description\": \"Identifier for group that worker claiming the task is a part of.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerId\": {\n            \"description\": \"Identifier for worker within the given workerGroup\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"workerGroup\",\n        \"workerId\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task-claim-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task-claim-response.json#":                            "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Claim Response\",\n    \"description\": \"Response to a successful task claim\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n        },\n        \"runId\": {\n            \"description\": \"`run-id` assigned to this run of the task\\n\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 1000\n        },\n        \"workerGroup\": {\n            \"description\": \"Identifier for the worker-group within which this run started.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerId\": {\n            \"description\": \"Identifier for the worker executing this run.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"takenUntil\": {\n            \"description\": \"Time at which the run expires and is resolved as `exception`,\\nwith reason `claim-expired` if the run haven't been reclaimed.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"task\": {\n            \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task.json#\"\n        },\n        \"credentials\": {\n            \"type\": \"object\",\n            \"description\": \"Temporary credentials granting `task.scopes` and the scope:\\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\\nthe task, upload artifacts and report task resolution.\\n\\nThe temporary credentials are set to expire after `takenUntil`. They\\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\\ncoming close `takenUntil` won't have problems even if there is a little\\nclock drift.\\n\\nWorkers should use these credentials when making requests on behalf of\\na task. This includes requests to create artifacts, reclaiming the task\\nreporting the task `completed`, `failed` or `exception`.\\n\\nNote, a new set of temporary credentials is issued when the worker\\nreclaims the task.\\n\",\n            \"properties\": {\n                \"clientId\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `clientId` for the temporary credentials.\\n\"\n                },\n                \"accessToken\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `accessToken` for the temporary credentials.\\n\"\n                },\n                \"certificate\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `certificate` for the temporary credentials, these are required\\nfor the temporary credentials to work.\\n\"\n                }\n            },\n            \"required\": [\n                \"clientId\",\n                \"accessToken\",\n                \"certificate\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"runId\",\n        \"workerGroup\",\n        \"workerId\",\n        \"takenUntil\",\n        \"task\",\n        \"credentials\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task-claim-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task-exception-request.json#":                         "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Exception Request\",\n    \"description\": \"Request for a run of a task to be resolved with an exception\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"reason\": {\n            \"type\": \"string\",\n            \"enum\": [\n                \"worker-shutdown\",\n                \"malformed-payload\",\n                \"resource-unavailable\",\n                \"internal-error\",\n                \"superseded\",\n                \"intermittent-task\"\n            ],\n            \"description\": \"Reason that the task is resolved with an exception. This is a subset\\nof the values for `resolvedReason` given in the task status structure.\\n**Report `worker-shutdown`** if the run failed because the worker\\nhad to shutdown (spot node disappearing). In case of `worker-shutdown`\\nthe queue will immediately **retry** the task, by making a new run.\\nThis is much faster than ignoreing the issue and letting the task _retry_\\nby claim expiration. For any other _reason_ reported the queue will not\\nretry the task.\\n**Report `malformed-payload`** if the `task.payload` doesn't match the\\nschema for the worker payload, or referenced resource doesn't exists.\\nIn either case, you should still log the error to a log file for the\\nspecific run.\\n**Report `resource-unavailable`** if a resource/service needed or\\nreferenced in `task.payload` is _temporarily_ unavailable. Do not use this\\nunless you know the resource exists, if the resource doesn't exist you\\nshould report `malformed-payload`. Example use-case if you contact the\\nindex (a service) on behalf of the task, because of a declaration in\\n`task.payload`, and the service (index) is temporarily down. Don't use\\nthis if a URL returns 404, but if it returns 503 or hits a timeout when\\nyou retry the request, then this _may_ be a valid exception. The queue\\nassumes that workers have applied retries as needed, and will not retry\\n the task.\\n**Report `internal-error`** if the worker experienced an unhandled internal\\nerror from which it couldn't recover. The queue will not retry runs\\nresolved with this reason, but you are clearly signaling that this is a\\nbug in the worker code.\\n**Report `superseded`** if the task was determined to have been\\nsuperseded by another task, and its results are no longer needed.  It is\\nconvention in this case to create an artifact entitled\\n`public/superseded-by` containing the taskId of the task that superseded\\nthis one.\\n**Report `intermittent-task`** if the task explicitly requested a retry\\nbecause task is intermittent. Workers can choose whether or not to\\nsupport this, but workers shouldn't blindly report this for every task\\nthat fails.\\n\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"reason\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task-exception-request.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task-reclaim-response.json#":                          "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Reclaim Response\",\n    \"description\": \"Response to a successful task claim\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n        },\n        \"runId\": {\n            \"description\": \"`run-id` assigned to this run of the task\\n\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 1000\n        },\n        \"workerGroup\": {\n            \"description\": \"Identifier for the worker-group within which this run started.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerId\": {\n            \"description\": \"Identifier for the worker executing this run.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"takenUntil\": {\n            \"description\": \"Time at which the run expires and is resolved as `exception`,\\nwith reason `claim-expired` if the run haven't been reclaimed.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"credentials\": {\n            \"type\": \"object\",\n            \"description\": \"Temporary credentials granting `task.scopes` and the scope:\\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\\nthe task, upload artifacts and report task resolution.\\n\\nThe temporary credentials are set to expire after `takenUntil`. They\\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\\ncoming close `takenUntil` won't have problems even if there is a little\\nclock drift.\\n\\nWorkers should use these credentials when making requests on behalf of\\na task. This includes requests to create artifacts, reclaiming the task\\nreporting the task `completed`, `failed` or `exception`.\\n\\nNote, a new set of temporary credentials is issued when the worker\\nreclaims the task.\\n\",\n            \"properties\": {\n                \"clientId\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `clientId` for the temporary credentials.\\n\"\n                },\n                \"accessToken\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `accessToken` for the temporary credentials.\\n\"\n                },\n                \"certificate\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1,\n                    \"description\": \"The `certificate` for the temporary credentials, these are required\\nfor the temporary credentials to work.\\n\"\n                }\n            },\n            \"required\": [\n                \"clientId\",\n                \"accessToken\",\n                \"certificate\"\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"runId\",\n        \"workerGroup\",\n        \"workerId\",\n        \"takenUntil\",\n        \"credentials\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task-reclaim-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task-status-response.json#":                           "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Status Response\",\n    \"description\": \"Response to a task status request\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/queue/v1/task-status.json#\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task-status-response.json#\"\n}",
	"http://schemas.taskcluster.net/queue/v1/task.json#":                                           "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task Definition Response\",\n    \"description\": \"Definition of a task that can be scheduled\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"provisionerId\": {\n            \"title\": \"Provisioner Id\",\n            \"description\": \"Unique identifier for a provisioner, that can supply specified\\n`workerType`\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"workerType\": {\n            \"title\": \"Worker Type\",\n            \"description\": \"Unique identifier for a worker-type within a specific provisioner\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"schedulerId\": {\n            \"title\": \"Scheduler Identifier\",\n            \"description\": \"Identifier for the scheduler that _defined_ this task, this can be an\\nidentifier for a user or a service like the `\\\"task-graph-scheduler\\\"`.\\nAlong with the `taskGroupId` this is used to form the permission scope\\n`queue:assume:scheduler-id:<schedulerId>/<taskGroupId>`,\\nthis scope is necessary to _schedule_ a defined task, or _rerun_ a task.\\n\",\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"maxLength\": 22,\n            \"pattern\": \"^([a-zA-Z0-9-_]*)$\"\n        },\n        \"taskGroupId\": {\n            \"title\": \"Task-Group Identifier\",\n            \"description\": \"Identifier for a group of tasks scheduled together with this task, by\\nscheduler identified by `schedulerId`. For tasks scheduled by the\\ntask-graph scheduler, this is the `taskGraphId`.  Defaults to `taskId` if\\nproperty isn't specified.\\n\",\n            \"type\": \"string\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"dependencies\": {\n            \"title\": \"Task Dependencies\",\n            \"description\": \"List of dependent tasks. These must either be _completed_ or _resolved_\\nbefore this task is scheduled. See `requires` for semantics.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task Dependency\",\n                \"description\": \"The `taskId` of a task that must be resolved before this task is\\nscheduled.\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n            },\n            \"maxItems\": 100,\n            \"uniqueItems\": true\n        },\n        \"requires\": {\n            \"title\": \"Dependency Requirement Semantics\",\n            \"description\": \"The tasks relation to its dependencies. This property specifies the\\nsemantics of the `task.dependencies` property.\\nIf `all-completed` is given the task will be scheduled when all\\ndependencies are resolved _completed_ (successful resolution).\\nIf `all-resolved` is given the task will be scheduled when all dependencies\\nhave been resolved, regardless of what their resolution is.\\n\",\n            \"type\": \"string\",\n            \"enum\": [\n                \"all-completed\",\n                \"all-resolved\"\n            ]\n        },\n        \"routes\": {\n            \"title\": \"Task Specific Routes\",\n            \"description\": \"List of task specific routes, AMQP messages will be CC'ed to these routes.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task Specific Route\",\n                \"description\": \"A task specific route, AMQP messages will be CC'ed with a routing key\\nmatching `route.<task-specific route>`. It's possible to dot (`.`) in\\nthe task specific route to make sub-keys, etc. See the RabbitMQ\\n[tutorial](http://www.rabbitmq.com/tutorials/tutorial-five-python.html)\\nfor examples on how to use routing-keys.\\n\",\n                \"type\": \"string\",\n                \"maxLength\": 249,\n                \"minLength\": 1\n            },\n            \"maxItems\": 64,\n            \"uniqueItems\": true\n        },\n        \"priority\": {\n            \"title\": \"Task Priority\",\n            \"description\": \"Priority of task, this defaults to `normal` and the scope\\n`queue:task-priority:high` is required to define a task with `priority`\\nset to `high`. Additional priority levels may be added later.\\n\",\n            \"type\": \"string\",\n            \"enum\": [\n                \"high\",\n                \"normal\"\n            ]\n        },\n        \"retries\": {\n            \"title\": \"Retries\",\n            \"description\": \"Number of times to retry the task in case of infrastructure issues.\\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\\nthese events are to be expected.\\n\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 49\n        },\n        \"created\": {\n            \"title\": \"Created\",\n            \"description\": \"Creation time of task\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"deadline\": {\n            \"title\": \"Deadline\",\n            \"description\": \"Deadline of the task, `pending` and `running` runs are\\nresolved as **exception** if not resolved by other means\\nbefore the deadline. Note, deadline cannot be more than\\n5 days into the future\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"expires\": {\n            \"title\": \"Expiration\",\n            \"description\": \"Task expiration, time at which task definition and status is deleted.\\nNotice that all artifacts for the task must have an expiration that is no\\nlater than this. If this property isn't it will be set to `deadline`\\nplus one year (this default may subject to change).\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        },\n        \"scopes\": {\n            \"title\": \"Scopes\",\n            \"description\": \"List of scopes (or scope-patterns) that the task is\\nauthorized to use.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Scope\",\n                \"description\": \"A scope (or scope-patterns) which the task is\\nauthorized to use. This can be a string or a string\\nending with `*` which will authorize all scopes for\\nwhich the string is a prefix.  Scopes must be composed of\\nprintable ASCII characters and spaces.\\n\",\n                \"type\": \"string\",\n                \"pattern\": \"^[\\\\x20-\\\\x7e]*$\"\n            }\n        },\n        \"payload\": {\n            \"title\": \"Task Payload\",\n            \"description\": \"Task-specific payload following worker-specific format. For example the\\n`docker-worker` requires keys like: `image`, `commands` and\\n`features`. Refer to the documentation of `docker-worker` for details.\\n\",\n            \"type\": \"object\"\n        },\n        \"metadata\": {\n            \"title\": \"Meta-data\",\n            \"description\": \"Required task metadata\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of task, used to very briefly given an idea about\\nwhat the task does.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Human readable description of the task, please **explain** what the\\ntask does. A few lines of documentation is not going to hurt you.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"E-mail of person who caused this task, e.g. the person who did\\n`hg push`. The person we should contact to ask why this task is here.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"maxLength\": 255\n                },\n                \"source\": {\n                    \"title\": \"Source\",\n                    \"description\": \"Link to source of this task, should specify a file, revision and\\nrepository. This should be place someone can go an do a git/hg blame\\nto who came up with recipe for this task.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\",\n                \"source\"\n            ]\n        },\n        \"tags\": {\n            \"title\": \"Tags\",\n            \"description\": \"Arbitrary key-value tags (only strings limited to 4k). These can be used\\nto attach informal meta-data to a task. Use this for informal tags that\\ntasks can be classified by. You can also think of strings here as\\ncandidates for formal meta-data. Something like\\n`purpose: 'build' || 'test'` is a good example.\\n\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"string\",\n                \"maxLength\": 4096\n            }\n        },\n        \"extra\": {\n            \"title\": \"Extra Data\",\n            \"description\": \"Object with properties that can hold any kind of extra data that should be\\nassociated with the task. This can be data for the task which doesn't\\nfit into `payload`, or it can supplementary data for use in services\\nlistening for events from this task. For example this could be details to\\ndisplay on _treeherder_, or information for indexing the task. Please, try\\nto put all related information under one property, so `extra` data keys\\nfor treeherder reporting and task indexing don't conflict, hence, we have\\nreusable services. **Warning**, do not stuff large data-sets in here,\\ntask definitions should not take-up multiple MiBs.\\n\",\n            \"type\": \"object\",\n            \"default\": {}\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"provisionerId\",\n        \"workerType\",\n        \"schedulerId\",\n        \"taskGroupId\",\n        \"dependencies\",\n        \"requires\",\n        \"routes\",\n        \"priority\",\n        \"retries\",\n        \"created\",\n        \"deadline\",\n        \"scopes\",\n        \"payload\",\n        \"metadata\",\n        \"tags\",\n        \"extra\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/queue/v1/task.json#\"\n}",
	"http://schemas.taskcluster.net/scheduler/v1/extend-task-graph-request.json#":                  "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/extend-task-graph-request.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task-Graph Definition\",\n    \"description\": \"Definition of a task-graph that can be scheduled\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"tasks\": {\n            \"title\": \"Tasks\",\n            \"description\": \"List of nodes in the task-graph, each featuring a task definition and scheduling preferences, such as number of _reruns_ to attempt.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task Node\",\n                \"description\": \"Representation of a tasks in the task-graph\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"taskId\": {\n                        \"title\": \"Task Identifier\",\n                        \"description\": \"Task identifier (`taskId`) for the task when submitted to the queue, also used in `requires` below. This must be formatted as a **slugid** that is a uuid encoded in url-safe base64 following [RFC 4648 sec. 5](http://tools.ietf.org/html/rfc4648#section-5)), but without `==` padding.\",\n                        \"type\": \"string\",\n                        \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                    },\n                    \"requires\": {\n                        \"title\": \"Required tasks\",\n                        \"description\": \"List of required `taskId`s\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"title\": \"Required `taskId`\",\n                            \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        },\n                        \"default\": []\n                    },\n                    \"reruns\": {\n                        \"title\": \"Re-runs\",\n                        \"description\": \"Number of times to _rerun_ the task if it completed unsuccessfully. **Note**, this does not capture _retries_ due to infrastructure issues.\",\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 100,\n                        \"default\": 0\n                    },\n                    \"task\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/create-task-request.json#\"\n                    }\n                },\n                \"required\": [\n                    \"taskId\",\n                    \"task\"\n                ]\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"tasks\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-response.json":                 "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-response.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Inspect Task-Graph Response\",\n    \"description\": \"Information about a **task-graph** as known by the scheduler, with all the state of all individual tasks.\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status.json#\"\n        },\n        \"tasks\": {\n            \"title\": \"Tasks\",\n            \"description\": \"Mapping from task-labels to task information and state.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task Information\",\n                \"description\": \"Information about a tasks in the task-graph\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"taskId\": {\n                        \"type\": \"string\",\n                        \"title\": \"Task Identifier\",\n                        \"description\": \"Unique task identifier, this is UUID encoded as [URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and stripped of `=` padding.\",\n                        \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                    },\n                    \"name\": {\n                        \"type\": \"string\",\n                        \"title\": \"Name\",\n                        \"description\": \"Human readable name from the task definition\",\n                        \"maxLength\": 255\n                    },\n                    \"requires\": {\n                        \"title\": \"Required tasks\",\n                        \"description\": \"List of required `taskId`s\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"title\": \"Required `taskId`\",\n                            \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        }\n                    },\n                    \"requiresLeft\": {\n                        \"title\": \"Required tasks left\",\n                        \"description\": \"List of `taskId`s that have yet to complete successfully, before this task can be scheduled.\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"title\": \"Required `taskId`\",\n                            \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        }\n                    },\n                    \"reruns\": {\n                        \"title\": \"Re-runs\",\n                        \"description\": \"Number of times to _rerun_ the task if it completed unsuccessfully. **Note**, this does not capture _retries_ due to infrastructure issues.\",\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 999\n                    },\n                    \"rerunsLeft\": {\n                        \"title\": \"Re-runs Left\",\n                        \"description\": \"Number of reruns that haven't been used yet.\",\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 999\n                    },\n                    \"state\": {\n                        \"title\": \"Task Node State\",\n                        \"description\": \"State of the task as considered by the scheduler\",\n                        \"type\": \"string\",\n                        \"enum\": [\n                            \"unscheduled\",\n                            \"scheduled\",\n                            \"completed\",\n                            \"failed\",\n                            \"exception\"\n                        ]\n                    },\n                    \"satisfied\": {\n                        \"title\": \"Task Satisfied\",\n                        \"description\": \"true, if the scheduler considers the task node as satisfied and hence no-longer prevents dependent tasks from running.\",\n                        \"type\": \"boolean\"\n                    },\n                    \"dependents\": {\n                        \"title\": \"Dependent tasks\",\n                        \"description\": \"List of `taskId`s that requires this task to be _complete successfully_ before they can be scheduled.\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"title\": \"Dependent `taskId`\",\n                            \"description\": \"`taskId` for task that requires this task to be _successfully completed_ before it can be scheduled.\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        }\n                    }\n                },\n                \"additionalProperties\": false,\n                \"required\": [\n                    \"taskId\",\n                    \"name\",\n                    \"requires\",\n                    \"requiresLeft\",\n                    \"reruns\",\n                    \"rerunsLeft\",\n                    \"state\",\n                    \"satisfied\",\n                    \"dependents\"\n                ]\n            }\n        },\n        \"metadata\": {\n            \"title\": \"Meta-data\",\n            \"description\": \"Required task metadata\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of task-graph\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Human readable description of task-graph, **explain** what it does!\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"E-mail of person who caused this task-graph, e.g. the person who did `hg push`\",\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"maxLength\": 255\n                },\n                \"source\": {\n                    \"title\": \"Source\",\n                    \"description\": \"Link to source of this task-graph, should specify file, revision and repository\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\",\n                \"source\"\n            ]\n        },\n        \"tags\": {\n            \"title\": \"Tags\",\n            \"description\": \"Arbitrary key-value tags (only strings limited to 4k)\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"string\",\n                \"maxLength\": 4096\n            }\n        },\n        \"scopes\": {\n            \"title\": \"Scopes\",\n            \"description\": \"List of scopes (or scope-patterns) that tasks of the task-graph is authorized to use.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Scope\",\n                \"description\": \"A scope (or scope-patterns) which a task of the task-graph is authorized to use. This can be a string or a string ending with `*` which will authorize all scopes for which the string is a prefix.\",\n                \"type\": \"string\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"tasks\",\n        \"metadata\",\n        \"tags\",\n        \"scopes\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-task-response.json":            "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/inspect-task-graph-task-response.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Inspect Task-Graph Task Response\",\n    \"description\": \"Information about a **task** in a task-graph as known by the scheduler.\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"taskId\": {\n            \"type\": \"string\",\n            \"title\": \"Task Identifier\",\n            \"description\": \"Unique task identifier, this is UUID encoded as [URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and stripped of `=` padding.\",\n            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n        },\n        \"name\": {\n            \"type\": \"string\",\n            \"title\": \"Name\",\n            \"description\": \"Human readable name from the task definition\",\n            \"maxLength\": 255\n        },\n        \"requires\": {\n            \"title\": \"Required tasks\",\n            \"description\": \"List of required `taskId`s\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Required `taskId`\",\n                \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                \"type\": \"string\",\n                \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n            }\n        },\n        \"requiresLeft\": {\n            \"title\": \"Required tasks left\",\n            \"description\": \"List of `taskId`s that have yet to complete successfully, before this task can be scheduled.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Required `taskId`\",\n                \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                \"type\": \"string\",\n                \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n            }\n        },\n        \"reruns\": {\n            \"title\": \"Re-runs\",\n            \"description\": \"Number of times to _rerun_ the task if it completed unsuccessfully. **Note**, this does not capture _retries_ due to infrastructure issues.\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 999\n        },\n        \"rerunsLeft\": {\n            \"title\": \"Re-runs Left\",\n            \"description\": \"Number of reruns that haven't been used yet.\",\n            \"type\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 999\n        },\n        \"state\": {\n            \"title\": \"Task Node State\",\n            \"description\": \"State of the task as considered by the scheduler\",\n            \"type\": \"string\",\n            \"enum\": [\n                \"unscheduled\",\n                \"scheduled\",\n                \"completed\",\n                \"failed\",\n                \"exception\"\n            ]\n        },\n        \"satisfied\": {\n            \"title\": \"Task Satisfied\",\n            \"description\": \"true, if the scheduler considers the task node as satisfied and hence no-longer prevents dependent tasks from running.\",\n            \"type\": \"boolean\"\n        },\n        \"dependents\": {\n            \"title\": \"Dependent tasks\",\n            \"description\": \"List of `taskId`s that requires this task to be _complete successfully_ before they can be scheduled.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Dependent `taskId`\",\n                \"description\": \"`taskId` for task that requires this task to be _successfully completed_ before it can be scheduled.\",\n                \"type\": \"string\",\n                \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"taskId\",\n        \"name\",\n        \"requires\",\n        \"requiresLeft\",\n        \"reruns\",\n        \"rerunsLeft\",\n        \"state\",\n        \"satisfied\",\n        \"dependents\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/task-graph-info-response.json":                    "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-info-response.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task-Graph Info Response\",\n    \"description\": \"Response for a request for task-graph information\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status.json#\"\n        },\n        \"metadata\": {\n            \"title\": \"Meta-data\",\n            \"description\": \"Required task metadata\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of task-graph\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Human readable description of task-graph, **explain** what it does!\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"E-mail of person who caused this task-graph, e.g. the person who did `hg push`\",\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"maxLength\": 255\n                },\n                \"source\": {\n                    \"title\": \"Source\",\n                    \"description\": \"Link to source of this task-graph, should specify file, revision and repository\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\",\n                \"source\"\n            ]\n        },\n        \"tags\": {\n            \"title\": \"Tags\",\n            \"description\": \"Arbitrary key-value tags (only strings limited to 4k)\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"string\",\n                \"maxLength\": 4096\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\",\n        \"metadata\",\n        \"tags\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json":                  "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task-Graph Status Response\",\n    \"description\": \"Response containing the status structure for a task-graph\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status.json#\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json#":                 "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status-response.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task-Graph Status Response\",\n    \"description\": \"Response containing the status structure for a task-graph\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"status\": {\n            \"$ref\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph-status.json#\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"status\"\n    ]\n}",
	"http://schemas.taskcluster.net/scheduler/v1/task-graph.json#":                                 "{\n    \"id\": \"http://schemas.taskcluster.net/scheduler/v1/task-graph.json#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Task-Graph Definition\",\n    \"description\": \"Definition of a task-graph that can be scheduled\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"scopes\": {\n            \"title\": \"Scopes\",\n            \"description\": \"List of scopes (or scope-patterns) that tasks of the task-graph is\\nauthorized to use.\\n\",\n            \"type\": \"array\",\n            \"default\": [],\n            \"items\": {\n                \"title\": \"Scope\",\n                \"description\": \"A scope (or scope-patterns) which a task of the task-graph is\\nauthorized to use. This can be a string or a string ending with `*`\\nwhich will authorize all scopes for which the string is a prefix.\\n\",\n                \"type\": \"string\"\n            }\n        },\n        \"routes\": {\n            \"title\": \"Task-graph specific routes\",\n            \"description\": \"List of task-graph specific routes, AMQP messages will be CC'ed to these\\nroutes prefixed by `'route.'`.\\n\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task-Graph specific route\",\n                \"description\": \"A task-graph specific route, AMQP messages will be CC'ed with a\\nrouting key matching `route.<task-graph specific route>`. It's possible\\nto dot (`.`) in the task-graph specific route to make sub-keys, etc.\\nSee the RabbitMQ\\n[tutorial](http://www.rabbitmq.com/tutorials/tutorial-five-python.html)\\nfor examples on how to use routing-keys.\\n\",\n                \"type\": \"string\",\n                \"maxLength\": 249,\n                \"minLength\": 1\n            },\n            \"maxItems\": 10,\n            \"uniqueItems\": true,\n            \"default\": []\n        },\n        \"tasks\": {\n            \"title\": \"Tasks\",\n            \"description\": \"List of nodes in the task-graph, each featuring a task definition and scheduling preferences, such as number of _reruns_ to attempt.\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Task Node\",\n                \"description\": \"Representation of a tasks in the task-graph\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"taskId\": {\n                        \"title\": \"Task Identifier\",\n                        \"description\": \"Task identifier (`taskId`) for the task when submitted to the queue, also used in `requires` below. This must be formatted as a **slugid** that is a uuid encoded in url-safe base64 following [RFC 4648 sec. 5](http://tools.ietf.org/html/rfc4648#section-5)), but without `==` padding.\",\n                        \"type\": \"string\",\n                        \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                    },\n                    \"requires\": {\n                        \"title\": \"Required tasks\",\n                        \"description\": \"List of required `taskId`s\",\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"title\": \"Required `taskId`\",\n                            \"description\": \"`taskId` for task that is required to be _successfully completed_ before this task is scheduled.\",\n                            \"type\": \"string\",\n                            \"pattern\": \"^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$\"\n                        },\n                        \"default\": []\n                    },\n                    \"reruns\": {\n                        \"title\": \"Re-runs\",\n                        \"description\": \"Number of times to _rerun_ the task if it completed unsuccessfully. **Note**, this does not capture _retries_ due to infrastructure issues.\",\n                        \"type\": \"integer\",\n                        \"minimum\": 0,\n                        \"maximum\": 100,\n                        \"default\": 0\n                    },\n                    \"task\": {\n                        \"$ref\": \"http://schemas.taskcluster.net/queue/v1/create-task-request.json#\"\n                    }\n                },\n                \"required\": [\n                    \"taskId\",\n                    \"task\"\n                ]\n            }\n        },\n        \"metadata\": {\n            \"title\": \"Meta-data\",\n            \"description\": \"Required task metadata\\n\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"title\": \"Name\",\n                    \"description\": \"Human readable name of task-graph, give people finding this an idea\\nwhat this graph is about.\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 255\n                },\n                \"description\": {\n                    \"title\": \"Description\",\n                    \"description\": \"Human readable description of task-graph, **explain** what it does!\\n\",\n                    \"type\": \"string\",\n                    \"maxLength\": 32768\n                },\n                \"owner\": {\n                    \"title\": \"Owner\",\n                    \"description\": \"E-mail of person who caused this task-graph, e.g. the person who did\\n`hg push` or whatever triggered it.\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"email\",\n                    \"maxLength\": 255\n                },\n                \"source\": {\n                    \"title\": \"Source\",\n                    \"description\": \"Link to source of this task-graph, should specify file, revision and\\nrepository\\n\",\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"maxLength\": 4096\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\n                \"name\",\n                \"description\",\n                \"owner\",\n                \"source\"\n            ]\n        },\n        \"tags\": {\n            \"title\": \"Tags\",\n            \"description\": \"Arbitrary key-value tags (only strings limited to 4k)\\n\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"type\": \"string\",\n                \"maxLength\": 4096\n            },\n            \"default\": {}\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"tasks\",\n        \"metadata\"\n    ]\n}",
	"http://schemas.taskcluster.net/secrets/v1/secret-list.json#":                                  "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Secrets List\",\n    \"description\": \"Message containing a list of secret names\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"secrets\": {\n            \"description\": \"Secret names\",\n            \"type\": \"array\",\n            \"items\": {\n                \"title\": \"Secret\",\n                \"description\": \"Secret name\",\n                \"type\": \"string\"\n            }\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"secrets\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/secrets/v1/secret-list.json#\"\n}",
	"http://schemas.taskcluster.net/secrets/v1/secret.json#":                                       "{\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"title\": \"Secret\",\n    \"description\": \"Message containing a TaskCluster Secret\\n\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"secret\": {\n            \"description\": \"The secret value to be encrypted.\\n\",\n            \"type\": \"object\"\n        },\n        \"expires\": {\n            \"description\": \"An expiration date for this secret.\\n\",\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\n        \"secret\",\n        \"expires\"\n    ],\n    \"id\": \"http://schemas.taskcluster.net/secrets/v1/secret.json#\"\n}",
}
