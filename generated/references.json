[
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a worker.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker` are included.\n",
                "enum": [
                  "worker"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker Action",
            "type": "object"
          },
          "title": "Worker Actions",
          "type": "array",
          "uniqueItems": false
        },
        "capacity": {
          "description": "Number of tasks this worker can handle at once. A worker capacity of 0 means\nthe worker is not managed by worker manager and is only known to the queue, the\ntrue capacity is not known.\n",
          "minimum": 0,
          "title": "Worker Capacity",
          "type": "integer"
        },
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        },
        "firstClaim": {
          "description": "Date of the first time this worker claimed a task.\n",
          "format": "date-time",
          "title": "First task claimed",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this worker was seen active. Updated each time a worker calls\n`queue.claimWork`, `queue.reclaimTask`, and `queue.declareWorker` for this task queue.\n`lastDateActive` is updated every half hour but may be off by up-to half an hour.\nNonetheless, `lastDateActive` is a good indicator of when the worker was last seen active.\nThis defaults to null in the database, and is set to the current time when the worker\nis first seen.\n",
          "format": "date-time",
          "title": "Worker Last Date Active",
          "type": "string"
        },
        "providerId": {
          "description": "The provider that had started the worker and responsible for managing it.\nCan be different from the provider that's currently in the worker pool config.\nA providerId of \"none\" is used when the worker is not managed by worker manager.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        },
        "recentTasks": {
          "description": "List of 20 most recent tasks claimed by the worker.\n",
          "items": {
            "$ref": "task-run.json#"
          },
          "title": "Most Recent Tasks",
          "type": "array",
          "uniqueItems": false
        },
        "state": {
          "description": "A string specifying the state this worker is in so far as worker-manager knows.\nA \"requested\" worker is in the process of starting up, and if successful will enter\nthe \"running\" state once it has registered with the `registerWorker` API method.  A\n\"stopping\" worker is in the process of shutting down and deleting resources, while\na \"stopped\" worker is completely stopped.  Stopped workers are kept for historical\npurposes and are purged when they expire.  Note that some providers transition workers\ndirectly from \"running\" to \"stopped\".\nAn \"standalone\" worker is a worker that is not managed by worker-manager, these workers\nare only known by the queue.\n",
          "enum": [
            "requested",
            "running",
            "stopping",
            "stopped",
            "standalone"
          ],
          "title": "State",
          "type": "string"
        },
        "workerGroup": {
          "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Group",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker evaluating this run within given\n`workerGroup`.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Identifier",
          "type": "string"
        },
        "workerPoolId": {
          "$ref": "task.json#/properties/workerPoolId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "workerGroup",
        "workerId",
        "recentTasks",
        "expires",
        "firstClaim",
        "actions"
      ],
      "title": "Worker Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of worker pools",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerPools": {
          "description": "List of all worker pools",
          "items": {
            "$ref": "worker-pool-full.json#"
          },
          "title": "Worker Pools",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerPools"
      ],
      "title": "Worker Pool List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-full.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker pool definition.\n",
      "properties": {
        "config": {
          "additionalProperties": true,
          "type": "object"
        },
        "created": {
          "description": "Date and time when this worker pool was created\n",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "currentCapacity": {
          "description": "Total capacity available across all workers for this worker pool that are currently not \"stopped\"",
          "minimum": 0,
          "title": "Current Capacity",
          "type": "integer"
        },
        "description": {
          "description": "A description of this worker pool.\n",
          "maxLength": 10240,
          "title": "Description",
          "type": "string"
        },
        "emailOnError": {
          "description": "If true, the owner should be emailed on provisioning errors",
          "title": "Wants Email",
          "type": "boolean"
        },
        "lastModified": {
          "description": "Date and time when this worker pool was last updated\n",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "owner": {
          "description": "An email address to notify when there are provisioning errors for this\nworker pool.\n",
          "format": "email",
          "title": "Owner Email",
          "type": "string"
        },
        "providerId": {
          "description": "The provider responsible for managing this worker pool.\n\nIf this value is `\"null-provider\"`, then the worker pool is pending deletion\nonce all existing workers have terminated.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "requestedCapacity": {
          "description": "Total capacity available across all workers for this worker pool with state \"requested\"",
          "minimum": 0,
          "title": "Requested Worker Capacity",
          "type": "integer"
        },
        "requestedCount": {
          "description": "Total worker count in \"requested\" state for this worker pool",
          "minimum": 0,
          "title": "Requested Worker Count",
          "type": "integer"
        },
        "runningCapacity": {
          "description": "Total capacity available across all workers for this worker pool with state \"running\"",
          "minimum": 0,
          "title": "Running Worker Capacity",
          "type": "integer"
        },
        "runningCount": {
          "description": "Total worker count in \"running\" state for this worker pool",
          "minimum": 0,
          "title": "Running Worker Count",
          "type": "integer"
        },
        "stoppedCapacity": {
          "description": "Total capacity available across all workers for this worker pool with state \"stopped\"",
          "minimum": 0,
          "title": "Stopped Worker Capacity",
          "type": "integer"
        },
        "stoppedCount": {
          "description": "Total worker count in \"stopped\" state for this worker pool",
          "minimum": 0,
          "title": "Stopped Worker Count",
          "type": "integer"
        },
        "stoppingCapacity": {
          "description": "Total capacity available across all workers for this worker pool with state \"stopping\"",
          "minimum": 0,
          "title": "Stopping Worker Capacity",
          "type": "integer"
        },
        "stoppingCount": {
          "description": "Total worker count in \"stopping\" state for this worker pool",
          "minimum": 0,
          "title": "Stopping Worker Count",
          "type": "integer"
        },
        "workerPoolId": {
          "description": "The ID of this worker pool (of the form `providerId/workerType` for compatibility)\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Pool ID",
          "type": "string"
        }
      },
      "required": [
        "providerId",
        "description",
        "created",
        "lastModified",
        "config",
        "owner",
        "emailOnError",
        "currentCapacity",
        "requestedCount",
        "runningCount",
        "stoppingCount",
        "stoppedCount",
        "requestedCapacity",
        "runningCapacity",
        "stoppingCapacity",
        "stoppedCapacity"
      ],
      "title": "Worker Pool Full Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-full.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-error.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker pool error definition.\n",
      "properties": {
        "description": {
          "description": "A longer description of what occured in the error.",
          "maxLength": 10240,
          "title": "Description",
          "type": "string"
        },
        "errorId": {
          "description": "An arbitary unique identifier for this error",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Error ID",
          "type": "string"
        },
        "extra": {
          "additionalProperties": true,
          "description": "Any extra structured information about this error",
          "title": "Extra",
          "type": "object"
        },
        "kind": {
          "description": "A general machine-readable way to identify this sort of error.",
          "maxLength": 128,
          "pattern": "[-a-z0-9]+",
          "title": "Kind",
          "type": "string"
        },
        "reported": {
          "description": "Date and time when this error was reported",
          "format": "date-time",
          "title": "Reported",
          "type": "string"
        },
        "title": {
          "description": "A human-readable version of `kind`.",
          "maxLength": 128,
          "title": "Title",
          "type": "string"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "errorId",
        "reported",
        "kind",
        "title",
        "description",
        "extra"
      ],
      "title": "Worker Pool Error",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-error.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-error-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of worker pool errors",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerPoolErrors": {
          "description": "List of worker pool errors",
          "items": {
            "$ref": "worker-pool-error.json#"
          },
          "title": "Worker Pool Errors",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerPoolErrors"
      ],
      "title": "Worker Pool Error List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-error-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of workers in a given worker pool",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of all workers in a given worker pool",
          "items": {
            "$ref": "worker-full.json#"
          },
          "title": "Workers",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "Worker List in a Given Worker Pool",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-lifecycle.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Conditions a worker can reach and actions to take in the case that they do.\nNot all providers necessarily implement all features of this in the same way.\nRead the providers docs to understand exactly what it will do.\n",
      "properties": {
        "registrationTimeout": {
          "description": "Each worker in this pool has `registrationTimeout` seconds to\nregister itself with worker-manager after it has\nbeen requsted from the cloud provider. After this\ntimeout, worker-manager will terminate the instance,\nassuming it is broken.\n\nThis parameter has no effect for worker pools using the static provider\ntype.\n",
          "title": "Registration Timeout",
          "type": "integer"
        },
        "reregistrationTimeout": {
          "default": 345600,
          "description": "If specified, workers in this pool must re-register via `reregister()`\nwithin `reregistrationTimeout` seconds from the initial call to\n`register()` to get new credentials. If the worker has not done so, it\nwill be terminated.  This value also dictates the lifetime of the\ntemporary credentials granted to the worker, meaning that it must be\nless than 30 days. The default value is 4 days.\n",
          "maximum": 2592000,
          "title": "Checkin Timeout",
          "type": "integer"
        }
      },
      "required": [
      ],
      "title": "Worker Lifecycle",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-lifecycle.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-full.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker definition.",
      "properties": {
        "capacity": {
          "description": "Number of tasks this worker can handle at once",
          "minimum": 1,
          "title": "Worker Capacity",
          "type": "integer"
        },
        "created": {
          "description": "Date and time when this worker was created",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "expires": {
          "description": "Date and time when this worker will be deleted from the DB",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "lastChecked": {
          "description": "Date and time when the state of this worker was verified with a cloud api.\nFor providers with nothing to check, this will just be permanently set to the\ntime the worker was created.\n",
          "format": "date-time",
          "title": "Last Checked",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time when this worker last changed state",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "providerId": {
          "description": "The provider that had started the worker and responsible for managing it.\nCan be different from the provider that's currently in the worker pool config.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "state": {
          "description": "A string specifying the state this worker is in so far as worker-manager knows.\nA \"requested\" worker is in the process of starting up, and if successful will enter\nthe \"running\" state once it has registered with the `registerWorker` API method.  A\n\"stopping\" worker is in the process of shutting down and deleting resources, while\na \"stopped\" worker is completely stopped.  Stopped workers are kept for historical\npurposes and are purged when they expire.  Note that some providers transition workers\ndirectly from \"running\" to \"stopped\".\n",
          "enum": [
            "requested",
            "running",
            "stopping",
            "stopped"
          ],
          "title": "State",
          "type": "string"
        },
        "workerGroup": {
          "description": "Worker group to which this worker belongs",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker group",
          "type": "string"
        },
        "workerId": {
          "description": "Worker ID",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker ID",
          "type": "string"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "workerGroup",
        "workerId",
        "providerId",
        "created",
        "expires",
        "state",
        "capacity",
        "lastChecked",
        "lastModified"
      ],
      "title": "Worker Full Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-full.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/update-worker-pool-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Fields that are defined by a user for a worker pool.\nUsed to modify worker-pool definitions.\n\nThe `workerPoolId`, `created`, and `lastModified` fields are optional and\nallowed only to ease the common practice of getting a worker pool definition\nwith `workerPool(..)`, modifying it, and writing it back with\n`updateWorkerPool(..).  `workerPoolId` must be correct if\nsupplied, and the values of `created` and `lastModified` are ignored.\n",
      "properties": {
        "config": {
          "$ref": "worker-pool-full.json#/properties/config"
        },
        "created": {
          "description": "Ignored on update",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "description": {
          "$ref": "worker-pool-full.json#/properties/description"
        },
        "emailOnError": {
          "$ref": "worker-pool-full.json#/properties/emailOnError"
        },
        "lastModified": {
          "description": "Ignored on update",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "owner": {
          "$ref": "worker-pool-full.json#/properties/owner"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        },
        "workerPoolId": {
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Pool ID",
          "type": "string"
        }
      },
      "required": [
        "providerId",
        "description",
        "config",
        "owner",
        "emailOnError"
      ],
      "title": "Worker Pool Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/update-worker-pool-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/task.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, by which this task must be complete. `pending` and\n`running` runs are resolved as **exception** if not resolved by other means\nbefore the deadline. After the deadline, a task is immutable. Note,\ndeadline cannot be more than 5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "default": [
          ],
          "description": "List of dependent tasks. These must either be _completed_ or _resolved_\nbefore this task is scheduled. See `requires` for semantics.\n",
          "items": {
            "description": "The `taskId` of a task that must be resolved before this task is\nscheduled.\n",
            "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
            "title": "Task Dependency",
            "type": "string"
          },
          "maxItems": 100,
          "title": "Task Dependencies",
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Task expiration, time at which task definition and status is deleted.\nNotice that all artifacts for the task must have an expiration that is no\nlater than this. If this property isn't it will be set to `deadline`\nplus one year (this default may change).\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "extra": {
          "default": {
          },
          "description": "Object with properties that can hold any kind of extra data that should be\nassociated with the task. This can be data for the task which doesn't\nfit into `payload`, or it can supplementary data for use in services\nlistening for events from this task. For example this could be details to\ndisplay on dashboard, or information for indexing the task. Please, try\nto put all related information under one property, so `extra` data keys\ndon't conflict.  **Warning**, do not stuff large data-sets in here --\ntask definitions should not take-up multiple MiBs.\n",
          "title": "Extra Data",
          "type": "object"
        },
        "metadata": {
          "additionalProperties": false,
          "description": "Required task metadata\n",
          "properties": {
            "description": {
              "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
              "maxLength": 32768,
              "title": "Description",
              "type": "string"
            },
            "name": {
              "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
              "maxLength": 255,
              "title": "Name",
              "type": "string"
            },
            "owner": {
              "description": "Entity who caused this task, not necessarily a person with email who did\n`hg push` as it could be automation bots as well. The entity we should\ncontact to ask why this task is here.\n",
              "maxLength": 255,
              "title": "Owner",
              "type": "string"
            },
            "source": {
              "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
              "format": "uri",
              "maxLength": 4096,
              "pattern": "^(https?|ssh)://",
              "title": "Source",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description",
            "owner",
            "source"
          ],
          "title": "Task Metadata",
          "type": "object"
        },
        "payload": {
          "description": "Task-specific payload following worker-specific format.\nRefer to the documentation for the worker implementing\n`<provisionerId>/<workerType>` for details.\n",
          "title": "Task Payload",
          "type": "object"
        },
        "priority": {
          "default": "lowest",
          "description": "Priority of task. This defaults to `lowest` and the scope\n`queue:create-task:<priority>/<provisionerId>/<workerType>` is required\nto define a task with `<priority>`. The `normal` priority is treated as\n`lowest`.\n",
          "enum": [
            "highest",
            "very-high",
            "high",
            "medium",
            "low",
            "very-low",
            "lowest",
            "normal"
          ],
          "title": "Task Priority",
          "type": "string"
        },
        "projectId": {
          "default": "none",
          "description": "The name for the \"project\" with which this task is associated.  This\nvalue can be used to control permission to manipulate tasks as well as\nfor usage reporting.  Project ids are typically simple identifiers,\noptionally in a hierarchical namespace separated by `/` characters.\nThis value defaults to `none`.\n",
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        },
        "provisionerId": {
          "description": "Unique identifier for a provisioner, that can supply specified\n`workerType`. Deprecation is planned for this property as it\nwill be replaced, together with `workerType`, by the new\nidentifier `workerPoolId`.\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}$",
          "title": "Provisioner Id",
          "type": "string"
        },
        "requires": {
          "default": "all-completed",
          "description": "The tasks relation to its dependencies. This property specifies the\nsemantics of the `task.dependencies` property.\nIf `all-completed` is given the task will be scheduled when all\ndependencies are resolved _completed_ (successful resolution).\nIf `all-resolved` is given the task will be scheduled when all dependencies\nhave been resolved, regardless of what their resolution is.\n",
          "enum": [
            "all-completed",
            "all-resolved"
          ],
          "title": "Dependency Requirement Semantics",
          "type": "string"
        },
        "retries": {
          "default": 5,
          "description": "Number of times to retry the task in case of infrastructure issues.\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\nthese events are to be expected.\n",
          "maximum": 49,
          "minimum": 0,
          "title": "Retries",
          "type": "integer"
        },
        "routes": {
          "default": [
          ],
          "description": "List of task-specific routes. Pulse messages about the task will be CC'ed to\n`route.<value>` for each `<value>` in this array.\n\nThis array has a maximum size due to a limitation of the AMQP protocol,\nover which Pulse runs.  All routes must fit in the same \"frame\" of this\nprotocol, and the frames have a fixed maximum size (typically 128k).\n",
          "items": {
            "description": "A task specific route.\n",
            "maxLength": 249,
            "minLength": 1,
            "title": "Task Specific Route",
            "type": "string"
          },
          "maxItems": 64,
          "title": "Task Specific Routes",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "default": "-",
          "description": "All tasks in a task group must have the same `schedulerId`. This is used for several purposes:\n\n* it can represent the entity that created the task;\n* it can limit addition of new tasks to a task group: the caller of\n    `createTask` must have a scope related to the `schedulerId` of the task\n    group;\n* it controls who can manipulate tasks, again by requiring\n    `schedulerId`-related scopes; and\n* it appears in the routing key for Pulse messages about the task.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes that the task is authorized to use during its execution.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "title": "Scopes",
          "type": "array",
          "uniqueItems": false
        },
        "tags": {
          "additionalProperties": {
            "maxLength": 4096,
            "type": "string"
          },
          "default": {
          },
          "description": "Arbitrary key-value tags (only strings limited to 4k). These can be used\nto attach informal metadata to a task. Use this for informal tags that\ntasks can be classified by. You can also think of strings here as\ncandidates for formal metadata. Something like\n`purpose: 'build' || 'test'` is a good example.\n",
          "title": "Tags",
          "type": "object"
        },
        "taskGroupId": {
          "description": "Identifier for a group of tasks scheduled together with this task.\nGenerally, all tasks related to a single event such as a version-control\npush or a nightly build have the same `taskGroupId`.  This property\ndefaults to `taskId` if it isn't specified.  Tasks with `taskId` equal to\nthe `taskGroupId` are, [by convention](/docs/manual/using/task-graph),\ndecision tasks.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "workerPoolId": {
          "description": "Unique identifier for a worker pool\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Pool Id",
          "type": "string"
        },
        "workerType": {
          "description": "Unique identifier for a worker-type within a specific\nprovisioner. Deprecation is planned for this property as it will\nbe replaced, together with `provisionerId`, by the new\nidentifier `workerPoolId`.\n",
          "pattern": "^[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Type",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "workerPoolId",
        "schedulerId",
        "taskGroupId",
        "dependencies",
        "requires",
        "routes",
        "priority",
        "retries",
        "created",
        "deadline",
        "scopes",
        "payload",
        "metadata",
        "tags",
        "extra"
      ],
      "title": "Task Definition Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/task.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/task-run.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A run of a task.\n",
      "properties": {
        "runId": {
          "description": "Id of this task run, `run-id`s always starts from `0`\n",
          "maximum": 1000,
          "minimum": 0,
          "title": "Run Identifier",
          "type": "integer"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "runId"
      ],
      "title": "Task Run",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/task-run.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/reregister-worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response body to `reregisterWorker`.",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "The credentials the worker\nwill need to perform its work. Specifically, credentials with scopes\n* `assume:worker-pool:<workerPoolId>`\n* `assume:worker-id:<workerGroup>/<workerId>`\n* `queue:worker-id:<workerGroup>/<workerId>`\n* `secrets:get:worker-pool:<workerPoolId>`\n* `queue:claim-work:<workerPoolId>`\n* `worker-manager:remove-worker:<workerPoolId>/<workerGroup>/<workerId>`\n* `worker-manager:reregister-worker:<workerPoolId>/<workerGroup>/<workerId>`\n",
          "properties": {
            "accessToken": {
              "type": "string"
            },
            "certificate": {
              "description": "Note that a certificate may not be provided, if the credentials are not temporary.\n",
              "type": "string"
            },
            "clientId": {
              "type": "string"
            }
          },
          "required": [
            "accessToken",
            "clientId"
          ],
          "title": "Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Time at which the included credentials will expire. Workers must\nre-register before this time.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "secret": {
          "description": "The next secret value needed to reregister the worker (in `reregisterWorker).\nFor more information, refer to https://docs.taskcluster.net/docs/reference/core/worker-manager#reregistration.\n",
          "pattern": "^[a-zA-Z0-9_-]{44}$",
          "title": "Secret",
          "type": "string"
        }
      },
      "required": [
        "expires",
        "credentials",
        "secret"
      ],
      "title": "Reregister Worker Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/reregister-worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/reregister-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request body to `reregisterWorker`.",
      "properties": {
        "secret": {
          "description": "The secret value that was last configured in `registerWorker` (in the case of a newly registerd worker) or\n`reregisterWorker`.\nFor more information, refer to https://docs.taskcluster.net/docs/reference/core/worker-manager#reregistration.\n",
          "pattern": "^[a-zA-Z0-9_-]{44}$",
          "title": "Secret",
          "type": "string"
        },
        "workerGroup": {
          "$ref": "worker-full.json#/properties/workerGroup"
        },
        "workerId": {
          "$ref": "worker-full.json#/properties/workerId"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "workerGroup",
        "workerId",
        "secret"
      ],
      "title": "Reregister Worker Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/reregister-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/report-worker-error-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A report of an error from a worker.  This will be recorded with kind\n`worker-error`.\n\nThe worker's `workerGroup` and `workerId` will be added to `extra`.\n",
      "properties": {
        "description": {
          "$ref": "worker-pool-error.json#/properties/description"
        },
        "extra": {
          "$ref": "worker-pool-error.json#/properties/extra"
        },
        "kind": {
          "$ref": "worker-pool-error.json#/properties/kind"
        },
        "title": {
          "$ref": "worker-pool-error.json#/properties/title"
        },
        "workerGroup": {
          "$ref": "worker-full.json#/properties/workerGroup"
        },
        "workerId": {
          "$ref": "worker-full.json#/properties/workerId"
        }
      },
      "required": [
        "workerGroup",
        "workerId",
        "kind",
        "title",
        "description",
        "extra"
      ],
      "title": "Worker Error Report",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/report-worker-error-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/register-worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response body to `registerWorker`.",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "The credentials the worker\nwill need to perform its work.  Specifically, credentials with scopes\n* `assume:worker-pool:<workerPoolId>`\n* `assume:worker-id:<workerGroup>/<workerId>`\n* `queue:worker-id:<workerGroup>/<workerId>`\n* `secrets:get:worker-pool:<workerPoolId>`\n* `queue:claim-work:<workerPoolId>`\n* `worker-manager:remove-worker:<workerPoolId>/<workerGroup>/<workerId>`\n",
          "properties": {
            "accessToken": {
              "type": "string"
            },
            "certificate": {
              "description": "Note that a certificate may not be provided, if the credentials are not temporary.\n",
              "type": "string"
            },
            "clientId": {
              "type": "string"
            }
          },
          "required": [
            "accessToken",
            "clientId"
          ],
          "title": "Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Time at which the included credentials will expire.  Workers must either\nre-register (for static workers) or terminate (for dynamically\nprovisioned workers) before this time.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "secret": {
          "description": "A secret value generated by worker-manager that can be used in the call to `reregisterWorker`.\nFor more information, refer to https://docs.taskcluster.net/docs/reference/core/worker-manager#reregistration.\n",
          "pattern": "^[a-zA-Z0-9_-]{44}$",
          "title": "Secret",
          "type": "string"
        },
        "workerConfig": {
          "additionalProperties": true,
          "description": "This value is supplied unchanged to the worker from the worker-pool configuration.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [worker-runner](https://docs.taskcluster.net/docs/reference/workers/worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://docs.taskcluster.net/docs/reference/workers/worker-runner).\n",
          "title": "Worker Config",
          "type": "object"
        }
      },
      "required": [
        "expires",
        "credentials",
        "workerConfig",
        "secret"
      ],
      "title": "Register Worker Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/register-worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/register-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request body to `registerWorker`.",
      "properties": {
        "providerId": {
          "$ref": "worker-full.json#/properties/providerId"
        },
        "workerGroup": {
          "$ref": "worker-full.json#/properties/workerGroup"
        },
        "workerId": {
          "$ref": "worker-full.json#/properties/workerId"
        },
        "workerIdentityProof": {
          "description": "Proof that this call is coming from the worker identified by the other fields.\nThe form of this proof varies depending on the provider type.\n",
          "oneOf": [
            {
              "additionalProperties": false,
              "properties": {
                "token": {
                  "description": "A JWT token as defined in [this google documentation](https://cloud.google.com/compute/docs/instances/verifying-instance-identity)\n",
                  "title": "Token",
                  "type": "string"
                }
              },
              "required": [
                "token"
              ],
              "title": "google provider type",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "staticSecret": {
                  "description": "The secret value that was configured when the worker was created (in `createWorker`).\n",
                  "pattern": "^[a-zA-Z0-9_-]{44}$",
                  "title": "Secret",
                  "type": "string"
                }
              },
              "required": [
                "staticSecret"
              ],
              "title": "static provider type",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "document": {
                  "description": "Instance identity document that is obtained by\ncurl http://169.254.169.254/latest/dynamic/instance-identity/document on the instance\n",
                  "title": "Document",
                  "type": "string"
                },
                "signature": {
                  "description": "The signature for instance identity document. Can be obtained by\ncurl http://169.254.169.254/latest/dynamic/instance-identity/signature on the instance\n",
                  "title": "Signature",
                  "type": "string"
                }
              },
              "required": [
                "document",
                "signature"
              ],
              "title": "aws provider type",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "document": {
                  "description": "Attested data document that is obtained by\ncurl http://169.254.169.254/metadata/attested/document on the instance\n",
                  "title": "Document",
                  "type": "string"
                }
              },
              "required": [
                "document"
              ],
              "title": "azure provider type",
              "type": "object"
            }
          ],
          "title": "Worker Identity Proof"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "providerId",
        "workerGroup",
        "workerId",
        "workerIdentityProof"
      ],
      "title": "Register Worker Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/register-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/pulse-worker-pool-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "The message that is emitted when worker pools are created/changed/deleted.",
      "properties": {
        "previousProviderId": {
          "description": "If this is defined, it was the provider that handled this worker pool in the\nconfiguration before the current one. This will be used by providers to clean\nup any resources created for this workerType when they are no longer responsible\nfor it.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Previous Provider",
          "type": "string"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "providerId"
      ],
      "title": "WorkerType Pulse Message",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/pulse-worker-pool-message.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/provider-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of providers",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "providers": {
          "description": "List of all providers",
          "items": {
            "additionalProperties": false,
            "properties": {
              "providerId": {
                "description": "The id of this provider",
                "title": "Provider ID",
                "type": "string"
              },
              "providerType": {
                "description": "The provider implementation underlying this provider",
                "title": "Provider Type",
                "type": "string"
              }
            },
            "required": [
              "providerId",
              "providerType"
            ],
            "type": "object"
          },
          "title": "Providers",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "providers"
      ],
      "title": "Provider List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/provider-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/list-workers-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkers` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-type.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of workers in this worker-type.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "capacity": {
                "description": "Number of tasks this worker can handle at once. A worker capacity of 0 means\nthe worker is not managed by worker manager and is only known to the queue, the\ntrue capacity is not known.\n",
                "minimum": 0,
                "title": "Worker Capacity",
                "type": "integer"
              },
              "firstClaim": {
                "description": "Date of the first time this worker claimed a task.\n",
                "format": "date-time",
                "title": "First task claimed",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date of the last time this worker was seen active. Updated each time a worker calls\n`queue.claimWork`, `queue.reclaimTask`, and `queue.declareWorker` for this task queue.\n`lastDateActive` is updated every half hour but may be off by up-to half an hour.\nNonetheless, `lastDateActive` is a good indicator of when the worker was last seen active.\nThis defaults to null in the database, and is set to the current time when the worker\nis first seen.\n",
                "format": "date-time",
                "title": "Worker Last Date Active",
                "type": "string"
              },
              "latestTask": {
                "$ref": "task-run.json#",
                "description": "The most recent claimed task\n",
                "title": "Most Recent Task"
              },
              "providerId": {
                "description": "The provider that had started the worker and responsible for managing it.\nCan be different from the provider that's currently in the worker pool config.\nA providerId of \"none\" is used when the worker is not managed by worker manager.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Provider",
                "type": "string"
              },
              "quarantineUntil": {
                "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
                "format": "date-time",
                "title": "Worker Quarantine",
                "type": "string"
              },
              "state": {
                "description": "A string specifying the state this worker is in so far as worker-manager knows.\nA \"requested\" worker is in the process of starting up, and if successful will enter\nthe \"running\" state once it has registered with the `registerWorker` API method.  A\n\"stopping\" worker is in the process of shutting down and deleting resources, while\na \"stopped\" worker is completely stopped.  Stopped workers are kept for historical\npurposes and are purged when they expire.  Note that some providers transition workers\ndirectly from \"running\" to \"stopped\".\nAn \"standalone\" worker is a worker that is not managed by worker-manager, these workers\nare only known by the queue.\n",
                "enum": [
                  "requested",
                  "running",
                  "stopping",
                  "stopped",
                  "standalone"
                ],
                "title": "State",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for the worker group containing this worker.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for this worker (unique within this worker group).\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerPoolId": {
                "$ref": "task.json#/properties/workerPoolId"
              }
            },
            "required": [
              "workerGroup",
              "workerId",
              "firstClaim"
            ],
            "title": "Worker",
            "type": "object"
          },
          "title": "Workers from a WorkerType",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "List Workers Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/list-workers-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/create-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to create or update a worker. Capacity will default to 1 if not specified.",
      "properties": {
        "capacity": {
          "$ref": "worker-full.json#/properties/capacity"
        },
        "expires": {
          "description": "Date and time when this worker will be deleted from the DB",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "providerInfo": {
          "description": "Provider-specific information",
          "oneOf": [
            {
              "additionalProperties": false,
              "properties": {
                "staticSecret": {
                  "description": "A secret value shared with the worker.  This value must be passed in the `workerIdentityProof` of the `registerWorker` method.\nThe ideal way to generate a secret of this form is `slugid() + slugid()`.\n\nSecrets are traded for Taskcluster credentials, and should be treated with similar care.\nEach worker should have a distinct secret.\n",
                  "pattern": "^[a-zA-Z0-9_-]{44}$",
                  "title": "Secret",
                  "type": "string"
                }
              },
              "required": [
                "staticSecret"
              ],
              "title": "static provider type",
              "type": "object"
            }
          ],
          "title": "Provider Data"
        }
      },
      "required": [
        "expires"
      ],
      "title": "Worker Creation/Update Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/create-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/create-worker-pool-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Fields that are defined by a user for a worker pool.\nUsed to create worker-pool definitions. There is a larger\nset of fields for viewing since some parts are generated\nby the service.\n",
      "properties": {
        "config": {
          "$ref": "worker-pool-full.json#/properties/config"
        },
        "description": {
          "$ref": "worker-pool-full.json#/properties/description"
        },
        "emailOnError": {
          "$ref": "worker-pool-full.json#/properties/emailOnError"
        },
        "owner": {
          "$ref": "worker-pool-full.json#/properties/owner"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        }
      },
      "required": [
        "providerId",
        "description",
        "config",
        "owner",
        "emailOnError"
      ],
      "title": "Worker Pool Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/create-worker-pool-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-testing.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A provider used for testing",
      "title": "Testing Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-testing.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-static.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A configuration for static workertypes",
      "properties": {
        "lifecycle": {
          "additionalProperties": false,
          "description": "The Static provider implements a subset of the lifecycle hooks,\nonly supporting reregistration timeouts\n",
          "properties": {
            "reregistrationTimeout": {
              "$ref": "worker-lifecycle.json#/properties/reregistrationTimeout"
            }
          },
          "required": [
          ],
          "type": "object"
        },
        "workerConfig": {
          "additionalProperties": true,
          "description": "This value is supplied unchanged to the worker from the provider configuration.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [worker-runner](https://docs.taskcluster.net/docs/reference/workers/worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://docs.taskcluster.net/docs/reference/workers/worker-runner).\n",
          "title": "Worker Config",
          "type": "object"
        }
      },
      "required": [
      ],
      "title": "Static Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-static.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-null.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "A special provider indicating that no provisioning takes place.\n\nNote that this provider allows any configuration, but ignores it. This saves\nthe trouble of removing the config from a worker-pool when deleting it.\n",
      "title": "Null Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-null.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-google.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "'The config section of a workertype is using a provider with implementation google must match this.\nMuch of these fields are documented [here](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates)'\n",
      "properties": {
        "launchConfigs": {
          "description": "An array of possible variations of workers for this pool. Allows to vary across regions/zones/machineType/etc\nEach choice must include at least the required properties but can also include anything in\nthe request body of [the instance creation](https://cloud.google.com/compute/docs/reference/rest/beta/instances/insert)\napi method from gcloud. That said, worker-manager sets `instanceName` and `serviceAccounts` directly and you\ncannot override these. It also fills in some basic labels, will generate a default description, and sets the `taskcluster`\nmetadata key directly. You are free to set other metadata items though. A subset of these fields we require you to set such as `machineType`.\n",
          "items": {
            "additionalProperties": true,
            "properties": {
              "capacityPerInstance": {
                "description": "The number of tasks a single worker of this type can run at any given time.",
                "minimum": 1,
                "title": "Capacity Per Instance",
                "type": "integer"
              },
              "disks": {
                "description": "Defined in detail in the google doc above.",
                "title": "Disks",
                "type": "array",
                "uniqueItems": false
              },
              "machineType": {
                "description": "Full or partial URL of the machine type resource to use. Defined in detail in the google doc above",
                "title": "Machine Type",
                "type": "string"
              },
              "networkInterfaces": {
                "description": "Defined in detail in the google doc above.",
                "title": "Network Interfaces",
                "type": "array",
                "uniqueItems": false
              },
              "region": {
                "description": "The gcloud region this worker should be spawned in",
                "title": "Region",
                "type": "string"
              },
              "scheduling": {
                "additionalProperties": true,
                "description": "Defined in detail in the google doc above. Worker manager harcodes values for `automaticRestart` but\nyou can set all other fields.\n",
                "title": "Scheduling",
                "type": "object"
              },
              "workerConfig": {
                "additionalProperties": true,
                "description": "This value is supplied unchanged as the `workerConfig` property of the `taskcluster` instance metadata attribute.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [worker-runner](https://docs.taskcluster.net/docs/reference/workers/worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://docs.taskcluster.net/docs/reference/workers/worker-runner).\n",
                "title": "Worker Config",
                "type": "object"
              },
              "zone": {
                "description": "The gcloud az this worker should be spawned in. This az must be included because many resources (such as\nmachine types and disk types) are az-specific.\n",
                "title": "Availability Zone",
                "type": "string"
              }
            },
            "required": [
              "capacityPerInstance",
              "workerConfig",
              "region",
              "zone",
              "machineType",
              "disks",
              "networkInterfaces",
              "scheduling"
            ],
            "type": "object"
          },
          "title": "Choices",
          "type": "array",
          "uniqueItems": false
        },
        "lifecycle": {
          "$ref": "worker-lifecycle.json#"
        },
        "maxCapacity": {
          "description": "The maximum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "The minimum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Minimum Capacity",
          "type": "integer"
        },
        "scalingRatio": {
          "description": "The scaling ratio is a ratio of worker capacity to pending tasks - a ratio of 1.0 means that 1 capacity will be added for each pending task\n",
          "maximum": 1,
          "minimum": 0,
          "title": "Scaling Ratio",
          "type": "number"
        }
      },
      "required": [
        "minCapacity",
        "maxCapacity",
        "launchConfigs"
      ],
      "title": "Google Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-google.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-azure.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "'The config section of a workertype is using a provider with implementation azure must match this.\nMuch of these fields are documented [here](https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate)'\n",
      "properties": {
        "launchConfigs": {
          "description": "An array of possible variations of workers for this pool.\nEach choice must include at least the required properties but can also include anything in\nthe request body of [the virtual machine creation](https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate)\napi method. worker-manager sets the values of the `osProfile.adminPassword`, `osProfile.computerName`, `osProfile.customData`, `networkProfile.networkInterfaces`\nproperties directly, and they cannot be overriden. It also fills in some basic labels, will generate a default description, and sets the `taskcluster`\nmetadata key directly. You are free to set other metadata items though. A subset of these fields we require you to set such as `machineType`.\n",
          "items": {
            "additionalProperties": true,
            "properties": {
              "billingProfile": {
                "additionalProperties": true,
                "description": "https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#billingprofile",
                "properties": {
                  "maxPrice": {
                    "description": "the maximum price to pay for a spot virtual machine in US Dollars",
                    "title": "Max Price",
                    "type": "number"
                  }
                },
                "required": [
                ],
                "title": "Billing Profile",
                "type": "object"
              },
              "capacityPerInstance": {
                "description": "The number of tasks a single worker of this type can run at any given time.",
                "minimum": 1,
                "title": "Capacity Per Instance",
                "type": "integer"
              },
              "hardwareProfile": {
                "additionalProperties": true,
                "description": "https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#hardwareprofile",
                "properties": {
                  "vmSize": {
                    "title": "Virtual machine type",
                    "type": "string"
                  }
                },
                "required": [
                  "vmSize"
                ],
                "title": "Hardware Profile",
                "type": "object"
              },
              "ignoreFailedProvisioningStates": {
                "description": "A list of provisioning state codes (see the [Azure documentation](https://docs.microsoft.com/en-us/azure/virtual-machines/states-lifecycle)) that\nshould be ignored and treated as success if the VM is running.  The most common choice is `[\"OSProvisioningTimedOut\"]`, which ignores failure\nto start the Azure VM Agent.  This is appropriate on systems that do not or cannot run the agent.\n",
                "items": {
                  "type": "string"
                },
                "title": "Ignore failed provisioningStates",
                "type": "array",
                "uniqueItems": true
              },
              "location": {
                "description": "The Azure location this worker should be spawned in",
                "title": "Location",
                "type": "string"
              },
              "networkProfile": {
                "additionalProperties": true,
                "description": "Container object for network interfaces for the VM\nSee here: https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#networkprofile\n",
                "properties": {
                  "networkInterfaces": {
                    "items": {
                      "additionalProperties": true,
                      "properties": {
                        "id": {
                          "type": "string"
                        },
                        "primary": {
                          "type": "boolean"
                        }
                      },
                      "required": [
                      ],
                      "title": "Network Interface Reference",
                      "type": "object"
                    },
                    "title": "Network Interfaces",
                    "type": "array",
                    "uniqueItems": false
                  }
                },
                "required": [
                  "networkInterfaces"
                ],
                "title": "Network Profile",
                "type": "object"
              },
              "osProfile": {
                "additionalProperties": true,
                "description": "adminPassword, computerName, and customData are set by the provider and are not configurable\nhttps://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#osprofile\n",
                "required": [
                ],
                "title": "OS Profile",
                "type": "object"
              },
              "priority": {
                "description": "virtual machine priority, i.e. Spot\nhttps://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#virtualmachineprioritytypes\n",
                "title": "Priority",
                "type": "string"
              },
              "storageProfile": {
                "additionalProperties": true,
                "properties": {
                  "dataDisks": {
                    "items": {
                      "additionalProperties": true,
                      "description": "See https://docs.microsoft.com/en-us/javascript/api/@azure/arm-compute/datadisk.\nNote that naming disks is not supported; any provided name will be overwritten with a\ndynamically generated name.\n",
                      "properties": {
                      },
                      "required": [
                      ],
                      "title": "Data Disk",
                      "type": "object"
                    },
                    "title": "Data Disks",
                    "type": "array",
                    "uniqueItems": false
                  },
                  "imageReference": {
                    "additionalProperties": true,
                    "description": "https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#imagereference",
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "required": [
                    ],
                    "type": "object"
                  },
                  "osDisk": {
                    "additionalProperties": true,
                    "description": "See https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#osdisk.\nNote that naming disks is not supported; any provided name will be overwritten with a\ndynamically generated name.\n",
                    "properties": {
                      "createOption": {
                        "description": "FromImage creates the disk from the specified image\nhttps://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/createorupdate#diskcreateoptiontypes\n",
                        "type": "string"
                      }
                    },
                    "required": [
                    ],
                    "title": "OS Disk",
                    "type": "object"
                  }
                },
                "required": [
                  "osDisk"
                ],
                "title": "Storage Profile",
                "type": "object"
              },
              "subnetId": {
                "description": "The ID of the subnet workers should be spawned in",
                "title": "Subnet ID",
                "type": "string"
              },
              "workerConfig": {
                "additionalProperties": true,
                "description": "This value is supplied unchanged as the `workerConfig` property of the `taskcluster` instance metadata attribute.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [worker-runner](https://docs.taskcluster.net/docs/reference/workers/worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://docs.taskcluster.net/docs/reference/workers/worker-runner).\n",
                "title": "Worker Config",
                "type": "object"
              }
            },
            "required": [
              "capacityPerInstance",
              "workerConfig",
              "location",
              "subnetId",
              "hardwareProfile",
              "storageProfile"
            ],
            "type": "object"
          },
          "title": "Choices",
          "type": "array",
          "uniqueItems": false
        },
        "lifecycle": {
          "$ref": "worker-lifecycle.json#"
        },
        "maxCapacity": {
          "description": "The maximum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "The minimum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Minimum Capacity",
          "type": "integer"
        },
        "scalingRatio": {
          "description": "The scaling ratio is a ratio of worker capacity to pending tasks - a ratio of 1.0 means that 1 capacity will be added for each pending task\n",
          "maximum": 1,
          "minimum": 0,
          "title": "Scaling Ratio",
          "type": "number"
        }
      },
      "required": [
        "minCapacity",
        "maxCapacity",
        "launchConfigs"
      ],
      "title": "Azure Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-azure.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-aws.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Object with an array of possible options for different regions",
      "properties": {
        "launchConfigs": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "additionalUserData": {
                "additionalProperties": true,
                "properties": {
                  "providerId": {
                    "not": {
                    }
                  },
                  "rootUrl": {
                    "not": {
                    }
                  },
                  "workerConfig": {
                    "not": {
                    }
                  },
                  "workerGroup": {
                    "not": {
                    }
                  },
                  "workerPoolId": {
                    "not": {
                    }
                  }
                },
                "required": [
                ],
                "type": "object"
              },
              "capacityPerInstance": {
                "description": "The number of tasks a single worker of this type can run at any given time.",
                "minimum": 1,
                "title": "Capacity Per Instance",
                "type": "integer"
              },
              "launchConfig": {
                "additionalProperties": true,
                "description": "An object to be passed in to AWS runInstances method.\nSee the documentation [here](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/EC2.html#runInstances-property)\nYou can configure any properties you need. Note, however, that we disallow passing in arbitrary IAM instance profiles.\n",
                "not": {
                  "required": [
                    "IamInstanceProfile",
                    "UserData",
                    "MinCount",
                    "MaxCount"
                  ]
                },
                "properties": {
                  "ImageId": {
                    "description": "The ID of the AMI to launch an instance from.",
                    "type": "string"
                  }
                },
                "required": [
                  "ImageId"
                ],
                "title": "Launch Configuration",
                "type": "object"
              },
              "region": {
                "description": "AWS region (not to be confused with AZ) to launch the instances in",
                "title": "Region",
                "type": "string"
              },
              "workerConfig": {
                "additionalProperties": true,
                "description": "This value is supplied unchanged as the `workerConfig` property of the `taskcluster` instance metadata attribute.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [worker-runner](https://docs.taskcluster.net/docs/reference/workers/worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://docs.taskcluster.net/docs/reference/workers/worker-runner).\n",
                "title": "Worker Config",
                "type": "object"
              }
            },
            "required": [
              "region",
              "launchConfig",
              "capacityPerInstance"
            ],
            "type": "object"
          },
          "title": "Launch Configurations",
          "type": "array",
          "uniqueItems": true
        },
        "lifecycle": {
          "$ref": "worker-lifecycle.json#"
        },
        "maxCapacity": {
          "description": "Maximum capacity that should not be exceeded at any given time for the entire workerpool",
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "Minimum capacity necessary to maintain at any given time for the entire workerpool",
          "title": "Minimum Capacity",
          "type": "integer"
        },
        "scalingRatio": {
          "description": "The scaling ratio is a ratio of worker capacity to pending tasks - a ratio of 1.0 means that 1 capacity will be added for each pending task\n",
          "maximum": 1,
          "minimum": 0,
          "title": "Scaling Ratio",
          "type": "number"
        }
      },
      "required": [
        "launchConfigs",
        "minCapacity",
        "maxCapacity"
      ],
      "title": "AWS Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-aws.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a Taskcluster Secret\n",
      "properties": {
        "expires": {
          "description": "An expiration date for this secret.\n",
          "format": "date-time",
          "type": "string"
        },
        "secret": {
          "description": "The secret value to be encrypted.\n",
          "type": "object"
        }
      },
      "required": [
        "secret",
        "expires"
      ],
      "title": "Secret",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a list of secret names\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "secrets": {
          "description": "Secret names",
          "items": {
            "description": "Secret name",
            "title": "Secret",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "secrets"
      ],
      "title": "Secrets List",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret-list.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/workertype-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a worker-type request from a provisioner.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker-type` are included.\n",
                "enum": [
                  "worker-type"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker-type Action",
            "type": "object"
          },
          "title": "Worker-type Actions",
          "type": "array",
          "uniqueItems": false
        },
        "description": {
          "description": "Description of the worker-type.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this worker-type was seen active. `lastDateActive` is updated every half hour\nbut may be off by up-to half an hour. Nonetheless, `lastDateActive` is a good indicator\nof when the worker-type was last seen active.\n",
          "format": "date-time",
          "title": "Worker-type Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "stability": {
          "description": "This is the stability of the worker-type. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "workerType",
        "provisionerId",
        "taskQueueId",
        "description",
        "stability",
        "expires",
        "lastDateActive",
        "actions"
      ],
      "title": "Worker-type Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/workertype-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a worker.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker` are included.\n",
                "enum": [
                  "worker"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker Action",
            "type": "object"
          },
          "title": "Worker Actions",
          "type": "array",
          "uniqueItems": false
        },
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        },
        "firstClaim": {
          "description": "Date of the first time this worker claimed a task.\n",
          "format": "date-time",
          "title": "First task claimed",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this worker was seen active. Updated each time a worker calls\n`queue.claimWork`, `queue.reclaimTask`, and `queue.declareWorker` for this task queue.\n`lastDateActive` is updated every half hour but may be off by up-to half an hour.\nNonetheless, `lastDateActive` is a good indicator of when the worker was last seen active.\nThis defaults to null in the database, and is set to the current time when the worker\nis first seen.\n",
          "format": "date-time",
          "title": "Worker Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        },
        "recentTasks": {
          "description": "List of 20 most recent tasks claimed by the worker.\n",
          "items": {
            "$ref": "task-run.json#"
          },
          "title": "Most Recent Tasks",
          "type": "array",
          "uniqueItems": false
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        },
        "workerGroup": {
          "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Group",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker evaluating this run within given\n`workerGroup`.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Identifier",
          "type": "string"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "workerGroup",
        "workerId",
        "recentTasks",
        "expires",
        "firstClaim",
        "actions"
      ],
      "title": "Worker Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-workertype-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker-type.\n",
      "properties": {
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker-type Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-workertype-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-provisioner-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Provisioner Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-provisioner-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/taskqueue-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a task queue request from a provisioner.\n",
      "properties": {
        "description": {
          "description": "Description of the task queue.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the task queue will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Task queue Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this task queue was seen active. Updated each time a worker calls\n`queue.claimWork`, `queue.reclaimTask`, and `queue.declareWorker` for this task queue.\n`lastDateActive` is updated every half hour but may be off by up-to half an hour.\nNonetheless, `lastDateActive` is a good indicator of when the task queue was last seen active.\n",
          "format": "date-time",
          "title": "Task queue Last Date Active",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the task queue. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        }
      },
      "required": [
        "taskQueueId",
        "description",
        "stability",
        "expires",
        "lastDateActive"
      ],
      "title": "Task queue Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/taskqueue-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, by which this task must be complete. `pending` and\n`running` runs are resolved as **exception** if not resolved by other means\nbefore the deadline. After the deadline, a task is immutable. Note,\ndeadline cannot be more than 5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "default": [
          ],
          "description": "List of dependent tasks. These must either be _completed_ or _resolved_\nbefore this task is scheduled. See `requires` for semantics.\n",
          "items": {
            "description": "The `taskId` of a task that must be resolved before this task is\nscheduled.\n",
            "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
            "title": "Task Dependency",
            "type": "string"
          },
          "maxItems": 100,
          "title": "Task Dependencies",
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Task expiration, time at which task definition and status is deleted.\nNotice that all artifacts for the task must have an expiration that is no\nlater than this. If this property isn't it will be set to `deadline`\nplus one year (this default may change).\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "extra": {
          "default": {
          },
          "description": "Object with properties that can hold any kind of extra data that should be\nassociated with the task. This can be data for the task which doesn't\nfit into `payload`, or it can supplementary data for use in services\nlistening for events from this task. For example this could be details to\ndisplay on dashboard, or information for indexing the task. Please, try\nto put all related information under one property, so `extra` data keys\ndon't conflict.  **Warning**, do not stuff large data-sets in here --\ntask definitions should not take-up multiple MiBs.\n",
          "title": "Extra Data",
          "type": "object"
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "description": "Task-specific payload following worker-specific format.\nRefer to the documentation for the worker implementing\n`<provisionerId>/<workerType>` for details.\n",
          "title": "Task Payload",
          "type": "object"
        },
        "priority": {
          "default": "lowest",
          "description": "Priority of task. This defaults to `lowest` and the scope\n`queue:create-task:<priority>/<provisionerId>/<workerType>` is required\nto define a task with `<priority>`. The `normal` priority is treated as\n`lowest`.\n",
          "enum": [
            "highest",
            "very-high",
            "high",
            "medium",
            "low",
            "very-low",
            "lowest",
            "normal"
          ],
          "title": "Task Priority",
          "type": "string"
        },
        "projectId": {
          "default": "none",
          "description": "The name for the \"project\" with which this task is associated.  This\nvalue can be used to control permission to manipulate tasks as well as\nfor usage reporting.  Project ids are typically simple identifiers,\noptionally in a hierarchical namespace separated by `/` characters.\nThis value defaults to `none`.\n",
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        },
        "provisionerId": {
          "description": "Unique identifier for a provisioner, that can supply specified\n`workerType`. Deprecation is planned for this property as it\nwill be replaced, together with `workerType`, by the new\nidentifier `taskQueueId`.\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}$",
          "title": "Provisioner Id",
          "type": "string"
        },
        "requires": {
          "default": "all-completed",
          "description": "The tasks relation to its dependencies. This property specifies the\nsemantics of the `task.dependencies` property.\nIf `all-completed` is given the task will be scheduled when all\ndependencies are resolved _completed_ (successful resolution).\nIf `all-resolved` is given the task will be scheduled when all dependencies\nhave been resolved, regardless of what their resolution is.\n",
          "enum": [
            "all-completed",
            "all-resolved"
          ],
          "title": "Dependency Requirement Semantics",
          "type": "string"
        },
        "retries": {
          "default": 5,
          "description": "Number of times to retry the task in case of infrastructure issues.\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\nthese events are to be expected.\n",
          "maximum": 49,
          "minimum": 0,
          "title": "Retries",
          "type": "integer"
        },
        "routes": {
          "default": [
          ],
          "description": "List of task-specific routes. Pulse messages about the task will be CC'ed to\n`route.<value>` for each `<value>` in this array.\n\nThis array has a maximum size due to a limitation of the AMQP protocol,\nover which Pulse runs.  All routes must fit in the same \"frame\" of this\nprotocol, and the frames have a fixed maximum size (typically 128k).\n",
          "items": {
            "description": "A task specific route.\n",
            "maxLength": 249,
            "minLength": 1,
            "title": "Task Specific Route",
            "type": "string"
          },
          "maxItems": 64,
          "title": "Task Specific Routes",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "default": "-",
          "description": "All tasks in a task group must have the same `schedulerId`. This is used for several purposes:\n\n* it can represent the entity that created the task;\n* it can limit addition of new tasks to a task group: the caller of\n    `createTask` must have a scope related to the `schedulerId` of the task\n    group;\n* it controls who can manipulate tasks, again by requiring\n    `schedulerId`-related scopes; and\n* it appears in the routing key for Pulse messages about the task.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes that the task is authorized to use during its execution.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "title": "Scopes",
          "type": "array",
          "uniqueItems": false
        },
        "tags": {
          "additionalProperties": {
            "maxLength": 4096,
            "type": "string"
          },
          "default": {
          },
          "description": "Arbitrary key-value tags (only strings limited to 4k). These can be used\nto attach informal metadata to a task. Use this for informal tags that\ntasks can be classified by. You can also think of strings here as\ncandidates for formal metadata. Something like\n`purpose: 'build' || 'test'` is a good example.\n",
          "title": "Tags",
          "type": "object"
        },
        "taskGroupId": {
          "description": "Identifier for a group of tasks scheduled together with this task.\nGenerally, all tasks related to a single event such as a version-control\npush or a nightly build have the same `taskGroupId`.  This property\ndefaults to `taskId` if it isn't specified.  Tasks with `taskId` equal to\nthe `taskGroupId` are, [by convention](/docs/manual/using/task-graph),\ndecision tasks.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "taskQueueId": {
          "description": "Unique identifier for a task queue\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Task Queue Id",
          "type": "string"
        },
        "workerType": {
          "description": "Unique identifier for a worker-type within a specific\nprovisioner. Deprecation is planned for this property as it will\nbe replaced, together with `provisionerId`, by the new\nidentifier `taskQueueId`.\n",
          "pattern": "^[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Type",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "taskQueueId",
        "schedulerId",
        "taskGroupId",
        "dependencies",
        "requires",
        "routes",
        "priority",
        "retries",
        "created",
        "deadline",
        "scopes",
        "payload",
        "metadata",
        "tags",
        "extra"
      ],
      "title": "Task Definition Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A representation of **task status** as known by the queue\n",
      "properties": {
        "deadline": {
          "description": "Deadline of the task, by which this task must be complete. `pending` and\n`running` runs are resolved as **exception** if not resolved by other means\nbefore the deadline. After the deadline, a task is immutable. Note,\ndeadline cannot be more than 5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "expires": {
          "description": "Task expiration, time at which task definition and\nstatus is deleted. Notice that all artifacts for the task\nmust have an expiration that is no later than this.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "projectId": {
          "$ref": "task.json#/properties/projectId"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "retriesLeft": {
          "description": "Number of retries left for the task in case of infrastructure issues\n",
          "maximum": 999,
          "minimum": 0,
          "title": "Retries Left",
          "type": "integer"
        },
        "runs": {
          "description": "List of runs, ordered so that index `i` has `runId == i`\n",
          "items": {
            "additionalProperties": false,
            "description": "JSON object with information about a run\n",
            "properties": {
              "reasonCreated": {
                "description": "Reason for the creation of this run,\n**more reasons may be added in the future**.\n",
                "enum": [
                  "scheduled",
                  "retry",
                  "task-retry",
                  "rerun",
                  "exception"
                ],
                "title": "Reason Created",
                "type": "string"
              },
              "reasonResolved": {
                "description": "Reason that run was resolved, this is mainly\nuseful for runs resolved as `exception`.\nNote, **more reasons may be added in the future**, also this\nproperty is only available after the run is resolved. Some of these\nreasons, notably `intermittent-task`, `worker-shutdown`, and\n`claim-expired`, will trigger an automatic retry of the task.\nNote that 'superseded' is here only for compatibility, as that\nfunctionality has been removed.\n",
                "enum": [
                  "completed",
                  "failed",
                  "deadline-exceeded",
                  "canceled",
                  "claim-expired",
                  "worker-shutdown",
                  "malformed-payload",
                  "resource-unavailable",
                  "internal-error",
                  "intermittent-task",
                  "superseded"
                ],
                "title": "Reason Resolved",
                "type": "string"
              },
              "resolved": {
                "description": "Date-time at which this run was resolved, ie. when the run changed\nstate from `running` to either `completed`, `failed` or `exception`.\nThis property is only present after the run as been resolved.\n",
                "format": "date-time",
                "title": "Resolved",
                "type": "string"
              },
              "runId": {
                "description": "Id of this task run, `run-id`s always starts from `0`\n",
                "maximum": 1000,
                "minimum": 0,
                "title": "Run Identifier",
                "type": "integer"
              },
              "scheduled": {
                "description": "Date-time at which this run was scheduled, ie. when the run was\ncreated in state `pending`.\n",
                "format": "date-time",
                "title": "Scheduled",
                "type": "string"
              },
              "started": {
                "description": "Date-time at which this run was claimed, ie. when the run changed\nstate from `pending` to `running`. This property is only present\nafter the run has been claimed.\n",
                "format": "date-time",
                "title": "Started",
                "type": "string"
              },
              "state": {
                "description": "State of this run\n",
                "enum": [
                  "pending",
                  "running",
                  "completed",
                  "failed",
                  "exception"
                ],
                "title": "Run State",
                "type": "string"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `failed`, if the\nrun isn't reclaimed. Note, only present after the run has been\nclaimed.\n",
                "format": "date-time",
                "title": "Taken Until",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\nNote, this property is only present after the run is claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Group",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for worker evaluating this run within given\n`workerGroup`. Note, this property is only available after the run\nhas been claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Identifier",
                "type": "string"
              }
            },
            "required": [
              "runId",
              "state",
              "reasonCreated",
              "scheduled"
            ],
            "title": "Run Information",
            "type": "object"
          },
          "title": "List of Runs",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "state": {
          "description": "State of this task. This is just an auxiliary property derived from state\nof latests run, or `unscheduled` if none.\n",
          "enum": [
            "unscheduled",
            "pending",
            "running",
            "completed",
            "failed",
            "exception"
          ],
          "title": "State",
          "type": "string"
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "taskId",
        "provisionerId",
        "workerType",
        "taskQueueId",
        "schedulerId",
        "projectId",
        "taskGroupId",
        "deadline",
        "expires",
        "retriesLeft",
        "state",
        "runs"
      ],
      "title": "Task Status Structure",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a task status request\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        }
      },
      "required": [
        "status"
      ],
      "title": "Task Status Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-running-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a given run of a task have started\n",
      "properties": {
        "runId": {
          "description": "Id of the run that just started, always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `failed`, if the run\nisn't reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil"
      ],
      "title": "Task Running Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-running-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-run.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A run of a task.\n",
      "properties": {
        "runId": {
          "description": "Id of this task run, `run-id`s always starts from `0`\n",
          "maximum": 1000,
          "minimum": 0,
          "title": "Run Identifier",
          "type": "integer"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "runId"
      ],
      "title": "Task Run",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-run.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-reclaim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "credentials"
      ],
      "title": "Task Reclaim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-reclaim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-pulse-definition.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Subset of a task definition containing values that are useful for determining\nwhether a message is interesting to the receiver. Where the full task\ndefinition is required, the receiver should call queue.task to download that\ndefinition.\n",
      "properties": {
        "tags": {
          "$ref": "task.json#/properties/tags"
        }
      },
      "required": [
        "tags"
      ],
      "title": "Task Definition Structure for Pulse Messages",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-pulse-definition.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-pending-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task is now pending\n",
      "properties": {
        "runId": {
          "description": "Id of run that became pending, `run-id`s always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "additionalProperties": false,
          "description": "Subset of a task definition\n",
          "properties": {
            "tags": {
              "$ref": "task.json#/properties/tags"
            }
          },
          "required": [
            "tags"
          ],
          "type": "object"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status",
        "runId"
      ],
      "title": "Task Pending Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-pending-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Required task metadata\n",
      "properties": {
        "description": {
          "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "name": {
          "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "Entity who caused this task, not necessarily a person with email who did\n`hg push` as it could be automation bots as well. The entity we should\ncontact to ask why this task is here.\n",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        },
        "source": {
          "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
          "format": "uri",
          "maxLength": 4096,
          "pattern": "^(https?|ssh)://",
          "title": "Source",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner",
        "source"
      ],
      "title": "Task Metadata",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-group-sealed.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message written once a task group has been sealed.\n",
      "properties": {
        "schedulerId": {
          "description": "Identifier for the scheduler that created this task-group.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "taskGroupId",
        "schedulerId"
      ],
      "title": "Task Group Sealed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-group-sealed.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-group-resolved.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message written once a task group has no tasks to be run. It is\npossible for a task group to later have another task added, in which\ncase this message will be sent again once it finishes.\n",
      "properties": {
        "schedulerId": {
          "description": "Identifier for the scheduler that created this task-group.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "taskGroupId",
        "schedulerId"
      ],
      "title": "Task Group Resolved Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-group-resolved.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-failed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task failed to complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that failed.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Failed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-failed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request for a run of a task to be resolved with an exception\n",
      "properties": {
        "reason": {
          "description": "Reason that the task is resolved with an exception. This is a subset\nof the values for `resolvedReason` given in the task status structure.\n\n* **Report `worker-shutdown`** if the run failed because the worker\nhad to shutdown (spot node disappearing). In case of `worker-shutdown`\nthe queue will immediately **retry** the task, by making a new run.\nThis is much faster than ignoreing the issue and letting the task _retry_\nby claim expiration. For any other _reason_ reported the queue will not\nretry the task.\n\n* **Report `malformed-payload`** if the `task.payload` doesn't match the\nschema for the worker payload, or referenced resource doesn't exists.\nIn either case, you should still log the error to a log file for the\nspecific run.\n\n* **Report `resource-unavailable`** if a resource/service needed or\nreferenced in `task.payload` is _temporarily_ unavailable. Do not use this\nunless you know the resource exists, if the resource doesn't exist you\nshould report `malformed-payload`. Example use-case if you contact the\nindex (a service) on behalf of the task, because of a declaration in\n`task.payload`, and the service (index) is temporarily down. Don't use\nthis if a URL returns 404, but if it returns 503 or hits a timeout when\nyou retry the request, then this _may_ be a valid exception. The queue\nassumes that workers have applied retries as needed, and will not retry\n the task.\n\n* **Report `internal-error`** if the worker experienced an unhandled internal\nerror from which it couldn't recover. The queue will not retry runs\nresolved with this reason, but you are clearly signaling that this is a\nbug in the worker code.\n\n* **Report `intermittent-task`** if the task explicitly requested a retry\nbecause task is intermittent. Workers can choose whether or not to\nsupport this, but workers shouldn't blindly report this for every task\nthat fails.\n",
          "enum": [
            "worker-shutdown",
            "malformed-payload",
            "resource-unavailable",
            "internal-error",
            "intermittent-task"
          ],
          "type": "string"
        }
      },
      "required": [
        "reason"
      ],
      "title": "Task Exception Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that Taskcluster have failed to run a task.\n",
      "properties": {
        "runId": {
          "description": "Id of the last run for the task, not provided if `deadline`\nwas exceeded before a run was started.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the last attempt of the task\nran. Not provided, if `deadline` was exceeded before a run was started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the last worker that failed to report, causing the task\nto fail. Not provided, if `deadline` was exceeded before a run\nwas started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Exception Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-definition-and-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Task Definition and task status structure.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task.json#"
        }
      },
      "required": [
        "task",
        "status"
      ],
      "title": "Task definition and status",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-definition-and-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-defined-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has been defined. The task may or may not be\n_scheduled_ too.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Defined Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-defined-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-credentials.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Temporary credentials granting `task.scopes` and the scope:\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\nthe task, upload artifacts and report task resolution.\n\nThe temporary credentials are set to expire after `takenUntil`. They\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\ncoming close `takenUntil` won't have problems even if there is a little\nclock drift.\n\nWorkers should use these credentials when making requests on behalf of\na task. This includes requests to create artifacts, reclaiming the task\nreporting the task `completed`, `failed` or `exception`.\n\nNote, a new set of temporary credentials is issued when the worker\nreclaims the task.\n",
      "properties": {
        "accessToken": {
          "description": "The `accessToken` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        },
        "certificate": {
          "description": "The `certificate` for the temporary credentials, these are required\nfor the temporary credentials to work.\n",
          "minLength": 1,
          "type": "string"
        },
        "clientId": {
          "description": "The `clientId` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "certificate"
      ],
      "title": "Task Credentials",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-credentials.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-completed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that completed the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Completed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-completed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "task": {
          "$ref": "task.json#"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "task",
        "credentials"
      ],
      "title": "Task Claim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim (or reclaim) a task\n",
      "properties": {
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId"
      ],
      "title": "Task Claim Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/seal-task-group-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `sealTaskGroup` request.\n",
      "properties": {
        "expires": {
          "description": "Date and time when task group expires.\n",
          "format": "date-time",
          "title": "Task group expiry date",
          "type": "string"
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "sealed": {
          "description": "Date and time when task group was sealed.\n",
          "format": "date-time",
          "title": "Sealing timestamp",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being sealed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskGroupId",
        "sealed",
        "expires",
        "schedulerId"
      ],
      "title": "Seal Task-Group Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/seal-task-group-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/quarantine-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker's quarantineUntil property.\n",
      "properties": {
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        }
      },
      "required": [
        "quarantineUntil"
      ],
      "title": "Quarantine Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/quarantine-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/provisioner-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this provisioner was seen active. `lastDateActive` is updated every half hour\nbut may be off by up-to half an hour. Nonetheless, `lastDateActive` is a good indicator\nof when the provisioner was last seen active.\n",
          "format": "date-time",
          "title": "Provisioner Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "description",
        "actions",
        "stability",
        "expires",
        "lastDateActive"
      ],
      "title": "Provisioner Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/provisioner-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response to a request for posting an artifact.\nNote that the `storageType` property is referenced in the request as well.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Response to a request for a signed PUT URL that will allow you to\nupload an artifact to an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, must be specified as header when uploading with\nthe signed `putUrl`.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the signed `putUrl` no longer works\n",
              "format": "date-time",
              "type": "string"
            },
            "putUrl": {
              "description": "URL to which a `PUT` request can be made to upload the artifact\nrequested. Note, the `Content-Length` must be specified correctly,\nand the `ContentType` header must be set the value specified below.\n",
              "format": "uri",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "putUrl",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Information supporting uploading an object to the object service.  This\nconsists of an object name and uploadId, together with credentials\nallowing an upload of the designated object to the service.  The\nresulting credentials are valid for 24 hours or until the artifact\nexpires, whichever is shorter, allowing ample time for any method\nnegotiation, retries, and so on.  The caller should call\n`object.createUpload` with the given credentials, and perform the upload.\nNote that the `uploadId`, `projectId`, and `expires` given to\n`createUpload` must match those in this response.  The caller should call\n`object.finishUpload` when the upload is finished, at which point the\nobject is immutable and the credentials are no longer useful.\n",
          "properties": {
            "credentials": {
              "$ref": "object-credentials.json#"
            },
            "expires": {
              "description": "Expiration time for the artifact.\n",
              "format": "date-time",
              "type": "string"
            },
            "name": {
              "description": "Name of the object on the object service.\n",
              "pattern": "^[\\x20-\\x7e]+$",
              "type": "string"
            },
            "projectId": {
              "description": "Project identifier.\n",
              "maxLength": 500,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9._/-]*)$",
              "title": "Project Identifier",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'object'`\n",
              "enum": [
                "object"
              ],
              "type": "string"
            },
            "uploadId": {
              "description": "Unique identifier for this upload.   Once an object is created with an uploadId,\nuploads of the same object with different uploadIds will be rejected.  Callers\nshould pass a randomly-generated slugid here.",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Upload ID",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "name",
            "projectId",
            "uploadId",
            "credentials",
            "expires"
          ],
          "title": "Object Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to redirect to a URL for a given\nartifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Redirect Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response for an artifact with `storageType` `link`.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `link`\n",
              "enum": [
                "link"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Link Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to reply `424` (Failed Dependency)\nwith `reason` and `message` to any `GET` request for this artifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Error Artifact Response",
          "type": "object"
        }
      ],
      "title": "Post Artifact Response"
    },
    "filename": "schemas/queue/v1/post-artifact-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Request a authorization to put and artifact or posting of a URL as an artifact. Note that the `storageType` property is referenced in the response as well.",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Request for a signed PUT URL that will allow you to upload an artifact\nto an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, when uploading artifact to the signed\n`PUT` URL returned from this request this must given with the\n `ContentType` header. Please, provide correct mime-type,\n this make tooling a lot easier, specifically,\n always using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted. Note, that\nthese will be collected over time, and artifacts may remain\navailable after expiration. S3 based artifacts are identified in\nazure table storage and explicitly deleted on S3 after expiration.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request to create an artifact via the object service.\n",
          "properties": {
            "contentType": {
              "description": "Artifact content type.  This is advisory in nature and can be used,\nfor example, to select appropriate icons to display artifact links.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'object'`\n",
              "enum": [
                "object"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType"
          ],
          "title": "Object Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to redirect fetches for this artifact to a URL.  An\nexisting artifact can be replaced with a RedirectArtifact as long as the\ntask is still executing.  When a RedirectArtifact is fetched, the URL is\nreturned verbatim as a Location header in a 303 (See Other) response.\nClients will not apply any form of authentication to that URL.\n",
          "properties": {
            "contentType": {
              "description": "Expected content-type of the artifact.  This is informational only:\nit is suitable for use to choose an icon for the artifact, for example.\nThe accurate content-type of the artifact can only be determined by\ndownloading it.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the queue should no longer redirect to this URL.\nNote, that the queue will and cannot delete the resource your URL\nreferences, you are responsible for doing that yourself.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            },
            "url": {
              "description": "URL to which the queue should redirect using a `303` (See other)\nredirect.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "url",
            "contentType"
          ],
          "title": "Redirect Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to link this artifact to the named artifact on the same\ntask.  When a client fetches this artifact, the request will be treated as\nif the client fetched the linked artifact (including corresponding scope\nvalidation).  Note that the target artifact need not exist when this artifact\nis created.  It is allowed to create link cycles, but they will result in a\n400 response when fetched.\n",
          "properties": {
            "artifact": {
              "description": "Name of the artifact to which to link.\n",
              "type": "string"
            },
            "contentType": {
              "description": "Expected content-type of the artifact.  This is informational only:\nit is suitable for use to choose an icon for the artifact, for example.\nThe accurate content-type of the artifact can only be determined by\ndownloading it.  If this value is not provided, it will default to\n`application/binary`.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the queue should no longer maintain this link.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `link`\n",
              "enum": [
                "link"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "artifact"
          ],
          "title": "Link Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to reply `424` (Failed Dependency) with `reason` and\n`message` to any `GET` request for this artifact. This is mainly useful\nas a way for a task to declare that it failed to provide an artifact it\nwanted to upload.\n",
          "properties": {
            "expires": {
              "description": "Date-time after which the queue should stop replying with the error\nand forget about the artifact.\n",
              "format": "date-time",
              "type": "string"
            },
            "message": {
              "description": "Human readable explanation of why the artifact is missing\n",
              "maxLength": 4096,
              "type": "string"
            },
            "reason": {
              "description": "Reason why the artifact doesn't exist.\n",
              "enum": [
                "file-missing-on-worker",
                "invalid-resource-on-worker",
                "too-large-file-on-worker"
              ],
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "reason",
            "message"
          ],
          "title": "Error Artifact Request",
          "type": "object"
        }
      ],
      "title": "Post Artifact Request"
    },
    "filename": "schemas/queue/v1/post-artifact-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/poll-task-urls-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to request for poll task urls.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the signed URLs provided in this response\nexpires and not longer works for authentication.\n",
          "format": "date-time",
          "title": "Signed URL Expiration",
          "type": "string"
        },
        "queues": {
          "description": "List of signed URLs for queues to poll tasks from, they must be called\nin the order they are given. As the first entry in this array **may**\nhave higher priority.\n",
          "items": {
            "additionalProperties": false,
            "description": "Object holding two signed URLs for an azure queue, one for fetching\nmessages, and another for deleting messages. Remember to `claimTask`\nbefore deleting the message, and delete message even if the `claimTask`\noperation fails with a 400 status code. Don't delete it on other status\ncodes!\n",
            "properties": {
              "signedDeleteUrl": {
                "description": "Signed URL to delete messages that have been received using the\n`signedPollUrl`. You **must** do this to avoid receiving the same\nmessage again.\nTo use this URL you must substitute `{{messageId}}` and\n`{{popReceipt}}` with `MessageId` and `PopReceipt` from the XML\nresponse the `signedPollUrl` gave you. It is important that you\n`encodeURIComponent` both `MessageId` and `PopReceipt` prior to\nsubstitution, otherwise you will experience intermittent failures!\nNote this URL only works with `DELETE` request.\n",
                "pattern": "^https://",
                "title": "Signed Delete Message URL",
                "type": "string"
              },
              "signedPollUrl": {
                "description": "Signed URL to get message from the Azure Queue Storage queue,\nthat holds messages for the given `provisionerId` and `workerType`.\nNote that this URL returns XML, see documentation for the Azure\nQueue Storage\n[REST API](http://msdn.microsoft.com/en-us/library/azure/dd179474.aspx)\nfor details.\nWhen you have a message you can use `claimTask` to claim the task.\nYou will need to parse the XML response and base64 decode and\nJSON parse the `MessageText`.\nAfter you have called `claimTask` you **must** us the\n`signedDeleteUrl` to delete the message.\n**Remark**, you are allowed to append `&numofmessages=N`,\nwhere N < 32, to the URLs if you wish to obtain more than one\nmessage at the time.\n",
                "format": "uri",
                "title": "Signed Get Message URL",
                "type": "string"
              }
            },
            "required": [
              "signedPollUrl",
              "signedDeleteUrl"
            ],
            "title": "Signed URLs for a queue",
            "type": "object"
          },
          "title": "Queues To Poll From",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "queues",
        "expires"
      ],
      "title": "Poll Task Urls Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/poll-task-urls-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/pending-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for the number of pending tasks for a given\n`provisionerId` and `workerType`.\n",
      "properties": {
        "pendingTasks": {
          "description": "An approximate number of pending tasks for the given `provisionerId` and\n`workerType`. This is based on Azure Queue Storage metadata API, thus,\nnumber of reported here may be higher than actual number of pending tasks.\nBut there cannot be more pending tasks reported here. Ie. this is an\n**upper-bound** on the number of pending tasks.\n",
          "minimum": 0,
          "title": "Number of Pending Tasks",
          "type": "integer"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "taskQueueId",
        "pendingTasks"
      ],
      "title": "Count Pending Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/pending-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/object-credentials.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Temporary credentials for access to the object service.\n\nThese credentials are used both to download artifacts from the object service\n(`getArtifactContent`) and to upload artifacts (`createArtifact`).\n",
      "properties": {
        "accessToken": {
          "description": "The `accessToken` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        },
        "certificate": {
          "description": "The `certificate` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        },
        "clientId": {
          "description": "The `clientId` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "certificate"
      ],
      "title": "Object service Credentials",
      "type": "object"
    },
    "filename": "schemas/queue/v1/object-credentials.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workertypes-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkerTypes` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the provisioner.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerTypes": {
          "description": "List of worker-types in this provisioner.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description of the worker-type.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Worker-type Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the worker-type was last seen active\n",
                "format": "date-time",
                "title": "Worker-type Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "$ref": "task.json#/properties/provisionerId"
              },
              "stability": {
                "description": "This is the stability of the worker-type. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              },
              "taskQueueId": {
                "$ref": "task.json#/properties/taskQueueId"
              },
              "workerType": {
                "$ref": "task.json#/properties/workerType"
              }
            },
            "required": [
              "workerType",
              "provisionerId",
              "taskQueueId",
              "stability",
              "description",
              "expires",
              "lastDateActive"
            ],
            "title": "Worker Type",
            "type": "object"
          },
          "title": "WorkerTypes from the Provisioner",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerTypes"
      ],
      "title": "List Worker-Types Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workertypes-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workers-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkers` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-type.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of workers in this worker-type.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "firstClaim": {
                "description": "Date of the first time this worker claimed a task.\n",
                "format": "date-time",
                "title": "First task claimed",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date of the last time this worker was seen active. Updated each time a worker calls\n`queue.claimWork`, `queue.reclaimTask`, and `queue.declareWorker` for this task queue.\n`lastDateActive` is updated every half hour but may be off by up-to half an hour.\nNonetheless, `lastDateActive` is a good indicator of when the worker was last seen active.\nThis defaults to null in the database, and is set to the current time when the worker\nis first seen.\n",
                "format": "date-time",
                "title": "Worker Last Date Active",
                "type": "string"
              },
              "latestTask": {
                "$ref": "task-run.json#",
                "description": "The most recent claimed task\n",
                "title": "Most Recent Task"
              },
              "quarantineUntil": {
                "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
                "format": "date-time",
                "title": "Worker Quarantine",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for the worker group containing this worker.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for this worker (unique within this worker group).\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "workerGroup",
              "workerId",
              "firstClaim"
            ],
            "title": "Worker",
            "type": "object"
          },
          "title": "Workers from a WorkerType",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "List Workers Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workers-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-taskqueues-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listTaskQueues` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of task-queues.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listTaskQueues` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskQueues": {
          "description": "List of all task-queues.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description of the task queue.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the task queue will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Task queue Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the task queue was last seen active\n",
                "format": "date-time",
                "title": "Task queue Last Date Active",
                "type": "string"
              },
              "stability": {
                "description": "This is the stability of the task queue. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              },
              "taskQueueId": {
                "$ref": "task.json#/properties/taskQueueId"
              }
            },
            "required": [
              "taskQueueId",
              "stability",
              "description",
              "expires",
              "lastDateActive"
            ],
            "title": "Task Queue",
            "type": "object"
          },
          "title": "taskQueues",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskQueues"
      ],
      "title": "List Task-Queues Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-taskqueues-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-task-group-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listTaskGroup` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tasks in the task-group.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listTaskGroup` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks in this task-group.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks from the Task-Group",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskGroupId",
        "tasks"
      ],
      "title": "List Task-Group Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-task-group-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-provisioners-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "provisioners": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "actions": {
                "$ref": "actions.json#"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the provisioner created will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Provisioner Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the provisioner was last seen active\n",
                "format": "date-time",
                "title": "Provisioner Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "$ref": "task.json#/properties/provisionerId"
              },
              "stability": {
                "description": "This is the stability of the provisioner. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              }
            },
            "required": [
              "provisionerId",
              "description",
              "stability",
              "expires",
              "lastDateActive",
              "actions"
            ],
            "title": "Provisioner Information",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "provisioners"
      ],
      "title": "List Provisioners Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-provisioners-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-dependent-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listDependentTasks` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of dependent tasks.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listDependentTasks` with\n`continuationToken` until you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskId": {
          "description": "Identifier for the task whose dependents are being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks that have `taskId` in the `task.dependencies` property.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks that depend on `taskId`",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskId",
        "tasks"
      ],
      "title": "List Dependent Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-dependent-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-artifacts-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of artifacts for a given `taskId` and `runId`.\n",
      "properties": {
        "artifacts": {
          "description": "List of artifacts for given `taskId` and `runId`.\n",
          "items": {
            "$ref": "./artifact-response.json#"
          },
          "title": "Artifact List",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of artifacts.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "artifacts"
      ],
      "title": "List Artifacts Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-artifacts-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/get-artifact-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to the `getArtifact` method.  This method returns a simple URL from\nwhich the artifact data can be read.  Not that this response is provided as\nthe body of an HTTP 303 response, so clients which automatically follow\nredirects may not see this content.\n",
      "properties": {
        "storageType": {
          "description": "Artifact storage type.  Note that this is also available in the\n`x-taskcluster-artifact-storage-type` header.\n",
          "type": "string"
        },
        "url": {
          "description": "URL from which to download the artifact\n",
          "format": "uri",
          "type": "string"
        }
      },
      "required": [
        "storageType",
        "url"
      ],
      "title": "Get Artifact Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/get-artifact-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/finish-artifact-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request body for `finishArtifact`\n",
      "properties": {
        "uploadId": {
          "description": "The uploadId from `createArtifact`.  Supplying this value provides an\nadditional check, beyond scopes, that the caller was the entity that\nuploaded the data.  This must be specified for `storageType: object`.",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Upload ID",
          "type": "string"
        }
      },
      "required": [
        "uploadId"
      ],
      "title": "Finish Artifact Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/finish-artifact-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/create-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, by which this task must be complete. `pending` and\n`running` runs are resolved as **exception** if not resolved by other means\nbefore the deadline. After the deadline, a task is immutable. Note,\ndeadline cannot be more than 5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "$ref": "task.json#/properties/dependencies",
          "default": [
          ]
        },
        "expires": {
          "$ref": "task.json#/properties/expires"
        },
        "extra": {
          "$ref": "task.json#/properties/extra",
          "default": {
          }
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "$ref": "task.json#/properties/payload",
          "default": [
          ]
        },
        "priority": {
          "$ref": "task.json#/properties/priority",
          "default": "lowest"
        },
        "projectId": {
          "$ref": "task.json#/properties/projectId",
          "default": "none"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "requires": {
          "$ref": "task.json#/properties/requires",
          "default": "all-completed"
        },
        "retries": {
          "$ref": "task.json#/properties/retries",
          "default": 5
        },
        "routes": {
          "$ref": "task.json#/properties/routes",
          "default": [
          ]
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "scopes": {
          "$ref": "task.json#/properties/scopes",
          "default": [
          ]
        },
        "tags": {
          "$ref": "task.json#/properties/tags",
          "default": {
          }
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "taskQueueId": {
          "$ref": "task.json#/properties/taskQueueId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "created",
        "deadline",
        "payload",
        "metadata"
      ],
      "title": "Task Definition Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/create-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to an attempt to claim tasks for a worker to process.\n",
      "properties": {
        "tasks": {
          "description": "List of task claims, may be empty if no tasks was claimed, in which case\nthe worker should sleep a tiny bit before polling again.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "credentials": {
                "$ref": "task-credentials.json#"
              },
              "runId": {
                "description": "`run-id` assigned to this run of the task\n",
                "maximum": 1000,
                "minimum": 0,
                "type": "integer"
              },
              "status": {
                "$ref": "task-status.json#"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\nThis will be some time in the future, with that time controlled\nby the `queue.task_claim_timeout` configuration.\n",
                "format": "date-time",
                "type": "string"
              },
              "task": {
                "$ref": "task.json#"
              },
              "workerGroup": {
                "description": "Identifier for the worker-group within which this run started.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for the worker executing this run.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "status",
              "runId",
              "workerGroup",
              "workerId",
              "takenUntil",
              "task",
              "credentials"
            ],
            "title": "Task Claim",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "Claim Work Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim a task for a worker to process.\n",
      "properties": {
        "tasks": {
          "default": 1,
          "description": "Number of tasks to attempt to claim.\n",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId",
        "tasks"
      ],
      "title": "Claim Work Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/artifact-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Information about an artifact\n",
      "properties": {
        "contentType": {
          "description": "Expected content-type of the artifact.  This is informational only:\nit is suitable for use to choose an icon for the artifact, for example.\nThe accurate content-type of the artifact can only be determined by\ndownloading it.\n",
          "maxLength": 255,
          "title": "Content-Type",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Artifact Expiration",
          "type": "string"
        },
        "name": {
          "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact.\n",
          "maxLength": 1024,
          "title": "Artifact Name",
          "type": "string"
        },
        "storageType": {
          "description": "This is the `storageType` for the request that was used to create\nthe artifact.\n",
          "enum": [
            "s3",
            "object",
            "reference",
            "link",
            "error"
          ],
          "title": "Artifact Storage-Type",
          "type": "string"
        }
      },
      "required": [
        "storageType",
        "name",
        "expires",
        "contentType"
      ],
      "title": "Artifact",
      "type": "object"
    },
    "filename": "schemas/queue/v1/artifact-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/artifact-created-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting a new artifact has been created for a given task.\n",
      "properties": {
        "artifact": {
          "additionalProperties": false,
          "description": "Information about the artifact that was created\n",
          "properties": {
            "contentType": {
              "description": "Expected content-type of the artifact.  This is informational only:\nit is suitable for use to choose an icon for the artifact, for example.\nThe accurate content-type of the artifact can only be determined by\ndownloading it.\n",
              "maxLength": 255,
              "title": "Content-Type",
              "type": "string"
            },
            "expires": {
              "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
              "format": "date-time",
              "title": "Artifact Expiration",
              "type": "string"
            },
            "name": {
              "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact. But keep in mind that just because an\nartifact is created doesn't mean that it's immediately available.\n",
              "maxLength": 1024,
              "title": "Artifact Name",
              "type": "string"
            },
            "storageType": {
              "description": "This is the `storageType` for the request that was used to create the\nartifact.  Note that artifacts with the `s3` storage type do not produce\nthis message.\n",
              "enum": [
                "reference",
                "link",
                "error",
                "object"
              ],
              "title": "Artifact Storage-Type",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "name",
            "expires",
            "contentType"
          ],
          "title": "Artifact",
          "type": "object"
        },
        "runId": {
          "description": "Id of the run on which artifact was created.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the run with the created\nartifacted is running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker within which the run with the created artifact\nis running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "artifact"
      ],
      "title": "Artifact Created Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/artifact-created-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/artifact-content-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response to the `artifact` and `latestArtifact` methods.  It is one of the\nfollowing types, as identified by the `storageType` property.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "storageType": {
              "const": "s3"
            },
            "url": {
              "description": "URL from which to download the artifact.  This may be a URL for a bucket or\na CDN, and may or may not be signed, depending on server configuration.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "url"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "An object name, and credentials to use to access that object on the object service.\nThe credentials expire one hour after this call; this should allow ample time for\nretries, slow downloads, and clock skew.\n",
          "properties": {
            "credentials": {
              "$ref": "object-credentials.json#"
            },
            "name": {
              "description": "Name of the object on the object service.\n",
              "pattern": "^[\\x20-\\x7e]+$",
              "type": "string"
            },
            "storageType": {
              "const": "object"
            }
          },
          "required": [
            "storageType",
            "name",
            "credentials"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "storageType": {
              "const": "reference"
            },
            "url": {
              "description": "Referenced URL",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "url"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "description": "Error message",
              "type": "string"
            },
            "reason": {
              "description": "Error reason",
              "type": "string"
            },
            "storageType": {
              "const": "error"
            }
          },
          "required": [
            "storageType",
            "reason",
            "message"
          ],
          "type": "object"
        }
      ],
      "title": "Get Artifact Content Response"
    },
    "filename": "schemas/queue/v1/artifact-content-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/actions.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "See taskcluster [actions](/docs/reference/platform/taskcluster-queue/docs/actions) documentation.\n",
      "items": {
        "additionalProperties": false,
        "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
        "properties": {
          "context": {
            "description": "Actions have a \"context\" that is one of provisioner, worker-type, or worker, indicating\nwhich it applies to. `context` is used by the front-end to know where to display the action.\n\n| `context`   | Page displayed        |\n|-------------|-----------------------|\n| provisioner | Provisioner Explorer  |\n| worker-type | Workers Explorer      |\n| worker      | Worker Explorer       |\n",
            "enum": [
              "provisioner",
              "worker-type",
              "worker"
            ],
            "title": "Context",
            "type": "string"
          },
          "description": {
            "description": "Description of the provisioner.\n",
            "title": "Description",
            "type": "string"
          },
          "method": {
            "description": "Method to indicate the desired action to be performed for a given resource.\n",
            "enum": [
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "title": "Method",
            "type": "string"
          },
          "name": {
            "description": "Short names for things like logging/error messages.\n",
            "title": "Name",
            "type": "string"
          },
          "title": {
            "description": "Appropriate title for any sort of Modal prompt.\n",
            "title": "Title"
          },
          "url": {
            "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
            "title": "URL",
            "type": "string"
          }
        },
        "required": [
          "name",
          "title",
          "context",
          "url",
          "method",
          "description"
        ],
        "title": "Action",
        "type": "object"
      },
      "title": "Actions",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/queue/v1/actions.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-requests.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A list of Purge Cache requests that the Purge Cache service has previously received.\n",
      "items": {
        "additionalProperties": false,
        "description": "An entry in a list of Purge Cache Requests that the Purge Cache service has previously received.\n",
        "properties": {
          "before": {
            "description": "All caches that match this provisionerId, workerType, and cacheName must be destroyed if they were created _before_ this time.\n",
            "format": "date-time",
            "type": "string"
          },
          "cacheName": {
            "description": "Name of cache to purge.",
            "type": "string"
          },
          "provisionerId": {
            "description": "ProvisionerId associated with the workerType.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          },
          "workerType": {
            "description": "Workertype cache exists on.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          }
        },
        "required": [
          "provisionerId",
          "workerType",
          "cacheName",
          "before"
        ],
        "title": "Purge Cache Requests Entry",
        "type": "object"
      },
      "title": "Purge Cache Requests",
      "type": "array",
      "uniqueItems": false
    },
    "filename": "schemas/purge-cache/v1/purge-cache-requests.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request that a message be published to purge a specific cache.\n",
      "properties": {
        "cacheName": {
          "description": "Name of cache to purge. Notice that if a `workerType` have multiple kinds\nof caches (with independent names), it should purge all caches identified\nby `cacheName` regardless of cache type.\n",
          "type": "string"
        }
      },
      "required": [
        "cacheName"
      ],
      "title": "Purge Cache Request",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests.\n",
      "properties": {
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open Purge Request List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/all-purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests. Should not be used by workers.\n",
      "properties": {
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        },
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open All Purge Requests List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/all-purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/upload-method-put-url.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "request": {
          "additionalProperties": false,
          "description": "Request a URL to which a PUT request can be made.",
          "properties": {
            "contentLength": {
              "description": "Length, in bytes, of the uploaded data.",
              "type": "integer"
            },
            "contentType": {
              "description": "Content-type of the data to be uploaded.",
              "type": "string"
            }
          },
          "required": [
            "contentType",
            "contentLength"
          ],
          "title": "`putUrl` upload request",
          "type": "object"
        },
        "response": {
          "additionalProperties": false,
          "description": "Response containing a URL to which to PUT the data.",
          "properties": {
            "expires": {
              "description": "Expiration time for the URL.  After this time, the client must\ncall `createUpload` again to get a fresh URL.",
              "format": "date-time",
              "type": "string"
            },
            "headers": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "Headers which must be included with the PUT request.  In many\ncases, these are included in a signature embedded in the URL,\nand must be provided verbatim.\n\nThe `Content-Length` header may be included here.  Many HTTP client\nlibraries will also set this directly when the length is known.  In\nthis case, the values should be identical, and the header should only\nbe specified once.",
              "type": "object"
            },
            "url": {
              "description": "URL to which a PUT request should be made.",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "url",
            "expires",
            "headers"
          ],
          "title": "`putUrl` upload response",
          "type": "object"
        }
      },
      "title": "putUrl upload method"
    },
    "filename": "schemas/object/v1/upload-method-put-url.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/upload-method-data-inline.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "request": {
          "additionalProperties": false,
          "description": "Upload data included directly in the request.  The data has a fixed maximum length, so this should\nbe used only for value that are known to be of constant, fairly small size to avoid surprises as\nthe payload grows. In general, this is useful for testing and for metadata objects such as\nseparate cryptographic signatures.\n",
          "properties": {
            "contentType": {
              "description": "Content-type to be returned when downloading this data",
              "type": "string"
            },
            "objectData": {
              "description": "Base64-encoded byte data, with decoded size at most 8k.",
              "maxLength": 10926,
              "type": "string"
            }
          },
          "required": [
            "contentType",
            "objectData"
          ],
          "title": "`dataInline` upload request",
          "type": "object"
        },
        "response": {
          "const": true,
          "description": "Indication that the data has been uploaded.",
          "title": "`dataInline` upload response",
          "type": "boolean"
        }
      },
      "title": "dataInline upload method"
    },
    "filename": "schemas/object/v1/upload-method-data-inline.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/hashes.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "download": {
          "additionalProperties": true,
          "description": "Hashes of the content of this object.  The caller should verify all\nhashes present for recognized algorithms, and verify that at least one\nnon-deprecated hash is present.\n",
          "properties": {
            "sha256": {
              "$ref": "#/definitions/upload/properties/sha256"
            },
            "sha512": {
              "$ref": "#/definitions/upload/properties/sha512"
            }
          },
          "required": [
          ],
          "title": "Object Content Hashes For Download",
          "type": "object"
        },
        "upload": {
          "additionalProperties": true,
          "description": "Hashes of the content of this object.  These values will be verified by\nwell-behaved downloaders.  The format is `{alogrithm: value}`.\n\nMultiple calls to `createUpload` or `finishUpload` for the same object\ncan specify additional hashes, but existing hashes cannot be changed;\nthis allows \"amending\" an upload with hashes after the data has been\ntransferred, for example.\n\nAt least one non-deprecated algorithm must be included, preferably the\nmost advanced (SHA512).  Deprecated algorithms may also be included.\n",
          "properties": {
            "sha256": {
              "pattern": "^[a-z0-9]{64}$",
              "title": "SHA256 hash",
              "type": "string"
            },
            "sha512": {
              "pattern": "^[a-z0-9]{128}$",
              "title": "SHA512 hash",
              "type": "string"
            }
          },
          "required": [
          ],
          "title": "Object Content Hashes",
          "type": "object"
        }
      },
      "title": "Hash Methods"
    },
    "filename": "schemas/object/v1/hashes.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/get-object-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Metadata about an object.\n",
      "properties": {
        "expires": {
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "hashes": {
          "$ref": "hashes.json#/definitions/download"
        },
        "projectId": {
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        }
      },
      "required": [
        "projectId",
        "expires",
        "hashes"
      ],
      "title": "Object Metadata",
      "type": "object"
    },
    "filename": "schemas/object/v1/get-object-response.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/finish-upload-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "hashes": {
          "$ref": "hashes.json#/definitions/upload"
        },
        "projectId": {
          "description": "Project identifier.\n",
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        },
        "uploadId": {
          "description": "Unique identifier for this upload.",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Upload ID",
          "type": "string"
        }
      },
      "required": [
        "uploadId",
        "projectId"
      ],
      "title": "Finish Upload Request",
      "type": "object"
    },
    "filename": "schemas/object/v1/finish-upload-request.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/download-object-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "See [Download Methods](https://docs.taskcluster.net/docs/docs/reference/platform/object/download-methods) for details.\n",
      "oneOf": [
        {
          "$ref": "download-method-simple.json#/definitions/response"
        },
        {
          "$ref": "download-method-geturl.json#/definitions/response"
        }
      ],
      "title": "Download Object Response"
    },
    "filename": "schemas/object/v1/download-object-response.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/download-object-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "See [Download Methods](https://docs.taskcluster.net/docs/docs/reference/platform/object/download-methods) for details.\n",
      "properties": {
        "acceptDownloadMethods": {
          "additionalProperties": false,
          "description": "Download methods that the caller can suport, together with parameters for each method.\nThe server will choose one method and make the corresponding response.",
          "properties": {
            "getUrl": {
              "$ref": "download-method-geturl.json#/definitions/request"
            },
            "simple": {
              "$ref": "download-method-simple.json#/definitions/request"
            }
          },
          "required": [
          ],
          "title": "Supported download methods",
          "type": "object"
        }
      },
      "required": [
        "acceptDownloadMethods"
      ],
      "title": "Download Object Request",
      "type": "object"
    },
    "filename": "schemas/object/v1/download-object-request.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/download-method-simple.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "request": {
          "const": true,
          "type": "boolean"
        },
        "response": {
          "additionalProperties": false,
          "description": "A simple download returns a URL to which the caller should make a GET request.\nSee [Simple Downloads](https://docs.taskcluster.net/docs/docs/reference/platform/object/simple-downloads) for details.",
          "properties": {
            "method": {
              "const": "simple",
              "type": "string"
            },
            "url": {
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "method",
            "url"
          ],
          "title": "simple Download Response",
          "type": "object"
        }
      },
      "title": "simple Download Method"
    },
    "filename": "schemas/object/v1/download-method-simple.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/download-method-geturl.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "request": {
          "const": true,
          "type": "boolean"
        },
        "response": {
          "additionalProperties": false,
          "description": "This download method returns a URL from which the data may be fetched with an HTTP GET request.\n\nThe client should begin a GET request as soon as possible after receiving the reponse.\nThe server will respond with a 200 OK containing the data, or with a 4xx or 5xx error response.\nIt will _not_ redirect to another URL (3xx), and the client should not follow any such redirects.\n\nThe client can use standard Range requests to download portions of the object or to resume an interrupted download.\nPer the HTTP standard, servers may return more data than requested by the Range header.\n\nIf retrying a failed or interrupted download, and the `expires` field is in the past, the client should call `startDownload` again to get an updated `url`.\nThe client can assume that the object data and `hashes` will be the same for all calls to `startDownload`.\n\nThe client can use standard Accept-Encoding headers to indicate the encodings it can accept.\nHowever, in a deviation from standard HTTP, the client _must_ accept at least `identity` and `gzip` encodings.\nIf the HTTP response has a `Content-Encoding` header, the client should decode the body before verifying its hashes and returning it to the application.\n\nThe client _must_ verify that the resulting data matches the supplied hashes.\nThe object service does not, itself, validate object data and relies on clients to do so.",
          "properties": {
            "expires": {
              "description": "The time after which `url` is no longer valid.\nIf the client wishes to begin an HTTP GET request after this time, it should first call `startDownload` again to get a fresh URL.\n",
              "format": "date-time",
              "title": "Expiration",
              "type": "string"
            },
            "hashes": {
              "$ref": "hashes.json#/definitions/download"
            },
            "method": {
              "const": "getUrl",
              "type": "string"
            },
            "url": {
              "description": "The URL to which the client should make a GET request.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "method",
            "url",
            "expires",
            "hashes"
          ],
          "title": "getUrl Download Response",
          "type": "object"
        }
      },
      "title": "getUrl Download Method"
    },
    "filename": "schemas/object/v1/download-method-geturl.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/create-upload-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A response from the `createUpload` method, either agreeing to an upload method or\nrejecting the proposal.\n",
      "properties": {
        "expires": {
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "projectId": {
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        },
        "uploadId": {
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Upload ID",
          "type": "string"
        },
        "uploadMethod": {
          "additionalProperties": false,
          "description": "The selected upload method, from those contained in the request.  At most one\nproperty will be set, indicating the selected method.  If no properties are set,\nthen none of the proposed methods were selected.\n",
          "maxProperties": 1,
          "minProperties": 0,
          "properties": {
            "dataInline": {
              "$ref": "upload-method-data-inline.json#/definitions/response"
            },
            "putUrl": {
              "$ref": "upload-method-put-url.json#/definitions/response"
            }
          },
          "required": [
          ],
          "title": "Selected Upload Method (or none)",
          "type": "object"
        }
      },
      "required": [
        "projectId",
        "uploadId",
        "expires",
        "uploadMethod"
      ],
      "title": "Create Upload Response",
      "type": "object"
    },
    "filename": "schemas/object/v1/create-upload-response.json"
  },
  {
    "content": {
      "$id": "/schemas/object/v1/create-upload-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A request to begin an upload, containing proposed upload methods to which the\nserver may agree to or reject.\n",
      "properties": {
        "expires": {
          "description": "Date at which this entry expires from the object table.  The expiration cannot\nbe changed in subsequent calls to the same method.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "hashes": {
          "$ref": "hashes.json#/definitions/upload"
        },
        "projectId": {
          "description": "Project identifier.\n",
          "maxLength": 500,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9._/-]*)$",
          "title": "Project Identifier",
          "type": "string"
        },
        "proposedUploadMethods": {
          "additionalProperties": false,
          "description": "Upload methods, with details, that the caller is prepared to execute.  If\nthis object is empty, then the server will reject the request but still\ncreate the upload with the given `uploadId`, `projectId`, and `expires`,\nso any subsequent calls must share those values.  The server may choose\nany of the proposed methods at its discretion.\n",
          "properties": {
            "dataInline": {
              "$ref": "upload-method-data-inline.json#/definitions/request"
            },
            "putUrl": {
              "$ref": "upload-method-put-url.json#/definitions/request"
            }
          },
          "required": [
          ],
          "title": "Proposed Upload Methods",
          "type": "object"
        },
        "uploadId": {
          "description": "Unique identifier for this upload.   Once an object is created with an uploadId,\nuploads of the same object with different uploadIds will be rejected.  Callers\nshould pass a randomly-generated slugid here.",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Upload ID",
          "type": "string"
        }
      },
      "required": [
        "projectId",
        "uploadId",
        "expires",
        "proposedUploadMethods"
      ],
      "title": "Create Upload Request",
      "type": "object"
    },
    "filename": "schemas/object/v1/create-upload-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/slack-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to send a message to a Slack channel. The most interesting field in\nthis request is the `blocks` field which allows you to specify advanced\ndisplay layout for messages. This is best understood via the Slack API\ndocumentation.\n",
      "properties": {
        "attachments": {
          "description": "An array of Slack attachments. See https://api.slack.com/messaging/composing/layouts#attachments.\n",
          "type": "array"
        },
        "blocks": {
          "description": "An array of Slack layout blocks. See https://api.slack.com/reference/block-kit/blocks.\n",
          "type": "array"
        },
        "channelId": {
          "description": "The unique Slack channel ID, such as `C123456GZ`.\nIn the app, this is the last section of the 'copy link' URL for a channel.\n",
          "type": "string"
        },
        "text": {
          "description": "The main message text. If no blocks are included, this is used as the\nmessage text, otherwise this is used as alternative text and the blocks\nare used.\n",
          "type": "string"
        }
      },
      "required": [
        "channelId",
        "text"
      ],
      "title": "Send Slack Message",
      "type": "object"
    },
    "filename": "schemas/notify/v1/slack-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/pulse-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to post a message on pulse.\n",
      "properties": {
        "message": {
          "description": "Pulse message to send as plain text.\n",
          "type": "object"
        },
        "routingKey": {
          "description": "Routing-key to use when posting the message.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "required": [
        "routingKey",
        "message"
      ],
      "title": "Post Pulse Message Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/pulse-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "This can be pretty much anything you want it to be.\n",
      "properties": {
        "message": {
          "description": "Arbitrary message.\n",
          "title": "Message",
          "type": "object"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "message"
      ],
      "title": "Notification Message",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-message.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Type of notification and its corresponding address.\n",
      "properties": {
        "notificationAddress": {
          "type": "string"
        },
        "notificationType": {
          "enum": [
            "email",
            "pulse",
            "matrix-room",
            "slack-channel"
          ],
          "type": "string"
        }
      },
      "required": [
        "notificationType",
        "notificationAddress"
      ],
      "title": "Notification Type And Address",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of notification addresses.\n",
      "properties": {
        "addresses": {
          "items": {
            "$ref": "notification-address.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "addresses"
      ],
      "title": "List of notification adresses",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address-list.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/matrix-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to send a Matrix notice. Many of these fields are better understood by\nchecking the matrix spec itself. The precise definitions of these fields is\nbeyond the scope of this document.\n",
      "properties": {
        "body": {
          "description": "Unformatted text that will be displayed in the room if you do not\nspecify `formattedBody` or if a user's client can not render the format.\n",
          "type": "string"
        },
        "format": {
          "description": "The format for `formattedBody`. For instance, `org.matrix.custom.html`",
          "type": "string"
        },
        "formattedBody": {
          "description": "Text that will be rendered by matrix clients that support the given\nformat in that format. For instance, `<h1>Header Text</h1>`.\n",
          "type": "string"
        },
        "msgtype": {
          "default": "m.notice",
          "description": "Which of the `m.room.message` msgtypes to use. At the moment only the\ntypes that take `body`/`format`/`formattedBody` are supported.\n",
          "enum": [
            "m.notice",
            "m.text",
            "m.emote"
          ],
          "type": "string"
        },
        "roomId": {
          "description": "The fully qualified room name, such as `!whDRjjSmICCgrhFHsQ:mozilla.org`\nIf you are using riot, you can find this under the advanced settings for a room.\n",
          "type": "string"
        }
      },
      "required": [
        "roomId",
        "body"
      ],
      "title": "Send Matrix Notice Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/matrix-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/email-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to send an email\n",
      "properties": {
        "address": {
          "description": "E-mail address to which the message should be sent\n",
          "format": "email",
          "type": "string"
        },
        "content": {
          "description": "Content of the e-mail as **markdown**, will be rendered to HTML before\nthe email is sent. Notice that markdown allows for a few HTML tags, but\nwon't allow inclusion of script tags and other unpleasantries.\n",
          "maxLength": 102400,
          "minLength": 1,
          "type": "string"
        },
        "link": {
          "additionalProperties": false,
          "description": "Optional link that can be added as a button to the email.\n",
          "properties": {
            "href": {
              "description": "Where the link should point to.\n",
              "format": "uri",
              "maxLength": 1024,
              "minLength": 1,
              "type": "string"
            },
            "text": {
              "description": "Text to display on link.\n",
              "maxLength": 40,
              "minLength": 1,
              "type": "string"
            }
          },
          "required": [
            "text",
            "href"
          ],
          "type": "object"
        },
        "replyTo": {
          "description": "Reply-to e-mail (this property is optional)\n",
          "format": "email",
          "type": "string"
        },
        "subject": {
          "description": "Subject line of the e-mail, this is plain-text\n",
          "maxLength": 255,
          "minLength": 1,
          "type": "string"
        },
        "template": {
          "default": "simple",
          "description": "E-mail html template used to format your content.\n",
          "enum": [
            "simple",
            "fullscreen"
          ],
          "type": "string"
        }
      },
      "required": [
        "address",
        "subject",
        "content"
      ],
      "title": "Send Email Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/email-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a task.\n",
            "properties": {
              "data": {
                "description": "Data that was reported with the task. This is an arbitrary JSON\nobject.\n",
                "title": "Task Specific Data",
                "type": "object"
              },
              "expires": {
                "description": "Date at which this entry expires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "namespace": {
                "description": "Index path of the task.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              },
              "rank": {
                "description": "If multiple tasks are indexed with the same `namespace` the task\nwith the highest `rank` will be stored and returned in later\nrequests. If two tasks has the same `rank` the latest task will be\nstored.\n",
                "title": "Rank",
                "type": "number"
              },
              "taskId": {
                "description": "Unique task identifier for the task currently indexed at `namespace`.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "taskId",
              "rank",
              "data",
              "expires"
            ],
            "title": "Task",
            "type": "object"
          },
          "title": "Tasks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "List Tasks Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "namespaces": {
          "description": "List of namespaces.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a namespace that contains indexed tasks.\n",
            "properties": {
              "expires": {
                "description": "Date at which this entry, and by implication all entries below it,\nexpires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "name": {
                "description": "Name of namespace within it's parent namespace.\n",
                "title": "Name",
                "type": "string"
              },
              "namespace": {
                "description": "Fully qualified name of the namespace, you can use this to list\nnamespaces or tasks under this namespace.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "name",
              "expires"
            ],
            "title": "Namespace",
            "type": "object"
          },
          "title": "Namespaces",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "namespaces"
      ],
      "title": "List Namespaces Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token previously returned in a response to this list\nrequest. This property is optional and should not be provided for first\nrequests.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "limit": {
          "default": 1000,
          "description": "Maximum number of results per page. If there are more results than this\na continuation token will be return.\n",
          "maximum": 1000,
          "minimum": 1,
          "title": "Result limit",
          "type": "integer"
        }
      },
      "required": [
      ],
      "title": "List Namespaces Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/insert-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of the index entry to insert.\n",
      "properties": {
        "data": {
          "description": "This is an arbitrary JSON object. Feel free to put whatever data you want\nhere, but do limit it, you'll get errors if you store more than 32KB.\nSo stay well, below that limit.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Insert Task Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/insert-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/indexed-task-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "data": {
          "description": "Data that was reported with the task. This is an arbitrary JSON object.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the indexed task, used to find the indexed task in the index.\n",
          "maxLength": 255,
          "title": "Namespace",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "namespace",
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Indexed Task Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/indexed-task-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Secret token for a trigger\n",
      "properties": {
        "token": {
          "title": "Token",
          "type": "string"
        }
      },
      "required": [
        "token"
      ],
      "title": "trigger token response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A request to trigger a hook.  The payload must be a JSON object, and is used as the context\nfor a JSON-e rendering of the hook's task template, as described in \"Firing Hooks\".\n",
      "title": "Trigger Hook Request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-hook.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "anyOf": [
        {
          "additionalProperties": false,
          "description": "Response identifying the created task",
          "properties": {
            "status": {
              "additionalProperties": false,
              "description": "Another copy of the taskId, at the location where it was published in\nTaskcluster versions before v42.  Prefer to use the top-level property,\nas `status.taskId` may be removed in future versions.\n",
              "properties": {
                "taskId": {
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                }
              },
              "required": [
              ],
              "type": "object"
            },
            "taskId": {
              "description": "TaskId of the task created by triggering the hook.\n",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Task Identifier",
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ],
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Empty response indicating no task was created",
          "properties": {
          },
          "required": [
          ],
          "type": "object"
        }
      ],
      "description": "Response to a `triggerHook` or `triggerHookWithToken` call.\n\nIn most cases, this gives a `taskId`, but in cases where the hook template\ndoes not generate a task, it is an empty object with no `taskId`.\n",
      "title": "Trigger Hook Response"
    },
    "filename": "schemas/hooks/v1/trigger-hook-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/schedule.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A list of cron-style definitions to represent a set of moments in (UTC) time.\nIf several patterns are specified, a given moment in time represented by\nmore than one pattern is considered only to be counted once, in other words\nit is allowed for the cron patterns to overlap; duplicates are redundant.\n",
      "items": {
        "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\n",
        "title": "Cron Pattern",
        "type": "string"
      },
      "title": "Schedule",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/schedule.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/pulse-hook-changed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "Message reporting that a hook has changed\n",
      "properties": {
        "hookGroupId": {
          "description": "`hookGroupId` of the hook that was changed\n",
          "type": "string"
        },
        "hookId": {
          "description": "`hookId` of the hook that was changed\n",
          "type": "string"
        }
      },
      "required": [
        "hookId",
        "hookGroupId"
      ],
      "title": "Hook Changed Message",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/pulse-hook-changed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-lastFires-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of lastFires\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "lastFires": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "error": {
                "description": "The error that occurred when firing the task. This is typically,\nbut not always, an API error message.\n",
                "type": "string"
              },
              "firedBy": {
                "enum": [
                  "schedule",
                  "triggerHook",
                  "triggerHookWithToken",
                  "pulseMessage"
                ],
                "type": "string"
              },
              "hookGroupId": {
                "maxLength": 1000,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "hookId": {
                "maxLength": 1000,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_/]*)$",
                "type": "string"
              },
              "result": {
                "description": "Information about success or failure of firing of the hook",
                "enum": [
                  "success",
                  "error"
                ],
                "type": "string"
              },
              "taskCreateTime": {
                "description": "Time when the task was created",
                "format": "date-time",
                "type": "string"
              },
              "taskId": {
                "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "hookGroupId",
              "hookId",
              "taskId",
              "firedBy",
              "taskCreateTime",
              "result",
              "error"
            ],
            "type": "object"
          },
          "title": "LastFires",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "lastFires"
      ],
      "title": "LastFires list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-lastFires-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hooks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of hooks\n",
      "properties": {
        "hooks": {
          "items": {
            "$ref": "hook-definition.json#"
          },
          "title": "Hooks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "hooks"
      ],
      "title": "Hook list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hooks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hook-groups-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of `hookGroupIds`.\n",
      "properties": {
        "groups": {
          "items": {
            "type": "string"
          },
          "title": "Groups",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "groups"
      ],
      "title": "Hook groups",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hook-groups-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A snapshot of the current status of a hook.\n",
      "properties": {
        "lastFire": {
          "description": "Information about the last time this hook fired.  This property is only present\nif the hook has fired at least once.\n",
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Information about a successful firing of the hook",
              "properties": {
                "result": {
                  "enum": [
                    "success"
                  ],
                  "type": "string"
                },
                "taskId": {
                  "description": "The task created",
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "taskId",
                "time"
              ],
              "title": "Successful Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about an unsuccessful firing of the hook",
              "properties": {
                "error": {
                  "description": "The error that occurred when firing the task.  This is typically,\nbut not always, an API error message.\n",
                  "type": "object"
                },
                "result": {
                  "enum": [
                    "error"
                  ],
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "error",
                "time"
              ],
              "title": "Failed Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about no firing of the hook (e.g., a new hook)",
              "properties": {
                "result": {
                  "enum": [
                    "no-fire"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "result"
              ],
              "title": "No Fire",
              "type": "object"
            }
          ]
        },
        "nextScheduledDate": {
          "description": "The next time this hook's task is scheduled to be created. This property\nis only present if there is a scheduled next time. Some hooks don't have\nany schedules.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "lastFire"
      ],
      "title": "Hook status response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-status.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "description": {
          "description": "Long-form of the hook's purpose and behavior",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "emailOnError": {
          "default": true,
          "description": "Whether to email the owner on an error creating the task.",
          "title": "Email on error",
          "type": "boolean"
        },
        "name": {
          "description": "Human readable name of the hook",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "Email of the person or group responsible for this hook.",
          "format": "email",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner"
      ],
      "title": "Hook Metadata",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-definition.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that will create tasks when defined events occur.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 1000,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 1000,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "$ref": "schedule.json#"
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://json-e.js.org/)\nas described in [firing hooks](/docs/reference/core/hooks/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "type": "object"
        }
      },
      "required": [
        "hookGroupId",
        "hookId",
        "metadata",
        "task",
        "schedule",
        "triggerSchema"
      ],
      "title": "Hook definition",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-definition.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/create-hook-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that can create tasks at defined times.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 1000,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 1000,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "default": [
          ],
          "description": "Definition of the times at which a hook will result in creation of a task.\nIf several patterns are specified, tasks will be created at any time\nspecified by one or more patterns.\n",
          "items": {
            "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\nNote that tasks may not be created at exactly the time specified.\n",
            "title": "Cron Pattern",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://json-e.js.org/)\nas described in [firing hooks](/docs/reference/core/hooks/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "default": {
            "additionalProperties": false,
            "type": "object"
          },
          "type": "object"
        }
      },
      "required": [
        "metadata",
        "task"
      ],
      "title": "Hook creation request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/create-hook-request.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/bindings.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "items": {
        "additionalProperties": false,
        "description": "Exchange and RoutingKeyPattern for each binding\n",
        "properties": {
          "exchange": {
            "minLength": 1,
            "type": "string"
          },
          "routingKeyPattern": {
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "exchange",
          "routingKeyPattern"
        ],
        "title": "Binding",
        "type": "object"
      },
      "title": "List of Bindings",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/bindings.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.v1.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v1, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "policy": {
          "additionalProperties": false,
          "properties": {
            "pullRequests": {
              "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
              "enum": [
                "public",
                "public_restricted",
                "collaborators"
              ],
              "type": "string"
            }
          },
          "required": [
            "pullRequests"
          ],
          "type": "object"
        },
        "reporting": {
          "description": "Policy for reporting status of PR or a commit. If absent, Github Statuses API is used",
          "enum": [
            "checks-v1"
          ],
          "type": "string"
        },
        "tasks": {
          "default": [
          ],
          "description": "Definitions of tasks that can be scheduled. Rendered with JSON-e\n",
          "oneOf": [
            {
              "description": "Each element of this should evaluate to a task definition via json-e",
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "type": "array",
              "uniqueItems": false
            },
            {
              "additionalProperties": true,
              "description": "This must evaluate to an array via json-e i.e. `$flatten`",
              "type": "object"
            }
          ],
          "title": "Task definition template\""
        },
        "version": {
          "description": "Version of the format of this file; must be 1",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.v1.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v0, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "allowPullRequests": {
          "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
          "enum": [
            "public",
            "collaborators"
          ],
          "type": "string"
        },
        "metadata": {
          "additionalProperties": false,
          "description": "Required task graph metadata",
          "properties": {
            "description": {
              "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
              "maxLength": 32768,
              "title": "Description",
              "type": "string"
            },
            "name": {
              "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
              "maxLength": 255,
              "title": "Name",
              "type": "string"
            },
            "owner": {
              "description": "E-mail of person who caused this task, e.g. the person who did\n`hg push`. The person we should contact to ask why this task is here.\n",
              "maxLength": 255,
              "title": "Owner",
              "type": "string"
            },
            "source": {
              "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
              "maxLength": 4096,
              "title": "Source",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description",
            "owner",
            "source"
          ],
          "type": "object"
        },
        "tasks": {
          "default": [
          ],
          "items": {
            "additionalProperties": true,
            "description": "Definition of a task that can be scheduled\n",
            "properties": {
              "created": {
                "default": "{{ $fromNow }}",
                "description": "Creation time of task",
                "title": "Created",
                "type": "string"
              },
              "deadline": {
                "default": "{{ '1 day' | $fromNow }}",
                "description": "Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline",
                "title": "Deadline",
                "type": "string"
              }
            },
            "required": [
            ],
            "title": "Task Definition",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "version": {
          "description": ".taskcluster.yml version",
          "enum": [
            0
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/task-group-creation-requested.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Indicates that this service has created a new task group in response to a GitHub event.\nThis message is for internal use only and should not be relied on for other purposes.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "taskGroupId": {
          "description": "The id of the taskGroup that had been created.",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "taskGroupId",
        "organization",
        "repository",
        "version"
      ],
      "title": "Task Group Defined - Create Status",
      "type": "object"
    },
    "filename": "schemas/github/v1/task-group-creation-requested.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/repository.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Any Taskcluster-specific Github repository information.\n",
      "properties": {
        "installed": {
          "description": "True if integration is installed, False otherwise.\n",
          "type": "boolean"
        }
      },
      "required": [
        "installed"
      ],
      "title": "Repository Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/repository.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-rerun-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub re-run task request has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "checkRunId": {
          "description": "Check run id",
          "type": "number"
        },
        "checkSuiteId": {
          "description": "Check suite id",
          "type": "number"
        },
        "details": {
          "description": "Metadata describing the push (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "checkRunId",
        "checkSuiteId",
        "tasks_for"
      ],
      "title": "GitHub Re-run Request Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-rerun-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-release-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub release has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the release (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Release Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-release-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-push-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub push has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the push (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Push Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-push-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-pull-request-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub pull request has occurred\n",
      "properties": {
        "action": {
          "description": "The GitHub `action` which triggered an event.\n",
          "type": "string"
        },
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the pull request (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "action",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Pull Request Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-pull-request-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Create a commit status on GitHub.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "context": {
          "description": "A string label to differentiate this status from the status of other systems.",
          "type": "string"
        },
        "description": {
          "description": "A short description of the status.",
          "type": "string"
        },
        "state": {
          "description": "The state of the status.",
          "enum": [
            "pending",
            "success",
            "error",
            "failure"
          ],
          "type": "string"
        },
        "target_url": {
          "description": "The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the 'source' of the Status.",
          "type": "string"
        }
      },
      "required": [
        "state"
      ],
      "title": "Create Status Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-status.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-comment.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Write a new comment on a GitHub Issue or Pull Request.\nFull specification on [GitHub docs](https://developer.github.com/v3/issues/comments/#create-a-comment)\n",
      "properties": {
        "body": {
          "description": "The contents of the comment.",
          "type": "string"
        }
      },
      "required": [
        "body"
      ],
      "title": "Create Comment Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-comment.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/build-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A paginated list of builds\n",
      "properties": {
        "builds": {
          "description": "A simple list of builds.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "created": {
                "description": "The initial creation time of the build. This is when it became pending.\n",
                "format": "date-time",
                "type": "string"
              },
              "eventId": {
                "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
                "oneOf": [
                  {
                    "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
                    "title": "Github GUID",
                    "type": "string"
                  },
                  {
                    "enum": [
                      "Unknown"
                    ],
                    "title": "Unknown Github GUID",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "eventType": {
                "description": "Type of Github event that triggered the build (i.e. push, pull_request.opened).",
                "type": "string"
              },
              "organization": {
                "description": "Github organization associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "repository": {
                "description": "Github repository associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "sha": {
                "description": "Github revision associated with the build.",
                "maxLength": 40,
                "minLength": 40,
                "type": "string"
              },
              "state": {
                "description": "Github status associated with the build.",
                "enum": [
                  "pending",
                  "success",
                  "error",
                  "failure"
                ],
                "type": "string"
              },
              "taskGroupId": {
                "description": "Taskcluster task-group associated with the build.",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "type": "string"
              },
              "updated": {
                "description": "The last updated of the build. If it is done, this is when it finished.\n",
                "format": "date-time",
                "type": "string"
              }
            },
            "required": [
              "organization",
              "repository",
              "sha",
              "state",
              "taskGroupId",
              "eventType",
              "eventId",
              "created",
              "updated"
            ],
            "title": "Build",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        }
      },
      "required": [
        "builds"
      ],
      "title": "Builds Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/build-list.json"
  },
  {
    "content": {
      "$id": "/schemas/generic-worker/simple_posix.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "content": {
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Requires scope `queue:get-artifact:<artifact-name>`.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "artifact": {
                  "maxLength": 1024,
                  "type": "string"
                },
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "taskId": {
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                }
              },
              "required": [
                "taskId",
                "artifact"
              ],
              "title": "Artifact Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "url": {
                  "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
                  "format": "uri",
                  "title": "URL",
                  "type": "string"
                }
              },
              "required": [
                "url"
              ],
              "title": "URL Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "raw": {
                  "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "title": "Raw",
                  "type": "string"
                }
              },
              "required": [
                "raw"
              ],
              "title": "Raw Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "base64": {
                  "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "pattern": "^[A-Za-z0-9/+]+[=]{0,2}$",
                  "title": "Base64",
                  "type": "string"
                }
              },
              "required": [
                "base64"
              ],
              "title": "Base64 Content",
              "type": "object"
            }
          ]
        },
        "fileMount": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Content of the file to be mounted.\n\nSince: generic-worker 5.4.0"
            },
            "file": {
              "description": "The filesystem location to mount the file.\n\nSince: generic-worker 5.4.0",
              "title": "File",
              "type": "string"
            }
          },
          "required": [
            "file",
            "content"
          ],
          "title": "File Mount",
          "type": "object"
        },
        "mount": {
          "oneOf": [
            {
              "$ref": "#/definitions/fileMount"
            },
            {
              "$ref": "#/definitions/writableDirectoryCache"
            },
            {
              "$ref": "#/definitions/readOnlyDirectory"
            }
          ],
          "title": "Mount"
        },
        "readOnlyDirectory": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Contents of read only directory.\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory",
              "type": "string"
            },
            "format": {
              "description": "Archive format of content for read only directory.\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "content",
            "format"
          ],
          "title": "Read Only Directory",
          "type": "object"
        },
        "writableDirectoryCache": {
          "additionalProperties": false,
          "dependencies": {
            "content": [
              "format"
            ],
            "format": [
              "content"
            ]
          },
          "properties": {
            "cacheName": {
              "description": "Implies a read/write cache directory volume. A unique name for the\ncache volume. Requires scope `generic-worker:cache:<cache-name>`.\nNote if this cache is loaded from an artifact, you will also require\nscope `queue:get-artifact:<artifact-name>` to use this cache.\n\nSince: generic-worker 5.4.0",
              "title": "Cache Name",
              "type": "string"
            },
            "content": {
              "$ref": "#/definitions/content",
              "description": "Optional content to be preloaded when initially creating the cache\n(if set, `format` must also be provided).\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory Volume",
              "type": "string"
            },
            "format": {
              "description": "Archive format of the preloaded content (if `content` provided).\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "cacheName"
          ],
          "title": "Writable Directory Cache",
          "type": "object"
        }
      },
      "description": "This schema defines the structure of the `payload` property referred to in a\nTaskcluster Task definition.",
      "properties": {
        "artifacts": {
          "description": "Artifacts to be published.\n\nSince: generic-worker 1.0.0",
          "items": {
            "additionalProperties": false,
            "properties": {
              "contentEncoding": {
                "description": "Content-Encoding for the artifact. If not provided, `gzip` will be used, except for the\nfollowing file extensions, where `identity` will be used, since they are already\ncompressed:\n\n* 7z\n* bz2\n* deb\n* dmg\n* flv\n* gif\n* gz\n* jpeg\n* jpg\n* png\n* swf\n* tbz\n* tgz\n* webp\n* whl\n* woff\n* woff2\n* xz\n* zip\n* zst\n\nNote, setting `contentEncoding` on a directory artifact will apply the same content\nencoding to all the files contained in the directory.\n\nSince: generic-worker 16.2.0",
                "enum": [
                  "identity",
                  "gzip"
                ],
                "title": "Content-Encoding header when serving artifact over HTTP.",
                "type": "string"
              },
              "contentType": {
                "description": "Explicitly set the value of the HTTP `Content-Type` response header when the artifact(s)\nis/are served over HTTP(S). If not provided (this property is optional) the worker will\nguess the content type of artifacts based on the filename extension of the file storing\nthe artifact content. It does this by looking at the system filename-to-mimetype mappings\ndefined in multiple `mime.types` files located under `/etc`. Note, setting `contentType`\non a directory artifact will apply the same contentType to all files contained in the\ndirectory.\n\nSee [mime.TypeByExtension](https://pkg.go.dev/mime#TypeByExtension).\n\nSince: generic-worker 10.4.0",
                "title": "Content-Type header when serving artifact over HTTP",
                "type": "string"
              },
              "expires": {
                "description": "Date when artifact should expire must be in the future, no earlier than task deadline, but\nno later than task expiry. If not set, defaults to task expiry.\n\nSince: generic-worker 1.0.0",
                "format": "date-time",
                "title": "Expiry date and time",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact, as it will be published. If not set, `path` will be used.\nConventionally (although not enforced) path elements are forward slash separated. Example:\n`public/build/a/house`. Note, no scopes are required to read artifacts beginning `public/`.\nArtifact names not beginning `public/` are scope-protected (caller requires scopes to\ndownload the artifact). See the Queue documentation for more information.\n\nSince: generic-worker 8.1.0",
                "title": "Name of the artifact",
                "type": "string"
              },
              "path": {
                "description": "Relative path of the file/directory from the task directory. Note this is not an absolute\npath as is typically used in docker-worker, since the absolute task directory name is not\nknown when the task is submitted. Example: `dist\\regedit.exe`. It doesn't matter if\nforward slashes or backslashes are used.\n\nSince: generic-worker 1.0.0",
                "title": "Artifact location",
                "type": "string"
              },
              "type": {
                "description": "Artifacts can be either an individual `file` or a `directory` containing\npotentially multiple files with recursively included subdirectories.\n\nSince: generic-worker 1.0.0",
                "enum": [
                  "file",
                  "directory"
                ],
                "title": "Artifact upload type.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "path"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifacts to be published",
          "type": "array",
          "uniqueItems": true
        },
        "command": {
          "description": "One array per command (each command is an array of arguments). Several arrays\nfor several commands.\n\nSince: generic-worker 0.0.1",
          "items": {
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "type": "array",
            "uniqueItems": false
          },
          "minItems": 1,
          "title": "Commands to run",
          "type": "array",
          "uniqueItems": false
        },
        "env": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Env vars must be string to __string__ mappings (not number or boolean). For example:\n```\n{\n  \"PATH\": \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\",\n  \"GOOS\": \"darwin\",\n  \"FOO_ENABLE\": \"true\",\n  \"BAR_TOTAL\": \"3\"\n}\n```\n\nNote, the following environment variables will automatically be set in the task\ncommands:\n  * `TASK_ID` - the task ID of the currently running task\n  * `RUN_ID` - the run ID of the currently running task\n  * `TASKCLUSTER_ROOT_URL` - the root URL of the taskcluster deployment\n  * `TASKCLUSTER_PROXY_URL` (if taskcluster proxy feature enabled) - the\n     taskcluster authentication proxy for making unauthenticated taskcluster\n     API calls\n  * `TASKCLUSTER_WORKER_LOCATION`. See\n    [RFC #0148](https://github.com/taskcluster/taskcluster-rfcs/blob/master/rfcs/0148-taskcluster-worker-location.md)\n    for details.\n\nSince: generic-worker 0.0.1",
          "title": "Env vars",
          "type": "object"
        },
        "features": {
          "additionalProperties": false,
          "description": "Feature flags enable additional functionality.\n\nSince: generic-worker 5.3.0",
          "properties": {
            "taskclusterProxy": {
              "description": "The taskcluster proxy provides an easy and safe way to make authenticated\ntaskcluster requests within the scope(s) of a particular task. See\n[the github project](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) for more information.\n\nSince: generic-worker 10.6.0",
              "title": "Run [taskcluster-proxy](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) to allow tasks to dynamically proxy requests to taskcluster services",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Feature flags",
          "type": "object"
        },
        "maxRunTime": {
          "description": "Maximum time the task container can run in seconds.\n\nSince: generic-worker 0.0.1",
          "maximum": 86400,
          "minimum": 1,
          "multipleOf": 1,
          "title": "Maximum run time in seconds",
          "type": "integer"
        },
        "mounts": {
          "description": "Directories and/or files to be mounted.\n\nSince: generic-worker 5.4.0",
          "items": {
            "$ref": "#/definitions/mount",
            "title": "Mount"
          },
          "type": "array",
          "uniqueItems": false
        },
        "onExitStatus": {
          "additionalProperties": false,
          "description": "By default tasks will be resolved with `state/reasonResolved`: `completed/completed`\nif all task commands have a zero exit code, or `failed/failed` if any command has a\nnon-zero exit code. This payload property allows customsation of the task resolution\nbased on exit code of task commands.",
          "properties": {
            "retry": {
              "description": "Exit codes for any command in the task payload to cause this task to\nbe resolved as `exception/intermittent-task`. Typically the Queue\nwill then schedule a new run of the existing `taskId` (rerun) if not\nall task runs have been exhausted.\n\nSee [itermittent tasks](https://docs.taskcluster.net/docs/reference/platform/taskcluster-queue/docs/worker-interaction#intermittent-tasks) for more detail.\n\nSince: generic-worker 10.10.0",
              "items": {
                "minimum": 1,
                "title": "Exit codes",
                "type": "integer"
              },
              "title": "Intermittent task exit codes",
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
          ],
          "title": "Exit code handling",
          "type": "object"
        },
        "osGroups": {
          "description": "A list of OS Groups that the task user should be a member of. Not yet implemented on\nnon-Windows platforms, therefore this optional property may only be an empty array if\nprovided.\n\nSince: generic-worker 6.0.0",
          "items": {
            "type": "string"
          },
          "maxItems": 0,
          "title": "OS Groups",
          "type": "array",
          "uniqueItems": false
        },
        "supersederUrl": {
          "description": "This property is allowed for backward compatibility, but is unused.",
          "title": "unused",
          "type": "string"
        }
      },
      "required": [
        "command",
        "maxRunTime"
      ],
      "title": "Generic worker payload - simple, posix",
      "type": "object"
    },
    "filename": "schemas/generic-worker/simple_posix.json"
  },
  {
    "content": {
      "$id": "/schemas/generic-worker/multiuser_windows.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "content": {
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Requires scope `queue:get-artifact:<artifact-name>`.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "artifact": {
                  "maxLength": 1024,
                  "type": "string"
                },
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "taskId": {
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                }
              },
              "required": [
                "taskId",
                "artifact"
              ],
              "title": "Artifact Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "url": {
                  "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
                  "format": "uri",
                  "title": "URL",
                  "type": "string"
                }
              },
              "required": [
                "url"
              ],
              "title": "URL Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "raw": {
                  "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "title": "Raw",
                  "type": "string"
                }
              },
              "required": [
                "raw"
              ],
              "title": "Raw Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "base64": {
                  "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "pattern": "^[A-Za-z0-9/+]+[=]{0,2}$",
                  "title": "Base64",
                  "type": "string"
                }
              },
              "required": [
                "base64"
              ],
              "title": "Base64 Content",
              "type": "object"
            }
          ]
        },
        "fileMount": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Content of the file to be mounted.\n\nSince: generic-worker 5.4.0"
            },
            "file": {
              "description": "The filesystem location to mount the file.\n\nSince: generic-worker 5.4.0",
              "title": "File",
              "type": "string"
            }
          },
          "required": [
            "file",
            "content"
          ],
          "title": "File Mount",
          "type": "object"
        },
        "mount": {
          "oneOf": [
            {
              "$ref": "#/definitions/fileMount"
            },
            {
              "$ref": "#/definitions/writableDirectoryCache"
            },
            {
              "$ref": "#/definitions/readOnlyDirectory"
            }
          ],
          "title": "Mount"
        },
        "readOnlyDirectory": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Contents of read only directory.\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory",
              "type": "string"
            },
            "format": {
              "description": "Archive format of content for read only directory.\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "content",
            "format"
          ],
          "title": "Read Only Directory",
          "type": "object"
        },
        "writableDirectoryCache": {
          "additionalProperties": false,
          "dependencies": {
            "content": [
              "format"
            ],
            "format": [
              "content"
            ]
          },
          "properties": {
            "cacheName": {
              "description": "Implies a read/write cache directory volume. A unique name for the\ncache volume. Requires scope `generic-worker:cache:<cache-name>`.\nNote if this cache is loaded from an artifact, you will also require\nscope `queue:get-artifact:<artifact-name>` to use this cache.\n\nSince: generic-worker 5.4.0",
              "title": "Cache Name",
              "type": "string"
            },
            "content": {
              "$ref": "#/definitions/content",
              "description": "Optional content to be preloaded when initially creating the cache\n(if set, `format` must also be provided).\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory Volume",
              "type": "string"
            },
            "format": {
              "description": "Archive format of the preloaded content (if `content` provided).\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "cacheName"
          ],
          "title": "Writable Directory Cache",
          "type": "object"
        }
      },
      "description": "This schema defines the structure of the `payload` property referred to in a\nTaskcluster Task definition.",
      "properties": {
        "artifacts": {
          "description": "Artifacts to be published.\n\nSince: generic-worker 1.0.0",
          "items": {
            "additionalProperties": false,
            "properties": {
              "contentEncoding": {
                "description": "Content-Encoding for the artifact. If not provided, `gzip` will be used, except for the\nfollowing file extensions, where `identity` will be used, since they are already\ncompressed:\n\n* 7z\n* bz2\n* deb\n* dmg\n* flv\n* gif\n* gz\n* jpeg\n* jpg\n* png\n* swf\n* tbz\n* tgz\n* webp\n* whl\n* woff\n* woff2\n* xz\n* zip\n* zst\n\nNote, setting `contentEncoding` on a directory artifact will apply the same content\nencoding to all the files contained in the directory.\n\nSince: generic-worker 16.2.0",
                "enum": [
                  "identity",
                  "gzip"
                ],
                "title": "Content-Encoding header when serving artifact over HTTP.",
                "type": "string"
              },
              "contentType": {
                "description": "Explicitly set the value of the HTTP `Content-Type` response header when the artifact(s)\nis/are served over HTTP(S). If not provided (this property is optional) the worker will\nguess the content type of artifacts based on the filename extension of the file storing\nthe artifact content. It does this by looking at the system filename-to-mimetype mappings\ndefined in the Windows registry. Note, setting `contentType` on a directory artifact will\napply the same contentType to all files contained in the directory.\n\nSee [mime.TypeByExtension](https://pkg.go.dev/mime#TypeByExtension).\n\nSince: generic-worker 10.4.0",
                "title": "Content-Type header when serving artifact over HTTP",
                "type": "string"
              },
              "expires": {
                "description": "Date when artifact should expire must be in the future, no earlier than task deadline, but\nno later than task expiry. If not set, defaults to task expiry.\n\nSince: generic-worker 1.0.0",
                "format": "date-time",
                "title": "Expiry date and time",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact, as it will be published. If not set, `path` will be used.\nConventionally (although not enforced) path elements are forward slash separated. Example:\n`public/build/a/house`. Note, no scopes are required to read artifacts beginning `public/`.\nArtifact names not beginning `public/` are scope-protected (caller requires scopes to\ndownload the artifact). See the Queue documentation for more information.\n\nSince: generic-worker 8.1.0",
                "title": "Name of the artifact",
                "type": "string"
              },
              "path": {
                "description": "Relative path of the file/directory from the task directory. Note this is not an absolute\npath as is typically used in docker-worker, since the absolute task directory name is not\nknown when the task is submitted. Example: `dist\\regedit.exe`. It doesn't matter if\nforward slashes or backslashes are used.\n\nSince: generic-worker 1.0.0",
                "title": "Artifact location",
                "type": "string"
              },
              "type": {
                "description": "Artifacts can be either an individual `file` or a `directory` containing\npotentially multiple files with recursively included subdirectories.\n\nSince: generic-worker 1.0.0",
                "enum": [
                  "file",
                  "directory"
                ],
                "title": "Artifact upload type.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "path"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifacts to be published",
          "type": "array",
          "uniqueItems": true
        },
        "command": {
          "description": "One entry per command (consider each entry to be interpreted as a full line of\na Windows™ .bat file). For example:\n```\n[\n  \"set\",\n  \"echo hello world > hello_world.txt\",\n  \"set GOPATH=C:\\\\Go\"\n]\n```\n\nSince: generic-worker 0.0.1",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "title": "Commands to run",
          "type": "array",
          "uniqueItems": false
        },
        "env": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Env vars must be string to __string__ mappings (not number or boolean). For example:\n```\n{\n  \"PATH\": \"C:\\\\Windows\\\\system32;C:\\\\Windows\",\n  \"GOOS\": \"windows\",\n  \"FOO_ENABLE\": \"true\",\n  \"BAR_TOTAL\": \"3\"\n}\n```\n\nNote, the following environment variables will automatically be set in the task\ncommands:\n  * `TASK_ID` - the task ID of the currently running task\n  * `RUN_ID` - the run ID of the currently running task\n  * `TASKCLUSTER_ROOT_URL` - the root URL of the taskcluster deployment\n  * `TASKCLUSTER_PROXY_URL` (if taskcluster proxy feature enabled) - the\n     taskcluster authentication proxy for making unauthenticated taskcluster\n     API calls\n  * `TASK_USER_CREDENTIALS` (if config property `runTasksAsCurrentUser` set to\n    `true` in `generic-worker.config` file - the absolute file location of a\n    json file containing the current task OS user account name and password.\n    This is only useful for the generic-worker multiuser CI tasks, where\n    `runTasksAsCurrentUser` is set to `true`.\n  * `TASKCLUSTER_WORKER_LOCATION`. See\n    [RFC #0148](https://github.com/taskcluster/taskcluster-rfcs/blob/master/rfcs/0148-taskcluster-worker-location.md)\n    for details.\n\nSince: generic-worker 0.0.1",
          "title": "Env vars",
          "type": "object"
        },
        "features": {
          "additionalProperties": false,
          "description": "Feature flags enable additional functionality.\n\nSince: generic-worker 5.3.0",
          "properties": {
            "chainOfTrust": {
              "description": "Artifacts named `public/chain-of-trust.json` and\n`public/chain-of-trust.json.sig` should be generated which will\ninclude information for downstream tasks to build a level of trust\nfor the artifacts produced by the task and the environment it ran in.\n\nSince: generic-worker 5.3.0",
              "title": "Enable generation of signed Chain of Trust artifacts",
              "type": "boolean"
            },
            "runAsAdministrator": {
              "description": "Runs commands with UAC elevation. Only set to true when UAC is\nenabled on the worker and Administrative privileges are required by\ntask commands. When UAC is disabled on the worker, task commands will\nalready run with full user privileges, and therefore a value of true\nwill result in a malformed-payload task exception.\n\nA value of true does not add the task user to the `Administrators`\ngroup - see the `osGroups` property for that. Typically\n`task.payload.osGroups` should include an Administrative group, such\nas `Administrators`, when setting to true.\n\nFor security, `runAsAdministrator` feature cannot be used in\nconjunction with `chainOfTrust` feature.\n\nRequires scope\n`generic-worker:run-as-administrator:<provisionerId>/<workerType>`.\n\nSince: generic-worker 10.11.0",
              "title": "Run commands with UAC process elevation",
              "type": "boolean"
            },
            "taskclusterProxy": {
              "description": "The taskcluster proxy provides an easy and safe way to make authenticated\ntaskcluster requests within the scope(s) of a particular task. See\n[the github project](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) for more information.\n\nSince: generic-worker 10.6.0",
              "title": "Run [taskcluster-proxy](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) to allow tasks to dynamically proxy requests to taskcluster services",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Feature flags",
          "type": "object"
        },
        "maxRunTime": {
          "description": "Maximum time the task container can run in seconds.\n\nSince: generic-worker 0.0.1",
          "maximum": 86400,
          "minimum": 1,
          "multipleOf": 1,
          "title": "Maximum run time in seconds",
          "type": "integer"
        },
        "mounts": {
          "description": "Directories and/or files to be mounted.\n\nSince: generic-worker 5.4.0",
          "items": {
            "$ref": "#/definitions/mount",
            "title": "Mount"
          },
          "type": "array",
          "uniqueItems": false
        },
        "onExitStatus": {
          "additionalProperties": false,
          "description": "By default tasks will be resolved with `state/reasonResolved`: `completed/completed`\nif all task commands have a zero exit code, or `failed/failed` if any command has a\nnon-zero exit code. This payload property allows customsation of the task resolution\nbased on exit code of task commands.",
          "properties": {
            "retry": {
              "description": "Exit codes for any command in the task payload to cause this task to\nbe resolved as `exception/intermittent-task`. Typically the Queue\nwill then schedule a new run of the existing `taskId` (rerun) if not\nall task runs have been exhausted.\n\nSee [itermittent tasks](https://docs.taskcluster.net/docs/reference/platform/taskcluster-queue/docs/worker-interaction#intermittent-tasks) for more detail.\n\nSince: generic-worker 10.10.0",
              "items": {
                "minimum": 1,
                "title": "Exit codes",
                "type": "integer"
              },
              "title": "Intermittent task exit codes",
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
          ],
          "title": "Exit code handling",
          "type": "object"
        },
        "osGroups": {
          "description": "A list of OS Groups that the task user should be a member of. Requires scope\n`generic-worker:os-group:<provisionerId>/<workerType>/<os-group>` for each\ngroup listed.\n\nSince: generic-worker 6.0.0",
          "items": {
            "type": "string"
          },
          "title": "OS Groups",
          "type": "array",
          "uniqueItems": false
        },
        "rdpInfo": {
          "description": "Specifies an artifact name for publishing RDP connection information.\n\nSince this is potentially sensitive data, care should be taken to publish\nto a suitably locked down path, such as\n`login-identity/<login-identity>/rdpinfo.json` which is only readable for\nthe given login identity (for example\n`login-identity/mozilla-ldap/pmoore@mozilla.com/rdpinfo.json`). See the\n[artifact namespace guide](https://docs.taskcluster.net/docs/manual/using/namespaces#artifacts) for more information.\n\nUse of this feature requires scope\n`generic-worker:allow-rdp:<provisionerId>/<workerType>` which must be\ndeclared as a task scope.\n\nThe RDP connection data is published during task startup so that a user\nmay interact with the running task.\n\nThe task environment will be retained for 12 hours after the task\ncompletes, to enable an interactive user to perform investigative tasks.\nAfter these 12 hours, the worker will delete the task's Windows user\naccount, and then continue with other tasks.\n\nNo guarantees are given about the resolution status of the interactive\ntask, since the task is inherently non-reproducible and no automation\nshould rely on this value.\n\nSince: generic-worker 10.5.0",
          "title": "RDP Info",
          "type": "string"
        },
        "supersederUrl": {
          "description": "This property is allowed for backward compatibility, but is unused.",
          "title": "unused",
          "type": "string"
        }
      },
      "required": [
        "command",
        "maxRunTime"
      ],
      "title": "Generic worker payload - multiuser, windows",
      "type": "object"
    },
    "filename": "schemas/generic-worker/multiuser_windows.json"
  },
  {
    "content": {
      "$id": "/schemas/generic-worker/multiuser_posix.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "content": {
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Requires scope `queue:get-artifact:<artifact-name>`.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "artifact": {
                  "maxLength": 1024,
                  "type": "string"
                },
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "taskId": {
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                }
              },
              "required": [
                "taskId",
                "artifact"
              ],
              "title": "Artifact Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "url": {
                  "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
                  "format": "uri",
                  "title": "URL",
                  "type": "string"
                }
              },
              "required": [
                "url"
              ],
              "title": "URL Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "raw": {
                  "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "title": "Raw",
                  "type": "string"
                }
              },
              "required": [
                "raw"
              ],
              "title": "Raw Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "base64": {
                  "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "pattern": "^[A-Za-z0-9/+]+[=]{0,2}$",
                  "title": "Base64",
                  "type": "string"
                }
              },
              "required": [
                "base64"
              ],
              "title": "Base64 Content",
              "type": "object"
            }
          ]
        },
        "fileMount": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Content of the file to be mounted.\n\nSince: generic-worker 5.4.0"
            },
            "file": {
              "description": "The filesystem location to mount the file.\n\nSince: generic-worker 5.4.0",
              "title": "File",
              "type": "string"
            }
          },
          "required": [
            "file",
            "content"
          ],
          "title": "File Mount",
          "type": "object"
        },
        "mount": {
          "oneOf": [
            {
              "$ref": "#/definitions/fileMount"
            },
            {
              "$ref": "#/definitions/writableDirectoryCache"
            },
            {
              "$ref": "#/definitions/readOnlyDirectory"
            }
          ],
          "title": "Mount"
        },
        "readOnlyDirectory": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Contents of read only directory.\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory",
              "type": "string"
            },
            "format": {
              "description": "Archive format of content for read only directory.\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "content",
            "format"
          ],
          "title": "Read Only Directory",
          "type": "object"
        },
        "writableDirectoryCache": {
          "additionalProperties": false,
          "dependencies": {
            "content": [
              "format"
            ],
            "format": [
              "content"
            ]
          },
          "properties": {
            "cacheName": {
              "description": "Implies a read/write cache directory volume. A unique name for the\ncache volume. Requires scope `generic-worker:cache:<cache-name>`.\nNote if this cache is loaded from an artifact, you will also require\nscope `queue:get-artifact:<artifact-name>` to use this cache.\n\nSince: generic-worker 5.4.0",
              "title": "Cache Name",
              "type": "string"
            },
            "content": {
              "$ref": "#/definitions/content",
              "description": "Optional content to be preloaded when initially creating the cache\n(if set, `format` must also be provided).\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory Volume",
              "type": "string"
            },
            "format": {
              "description": "Archive format of the preloaded content (if `content` provided).\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "cacheName"
          ],
          "title": "Writable Directory Cache",
          "type": "object"
        }
      },
      "description": "This schema defines the structure of the `payload` property referred to in a\nTaskcluster Task definition.",
      "properties": {
        "artifacts": {
          "description": "Artifacts to be published.\n\nSince: generic-worker 1.0.0",
          "items": {
            "additionalProperties": false,
            "properties": {
              "contentEncoding": {
                "description": "Content-Encoding for the artifact. If not provided, `gzip` will be used, except for the\nfollowing file extensions, where `identity` will be used, since they are already\ncompressed:\n\n* 7z\n* bz2\n* deb\n* dmg\n* flv\n* gif\n* gz\n* jpeg\n* jpg\n* png\n* swf\n* tbz\n* tgz\n* webp\n* whl\n* woff\n* woff2\n* xz\n* zip\n* zst\n\nNote, setting `contentEncoding` on a directory artifact will apply the same content\nencoding to all the files contained in the directory.\n\nSince: generic-worker 16.2.0",
                "enum": [
                  "identity",
                  "gzip"
                ],
                "title": "Content-Encoding header when serving artifact over HTTP.",
                "type": "string"
              },
              "contentType": {
                "description": "Explicitly set the value of the HTTP `Content-Type` response header when the artifact(s)\nis/are served over HTTP(S). If not provided (this property is optional) the worker will\nguess the content type of artifacts based on the filename extension of the file storing\nthe artifact content. It does this by looking at the system filename-to-mimetype mappings\ndefined in multiple `mime.types` files located under `/etc`. Note, setting `contentType`\non a directory artifact will apply the same contentType to all files contained in the\ndirectory.\n\nSee [mime.TypeByExtension](https://pkg.go.dev/mime#TypeByExtension).\n\nSince: generic-worker 10.4.0",
                "title": "Content-Type header when serving artifact over HTTP",
                "type": "string"
              },
              "expires": {
                "description": "Date when artifact should expire must be in the future, no earlier than task deadline, but\nno later than task expiry. If not set, defaults to task expiry.\n\nSince: generic-worker 1.0.0",
                "format": "date-time",
                "title": "Expiry date and time",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact, as it will be published. If not set, `path` will be used.\nConventionally (although not enforced) path elements are forward slash separated. Example:\n`public/build/a/house`. Note, no scopes are required to read artifacts beginning `public/`.\nArtifact names not beginning `public/` are scope-protected (caller requires scopes to\ndownload the artifact). See the Queue documentation for more information.\n\nSince: generic-worker 8.1.0",
                "title": "Name of the artifact",
                "type": "string"
              },
              "path": {
                "description": "Relative path of the file/directory from the task directory. Note this is not an absolute\npath as is typically used in docker-worker, since the absolute task directory name is not\nknown when the task is submitted. Example: `dist\\regedit.exe`. It doesn't matter if\nforward slashes or backslashes are used.\n\nSince: generic-worker 1.0.0",
                "title": "Artifact location",
                "type": "string"
              },
              "type": {
                "description": "Artifacts can be either an individual `file` or a `directory` containing\npotentially multiple files with recursively included subdirectories.\n\nSince: generic-worker 1.0.0",
                "enum": [
                  "file",
                  "directory"
                ],
                "title": "Artifact upload type.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "path"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifacts to be published",
          "type": "array",
          "uniqueItems": true
        },
        "command": {
          "description": "One array per command (each command is an array of arguments). Several arrays\nfor several commands.\n\nSince: generic-worker 0.0.1",
          "items": {
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "type": "array",
            "uniqueItems": false
          },
          "minItems": 1,
          "title": "Commands to run",
          "type": "array",
          "uniqueItems": false
        },
        "env": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Env vars must be string to __string__ mappings (not number or boolean). For example:\n```\n{\n  \"PATH\": \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\",\n  \"GOOS\": \"darwin\",\n  \"FOO_ENABLE\": \"true\",\n  \"BAR_TOTAL\": \"3\"\n}\n```\n\nNote, the following environment variables will automatically be set in the task\ncommands, but may be overridden by environment variables in the task payload:\n  * `HOME` - the home directory of the task user\n  * `PATH` - `/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin`\n  * `USER` - the name of the task user\n\nThe following environment variables will automatically be set in the task\ncommands, and may not be overridden by environment variables in the task payload:\n  * `DISPLAY` - `:0` (Linux only)\n  * `TASK_ID` - the task ID of the currently running task\n  * `RUN_ID` - the run ID of the currently running task\n  * `TASKCLUSTER_ROOT_URL` - the root URL of the taskcluster deployment\n  * `TASKCLUSTER_PROXY_URL` (if taskcluster proxy feature enabled) - the\n     taskcluster authentication proxy for making unauthenticated taskcluster\n     API calls\n  * `TASK_USER_CREDENTIALS` (if config property `runTasksAsCurrentUser` set to\n    `true` in `generic-worker.config` file - the absolute file location of a\n    json file containing the current task OS user account name and password.\n    This is only useful for the generic-worker multiuser CI tasks, where\n    `runTasksAsCurrentUser` is set to `true`.\n  * `TASKCLUSTER_WORKER_LOCATION`. See\n    [RFC #0148](https://github.com/taskcluster/taskcluster-rfcs/blob/master/rfcs/0148-taskcluster-worker-location.md)\n    for details.\n\nSince: generic-worker 0.0.1",
          "title": "Env vars",
          "type": "object"
        },
        "features": {
          "additionalProperties": false,
          "description": "Feature flags enable additional functionality.\n\nSince: generic-worker 5.3.0",
          "properties": {
            "chainOfTrust": {
              "description": "Artifacts named `public/chain-of-trust.json` and\n`public/chain-of-trust.json.sig` should be generated which will\ninclude information for downstream tasks to build a level of trust\nfor the artifacts produced by the task and the environment it ran in.\n\nSince: generic-worker 5.3.0",
              "title": "Enable generation of signed Chain of Trust artifacts",
              "type": "boolean"
            },
            "taskclusterProxy": {
              "description": "The taskcluster proxy provides an easy and safe way to make authenticated\ntaskcluster requests within the scope(s) of a particular task. See\n[the github project](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) for more information.\n\nSince: generic-worker 10.6.0",
              "title": "Run [taskcluster-proxy](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) to allow tasks to dynamically proxy requests to taskcluster services",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Feature flags",
          "type": "object"
        },
        "maxRunTime": {
          "description": "Maximum time the task container can run in seconds.\n\nSince: generic-worker 0.0.1",
          "maximum": 86400,
          "minimum": 1,
          "multipleOf": 1,
          "title": "Maximum run time in seconds",
          "type": "integer"
        },
        "mounts": {
          "description": "Directories and/or files to be mounted.\n\nSince: generic-worker 5.4.0",
          "items": {
            "$ref": "#/definitions/mount",
            "title": "Mount"
          },
          "type": "array",
          "uniqueItems": false
        },
        "onExitStatus": {
          "additionalProperties": false,
          "description": "By default tasks will be resolved with `state/reasonResolved`: `completed/completed`\nif all task commands have a zero exit code, or `failed/failed` if any command has a\nnon-zero exit code. This payload property allows customsation of the task resolution\nbased on exit code of task commands.",
          "properties": {
            "retry": {
              "description": "Exit codes for any command in the task payload to cause this task to\nbe resolved as `exception/intermittent-task`. Typically the Queue\nwill then schedule a new run of the existing `taskId` (rerun) if not\nall task runs have been exhausted.\n\nSee [itermittent tasks](https://docs.taskcluster.net/docs/reference/platform/taskcluster-queue/docs/worker-interaction#intermittent-tasks) for more detail.\n\nSince: generic-worker 10.10.0",
              "items": {
                "minimum": 1,
                "title": "Exit codes",
                "type": "integer"
              },
              "title": "Intermittent task exit codes",
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
          ],
          "title": "Exit code handling",
          "type": "object"
        },
        "osGroups": {
          "description": "A list of OS Groups that the task user should be a member of. Not yet implemented on\nnon-Windows platforms, therefore this optional property may only be an empty array if\nprovided.\n\nSince: generic-worker 6.0.0",
          "items": {
            "type": "string"
          },
          "maxItems": 0,
          "title": "OS Groups",
          "type": "array",
          "uniqueItems": false
        },
        "supersederUrl": {
          "description": "This property is allowed for backward compatibility, but is unused.",
          "title": "unused",
          "type": "string"
        }
      },
      "required": [
        "command",
        "maxRunTime"
      ],
      "title": "Generic worker payload - multiuser, posix",
      "type": "object"
    },
    "filename": "schemas/generic-worker/multiuser_posix.json"
  },
  {
    "content": {
      "$id": "/schemas/generic-worker/docker_posix.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "content": {
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Requires scope `queue:get-artifact:<artifact-name>`.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "artifact": {
                  "maxLength": 1024,
                  "type": "string"
                },
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "taskId": {
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                }
              },
              "required": [
                "taskId",
                "artifact"
              ],
              "title": "Artifact Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
              "properties": {
                "sha256": {
                  "description": "The required SHA 256 of the content body.\n\nSince: generic-worker 10.8.0",
                  "pattern": "^[a-f0-9]{64}$",
                  "title": "SHA 256",
                  "type": "string"
                },
                "url": {
                  "description": "URL to download content from.\n\nSince: generic-worker 5.4.0",
                  "format": "uri",
                  "title": "URL",
                  "type": "string"
                }
              },
              "required": [
                "url"
              ],
              "title": "URL Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "raw": {
                  "description": "Byte-for-byte literal inline content of file/archive, up to 64KB in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "title": "Raw",
                  "type": "string"
                }
              },
              "required": [
                "raw"
              ],
              "title": "Raw Content",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
              "properties": {
                "base64": {
                  "description": "Base64 encoded content of file/archive, up to 64KB (encoded) in size.\n\nSince: generic-worker 11.1.0",
                  "maxLength": 65536,
                  "pattern": "^[A-Za-z0-9/+]+[=]{0,2}$",
                  "title": "Base64",
                  "type": "string"
                }
              },
              "required": [
                "base64"
              ],
              "title": "Base64 Content",
              "type": "object"
            }
          ]
        },
        "fileMount": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Content of the file to be mounted.\n\nSince: generic-worker 5.4.0"
            },
            "file": {
              "description": "The filesystem location to mount the file.\n\nSince: generic-worker 5.4.0",
              "title": "File",
              "type": "string"
            }
          },
          "required": [
            "file",
            "content"
          ],
          "title": "File Mount",
          "type": "object"
        },
        "mount": {
          "oneOf": [
            {
              "$ref": "#/definitions/fileMount"
            },
            {
              "$ref": "#/definitions/writableDirectoryCache"
            },
            {
              "$ref": "#/definitions/readOnlyDirectory"
            }
          ],
          "title": "Mount"
        },
        "readOnlyDirectory": {
          "additionalProperties": false,
          "properties": {
            "content": {
              "$ref": "#/definitions/content",
              "description": "Contents of read only directory.\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory",
              "type": "string"
            },
            "format": {
              "description": "Archive format of content for read only directory.\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "content",
            "format"
          ],
          "title": "Read Only Directory",
          "type": "object"
        },
        "writableDirectoryCache": {
          "additionalProperties": false,
          "dependencies": {
            "content": [
              "format"
            ],
            "format": [
              "content"
            ]
          },
          "properties": {
            "cacheName": {
              "description": "Implies a read/write cache directory volume. A unique name for the\ncache volume. Requires scope `generic-worker:cache:<cache-name>`.\nNote if this cache is loaded from an artifact, you will also require\nscope `queue:get-artifact:<artifact-name>` to use this cache.\n\nSince: generic-worker 5.4.0",
              "title": "Cache Name",
              "type": "string"
            },
            "content": {
              "$ref": "#/definitions/content",
              "description": "Optional content to be preloaded when initially creating the cache\n(if set, `format` must also be provided).\n\nSince: generic-worker 5.4.0",
              "title": "Content"
            },
            "directory": {
              "description": "The filesystem location to mount the directory volume.\n\nSince: generic-worker 5.4.0",
              "title": "Directory Volume",
              "type": "string"
            },
            "format": {
              "description": "Archive format of the preloaded content (if `content` provided).\n\nSince: generic-worker 5.4.0",
              "enum": [
                "rar",
                "tar.bz2",
                "tar.gz",
                "tar.xz",
                "tar.zst",
                "zip"
              ],
              "title": "Format",
              "type": "string"
            }
          },
          "required": [
            "directory",
            "cacheName"
          ],
          "title": "Writable Directory Cache",
          "type": "object"
        }
      },
      "description": "This schema defines the structure of the `payload` property referred to in a\nTaskcluster Task definition.",
      "properties": {
        "artifacts": {
          "description": "Artifacts to be published.\n\nSince: generic-worker 1.0.0",
          "items": {
            "additionalProperties": false,
            "properties": {
              "contentEncoding": {
                "description": "Content-Encoding for the artifact. If not provided, `gzip` will be used, except for the\nfollowing file extensions, where `identity` will be used, since they are already\ncompressed:\n\n* 7z\n* bz2\n* deb\n* dmg\n* flv\n* gif\n* gz\n* jpeg\n* jpg\n* png\n* swf\n* tbz\n* tgz\n* webp\n* whl\n* woff\n* woff2\n* xz\n* zip\n* zst\n\nNote, setting `contentEncoding` on a directory artifact will apply the same content\nencoding to all the files contained in the directory.\n\nSince: generic-worker 16.2.0",
                "enum": [
                  "identity",
                  "gzip"
                ],
                "title": "Content-Encoding header when serving artifact over HTTP.",
                "type": "string"
              },
              "contentType": {
                "description": "Explicitly set the value of the HTTP `Content-Type` response header when the artifact(s)\nis/are served over HTTP(S). If not provided (this property is optional) the worker will\nguess the content type of artifacts based on the filename extension of the file storing\nthe artifact content. It does this by looking at the system filename-to-mimetype mappings\ndefined in multiple `mime.types` files located under `/etc`. Note, setting `contentType`\non a directory artifact will apply the same contentType to all files contained in the\ndirectory.\n\nSee [mime.TypeByExtension](https://pkg.go.dev/mime#TypeByExtension).\n\nSince: generic-worker 10.4.0",
                "title": "Content-Type header when serving artifact over HTTP",
                "type": "string"
              },
              "expires": {
                "description": "Date when artifact should expire must be in the future, no earlier than task deadline, but\nno later than task expiry. If not set, defaults to task expiry.\n\nSince: generic-worker 1.0.0",
                "format": "date-time",
                "title": "Expiry date and time",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact, as it will be published. If not set, `path` will be used.\nConventionally (although not enforced) path elements are forward slash separated. Example:\n`public/build/a/house`. Note, no scopes are required to read artifacts beginning `public/`.\nArtifact names not beginning `public/` are scope-protected (caller requires scopes to\ndownload the artifact). See the Queue documentation for more information.\n\nSince: generic-worker 8.1.0",
                "title": "Name of the artifact",
                "type": "string"
              },
              "path": {
                "description": "Relative path of the file/directory from the task directory. Note this is not an absolute\npath as is typically used in docker-worker, since the absolute task directory name is not\nknown when the task is submitted. Example: `dist\\regedit.exe`. It doesn't matter if\nforward slashes or backslashes are used.\n\nSince: generic-worker 1.0.0",
                "title": "Artifact location",
                "type": "string"
              },
              "type": {
                "description": "Artifacts can be either an individual `file` or a `directory` containing\npotentially multiple files with recursively included subdirectories.\n\nSince: generic-worker 1.0.0",
                "enum": [
                  "file",
                  "directory"
                ],
                "title": "Artifact upload type.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "path"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifacts to be published",
          "type": "array",
          "uniqueItems": true
        },
        "command": {
          "description": "One array per command (each command is an array of arguments). Several arrays\nfor several commands.\n\nSince: generic-worker 0.0.1",
          "items": {
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "type": "array",
            "uniqueItems": false
          },
          "minItems": 1,
          "title": "Commands to run",
          "type": "array",
          "uniqueItems": false
        },
        "env": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Env vars must be string to __string__ mappings (not number or boolean). For example:\n```\n{\n  \"PATH\": \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\",\n  \"GOOS\": \"darwin\",\n  \"FOO_ENABLE\": \"true\",\n  \"BAR_TOTAL\": \"3\"\n}\n```\n\nNote, the following environment variables will automatically be set in the task\ncommands:\n  * `TASK_ID` - the task ID of the currently running task\n  * `RUN_ID` - the run ID of the currently running task\n  * `TASKCLUSTER_ROOT_URL` - the root URL of the taskcluster deployment\n  * `TASKCLUSTER_PROXY_URL` (if taskcluster proxy feature enabled) - the\n     taskcluster authentication proxy for making unauthenticated taskcluster\n     API calls\n  * `TASKCLUSTER_WORKER_LOCATION`. See\n    [RFC #0148](https://github.com/taskcluster/taskcluster-rfcs/blob/master/rfcs/0148-taskcluster-worker-location.md)\n    for details.\n\nSince: generic-worker 0.0.1",
          "title": "Env vars",
          "type": "object"
        },
        "features": {
          "additionalProperties": false,
          "description": "Feature flags enable additional functionality.\n\nSince: generic-worker 5.3.0",
          "properties": {
            "chainOfTrust": {
              "description": "Artifacts named `public/chain-of-trust.json` and\n`public/chain-of-trust.json.sig` should be generated which will\ninclude information for downstream tasks to build a level of trust\nfor the artifacts produced by the task and the environment it ran in.\n\nSince: generic-worker 5.3.0",
              "title": "Enable generation of signed Chain of Trust artifacts",
              "type": "boolean"
            },
            "taskclusterProxy": {
              "description": "The taskcluster proxy provides an easy and safe way to make authenticated\ntaskcluster requests within the scope(s) of a particular task. See\n[the github project](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) for more information.\n\nSince: generic-worker 10.6.0",
              "title": "Run [taskcluster-proxy](https://github.com/taskcluster/taskcluster/tree/main/tools/taskcluster-proxy) to allow tasks to dynamically proxy requests to taskcluster services",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Feature flags",
          "type": "object"
        },
        "maxRunTime": {
          "description": "Maximum time the task container can run in seconds.\n\nSince: generic-worker 0.0.1",
          "maximum": 86400,
          "minimum": 1,
          "multipleOf": 1,
          "title": "Maximum run time in seconds",
          "type": "integer"
        },
        "mounts": {
          "description": "Directories and/or files to be mounted.\n\nSince: generic-worker 5.4.0",
          "items": {
            "$ref": "#/definitions/mount",
            "title": "Mount"
          },
          "type": "array",
          "uniqueItems": false
        },
        "onExitStatus": {
          "additionalProperties": false,
          "description": "By default tasks will be resolved with `state/reasonResolved`: `completed/completed`\nif all task commands have a zero exit code, or `failed/failed` if any command has a\nnon-zero exit code. This payload property allows customsation of the task resolution\nbased on exit code of task commands.",
          "properties": {
            "retry": {
              "description": "Exit codes for any command in the task payload to cause this task to\nbe resolved as `exception/intermittent-task`. Typically the Queue\nwill then schedule a new run of the existing `taskId` (rerun) if not\nall task runs have been exhausted.\n\nSee [itermittent tasks](https://docs.taskcluster.net/docs/reference/platform/taskcluster-queue/docs/worker-interaction#intermittent-tasks) for more detail.\n\nSince: generic-worker 10.10.0",
              "items": {
                "minimum": 1,
                "title": "Exit codes",
                "type": "integer"
              },
              "title": "Intermittent task exit codes",
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
          ],
          "title": "Exit code handling",
          "type": "object"
        },
        "osGroups": {
          "description": "A list of OS Groups that the task user should be a member of. Not yet implemented on\nnon-Windows platforms, therefore this optional property may only be an empty array if\nprovided.\n\nSince: generic-worker 6.0.0",
          "items": {
            "type": "string"
          },
          "maxItems": 0,
          "title": "OS Groups",
          "type": "array",
          "uniqueItems": false
        },
        "supersederUrl": {
          "description": "This property is allowed for backward compatibility, but is unused.",
          "title": "unused",
          "type": "string"
        }
      },
      "required": [
        "command",
        "maxRunTime"
      ],
      "title": "Generic worker payload - docker, posix",
      "type": "object"
    },
    "filename": "schemas/generic-worker/docker_posix.json"
  },
  {
    "content": {
      "$id": "/schemas/docker-worker/v1/payload.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "definitions": {
        "artifact": {
          "additionalProperties": false,
          "properties": {
            "expires": {
              "format": "date-time",
              "title": "Date when artifact should expire must be in the future.",
              "type": "string"
            },
            "path": {
              "title": "Location of artifact in container, as an absolute path.",
              "type": "string"
            },
            "type": {
              "enum": [
                "file",
                "directory"
              ],
              "title": "Artifact upload type.",
              "type": "string"
            }
          },
          "required": [
            "type",
            "path"
          ],
          "type": "object"
        }
      },
      "description": "`.payload` field of the queue.",
      "properties": {
        "artifacts": {
          "additionalProperties": {
            "$ref": "#/definitions/artifact"
          },
          "description": "Artifact upload map example: ```{\"public/build.tar.gz\": {\"path\": \"/home/worker/build.tar.gz\", \"expires\": \"2016-05-28T16:12:56.693817Z\", \"type\": \"file\"}}```",
          "title": "Artifacts",
          "type": "object"
        },
        "cache": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Caches are mounted within the docker container at the mount point specified. Example: ```{ \"CACHE NAME\": \"/mount/path/in/container\" }```",
          "title": "Caches to mount point mapping.",
          "type": "object"
        },
        "capabilities": {
          "additionalProperties": false,
          "description": "Set of capabilities that must be enabled or made available to the task container Example: ```{ \"capabilities\": { \"privileged\": true }```",
          "properties": {
            "devices": {
              "additionalProperties": false,
              "description": "Allows devices from the host system to be attached to a task container similar to using `--device` in docker.",
              "properties": {
                "hostSharedMemory": {
                  "description": "Mount /dev/shm from the host in the container.",
                  "title": "Host shared memory device (Experimental)",
                  "type": "boolean"
                },
                "kvm": {
                  "description": "Mount /dev/kvm from the host in the container.",
                  "title": "/dev/kvm device (Experimental)",
                  "type": "boolean"
                },
                "loopbackAudio": {
                  "description": "Audio loopback device created using snd-aloop",
                  "title": "Loopback Audio device",
                  "type": "boolean"
                },
                "loopbackVideo": {
                  "description": "Video loopback device created using v4l2loopback.",
                  "title": "Loopback Video device",
                  "type": "boolean"
                }
              },
              "required": [
              ],
              "title": "Devices to be attached to task containers",
              "type": "object"
            },
            "privileged": {
              "default": false,
              "description": "Allows a task to run in a privileged container, similar to running docker with `--privileged`.  This only works for worker-types configured to enable it.",
              "title": "Privileged container",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Capabilities that must be available/enabled for the task container.",
          "type": "object"
        },
        "command": {
          "default": [
          ],
          "description": "Example: `['/bin/bash', '-c', 'ls']`.",
          "items": {
            "type": "string"
          },
          "title": "Docker command to run (see docker api).",
          "type": "array"
        },
        "env": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Example: ```\n{\n  \"PATH\": '/borked/path'\n  \"ENV_NAME\": \"VALUE\"\n}\n```",
          "title": "Environment variable mappings.",
          "type": "object"
        },
        "features": {
          "additionalProperties": false,
          "description": "Used to enable additional functionality.",
          "properties": {
            "allowPtrace": {
              "description": "This allows you to use the Linux ptrace functionality inside the container; it is otherwise disallowed by Docker's security policy.",
              "title": "Allow ptrace within the container",
              "type": "boolean"
            },
            "artifacts": {
              "description": "",
              "title": "Artifact uploads",
              "type": "boolean"
            },
            "bulkLog": {
              "description": "Useful if live logging is not interesting but the overalllog is later on",
              "title": "Bulk upload the task log into a single artifact",
              "type": "boolean"
            },
            "chainOfTrust": {
              "description": "Artifacts named chain-of-trust.json and chain-of-trust.json.sig should be generated which will include information for downstream tasks to build a level of trust for the artifacts produced by the task and the environment it ran in.",
              "title": "Enable generation of ed25519-signed Chain of Trust artifacts",
              "type": "boolean"
            },
            "dind": {
              "description": "Runs docker-in-docker and binds `/var/run/docker.sock` into the container. Doesn't allow privileged mode, capabilities or host volume mounts.",
              "title": "Docker in Docker",
              "type": "boolean"
            },
            "dockerSave": {
              "description": "Uploads docker images as artifacts",
              "title": "Docker save",
              "type": "boolean"
            },
            "interactive": {
              "description": "This allows you to interactively run commands inside the container and attaches you to the stdin/stdout/stderr over a websocket. Can be used for SSH-like access to docker containers.",
              "title": "Docker Exec Interactive",
              "type": "boolean"
            },
            "localLiveLog": {
              "description": "Logs are stored on the worker during the duration of tasks and available via http chunked streaming then uploaded to s3",
              "title": "Enable live logging (worker local)",
              "type": "boolean"
            },
            "taskclusterProxy": {
              "description": "The auth proxy allows making requests to taskcluster/queue and taskcluster/scheduler directly from your task with the same scopes as set in the task. This can be used to make api calls via the [client](https://github.com/taskcluster/taskcluster-client) CURL, etc... Without embedding credentials in the task.",
              "title": "Taskcluster auth proxy service",
              "type": "boolean"
            }
          },
          "required": [
          ],
          "title": "Feature flags",
          "type": "object"
        },
        "image": {
          "description": "Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace",
          "oneOf": [
            {
              "title": "Docker image name",
              "type": "string"
            },
            {
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string"
                },
                "type": {
                  "enum": [
                    "docker-image"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "type",
                "name"
              ],
              "title": "Named docker image",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "namespace": {
                  "type": "string"
                },
                "path": {
                  "type": "string"
                },
                "type": {
                  "enum": [
                    "indexed-image"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "type",
                "namespace",
                "path"
              ],
              "title": "Indexed docker image",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "path": {
                  "type": "string"
                },
                "taskId": {
                  "type": "string"
                },
                "type": {
                  "enum": [
                    "task-image"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "type",
                "taskId",
                "path"
              ],
              "title": "Docker image artifact",
              "type": "object"
            }
          ],
          "title": "Docker image."
        },
        "log": {
          "description": "Specifies a custom location for the livelog artifact",
          "title": "Custom log location",
          "type": "string"
        },
        "maxRunTime": {
          "description": "Maximum time the task container can run in seconds.",
          "maximum": 86400,
          "minimum": 1,
          "multipleOf": 1,
          "title": "Maximum run time in seconds",
          "type": "integer"
        },
        "onExitStatus": {
          "additionalProperties": false,
          "description": "By default docker-worker will fail a task with a non-zero exit status without retrying.  This payload property allows a task owner to define certain exit statuses that will be marked as a retriable exception.",
          "properties": {
            "purgeCaches": {
              "description": "If the task exists with a purge caches exit status, all caches associated with the task will be purged.",
              "items": {
                "title": "Exit statuses",
                "type": "integer"
              },
              "title": "Purge caches exit status",
              "type": "array"
            },
            "retry": {
              "description": "If the task exists with a retriable exit status, the task will be marked as an exception and a new run created.",
              "items": {
                "title": "Exit statuses",
                "type": "integer"
              },
              "title": "Retriable exit statuses",
              "type": "array"
            }
          },
          "required": [
          ],
          "title": "Exit status handling",
          "type": "object"
        },
        "supersederUrl": {
          "description": "Maintained for backward compatibility, but no longer used",
          "title": "(unused)",
          "type": "string"
        }
      },
      "required": [
        "image",
        "maxRunTime"
      ],
      "title": "Docker worker payload",
      "type": "object"
    },
    "filename": "schemas/docker-worker/v1/payload.json"
  },
  {
    "content": {
      "$id": "/schemas/common/values.schema.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "properties": {
        "applicationName": {
          "description": "The name of this deployment of Taskcluster.",
          "type": "string"
        },
        "auth": {
          "additionalProperties": false,
          "properties": {
            "aws_credentials_allowed_buckets": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "azure_accounts": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "azure_crypto_key": {
              "type": "string"
            },
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "docs_bucket": {
              "type": "string"
            },
            "gcp_credentials_allowed_projects": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "purgeExpiredClients": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "purgeExpiredClients"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "refs_bucket": {
              "type": "string"
            },
            "schemas_bucket": {
              "type": "string"
            },
            "sentry_auth_token": {
              "type": "string"
            },
            "sentry_host": {
              "type": "string"
            },
            "sentry_key_prefix": {
              "type": "string"
            },
            "sentry_organization": {
              "type": "string"
            },
            "sentry_team": {
              "type": "string"
            },
            "static_clients": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "websocktunnel_secret": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "static_clients",
            "read_db_url",
            "write_db_url",
            "pulse_username",
            "pulse_password"
          ],
          "title": "Configuration options for auth",
          "type": "object"
        },
        "built_in_workers": {
          "additionalProperties": false,
          "properties": {
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "server": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "server"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "taskcluster_client_id",
            "taskcluster_access_token"
          ],
          "title": "Configuration options for built-in-workers",
          "type": "object"
        },
        "certManagerClusterIssuerName": {
          "description": "Name of the cluster issuer, i.e. \"letsencrypt-prod\"",
          "type": "string"
        },
        "dockerImage": {
          "description": "The docker image containing taskcluster.",
          "type": "string"
        },
        "errorConfig": {
          "additionalProperties": true,
          "description": "Error reporting configuration for lib-monitor.",
          "properties": {
            "reporter": {
              "description": "Which reporter to use.",
              "type": "string"
            }
          },
          "required": [
            "reporter"
          ],
          "type": "object"
        },
        "forceSSL": {
          "description": "If true, all connections must use ssl",
          "type": "boolean"
        },
        "github": {
          "additionalProperties": false,
          "properties": {
            "bot_username": {
              "type": "string"
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "github_app_id": {
              "type": "string"
            },
            "github_private_pem": {
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "sync": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "worker": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "worker",
                "sync"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "provisioner_id": {
              "type": "string"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "webhook_secret": {
              "type": "string"
            },
            "worker_type": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "bot_username",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "github_private_pem",
            "github_app_id",
            "webhook_secret",
            "read_db_url",
            "write_db_url",
            "pulse_username",
            "pulse_password"
          ],
          "title": "Configuration options for github",
          "type": "object"
        },
        "hooks": {
          "additionalProperties": false,
          "properties": {
            "azure_crypto_key": {
              "type": "string"
            },
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "influx_connection": {
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expires": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "listeners": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "scheduler": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "scheduler",
                "listeners",
                "expires"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "read_db_url",
            "write_db_url",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "pulse_username",
            "pulse_password"
          ],
          "title": "Configuration options for hooks",
          "type": "object"
        },
        "imagePullSecret": {
          "description": "Secret name with docker credentials for private registry",
          "type": "string"
        },
        "index": {
          "additionalProperties": false,
          "properties": {
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expire": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "handlers": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "handlers",
                "expire"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "read_db_url",
            "write_db_url",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "pulse_username",
            "pulse_password"
          ],
          "title": "Configuration options for index",
          "type": "object"
        },
        "ingressCertName": {
          "description": "A google certificate name that the ingress can use to set up tls.",
          "type": "string"
        },
        "ingressStaticIpName": {
          "description": "A google static ip object that the ingress can use to maintain the same ip address.",
          "type": "string"
        },
        "ingressTlsSecretName": {
          "description": "Name of the secret where cert is stored, i.e. \"dev-cert\". This can be provisioned manually or automatically, by using cert-manager",
          "type": "string"
        },
        "ingressType": {
          "description": "Allows to use non-GLB ingress types, like \"nginx\"",
          "type": "string"
        },
        "meta": {
          "additionalProperties": true,
          "description": "Metadata about a deployment. This is not interpreted by Helm and can be used to store arbitrary metadata\nabout the configuration for use by other tooling.  It is automatically generated by `yarn dev:init`.",
          "type": "object"
        },
        "newRelic": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "If present, configuration for New Relic to be used by all services.  The properties and values of this\nobject are environment variables as given in\nhttps://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration\nIf omitted, the New Relic library will not be loaded.",
          "propertyNames": {
            "pattern": "^NEW_RELIC_[A-Z0-9_]*$"
          },
          "type": "object"
        },
        "nodeEnv": {
          "description": "You almost certainly want \"production\" here.",
          "type": "string"
        },
        "notify": {
          "additionalProperties": false,
          "properties": {
            "aws_access_key_id": {
              "type": "string"
            },
            "aws_region": {
              "type": "string"
            },
            "aws_secret_access_key": {
              "type": "string"
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "email_blacklist": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "email_source_address": {
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "matrix_access_token": {
              "type": "string"
            },
            "matrix_base_url": {
              "type": "string"
            },
            "matrix_user_id": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "handler": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "handler"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "slack_access_token": {
              "type": "string"
            },
            "slack_api_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "email_source_address",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url",
            "aws_access_key_id",
            "aws_secret_access_key",
            "pulse_username",
            "pulse_password"
          ],
          "title": "Configuration options for notify",
          "type": "object"
        },
        "object": {
          "additionalProperties": false,
          "properties": {
            "backend_map": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "backends": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "middleware": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expire": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "expire"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url"
          ],
          "title": "Configuration options for object",
          "type": "object"
        },
        "pulseAmqps": {
          "description": "whether to use amqps (TLS) to communicate with pulse (default true)",
          "type": "boolean"
        },
        "pulseHostname": {
          "description": "A rabbitmq cluster",
          "type": "string"
        },
        "pulseVhost": {
          "description": "The vhost this deployment will use on the rabbitmq cluster",
          "type": "string"
        },
        "purge_cache": {
          "additionalProperties": false,
          "properties": {
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expireCachePurges": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "expireCachePurges"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "read_db_url",
            "write_db_url",
            "taskcluster_client_id",
            "taskcluster_access_token"
          ],
          "title": "Configuration options for purge-cache",
          "type": "object"
        },
        "queue": {
          "additionalProperties": false,
          "properties": {
            "artifact_region": {
              "type": "string"
            },
            "aws_access_key_id": {
              "type": "string"
            },
            "aws_endpoint": {
              "type": "string"
            },
            "aws_force_path_style": {
              "type": "boolean"
            },
            "aws_secret_access_key": {
              "type": "string"
            },
            "aws_skip_cors_configuration": {
              "type": "boolean"
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "private_artifact_bucket": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "claimResolver": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "deadlineResolver": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "dependencyResolver": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireArtifacts": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireQueueMessages": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireTask": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireTaskDependency": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireTaskGroups": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expireWorkerInfo": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "claimResolver",
                "deadlineResolver",
                "dependencyResolver",
                "expireArtifacts",
                "expireTask",
                "expireTaskGroups",
                "expireTaskDependency",
                "expireQueueMessages",
                "expireWorkerInfo"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "public_artifact_bucket": {
              "type": "string"
            },
            "public_artifact_bucket_cdn": {
              "type": "string"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "sign_public_artifact_urls": {
              "type": "boolean"
            },
            "task_cache_max_size": {
              "type": "number"
            },
            "task_claim_timeout": {
              "type": "number"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "worker_info_update_frequency": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "public_artifact_bucket",
            "private_artifact_bucket",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url",
            "pulse_username",
            "pulse_password",
            "aws_access_key_id",
            "aws_secret_access_key",
            "artifact_region"
          ],
          "title": "Configuration options for queue",
          "type": "object"
        },
        "references": {
          "additionalProperties": false,
          "properties": {
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web"
              ],
              "title": "Process settings for this service",
              "type": "object"
            }
          },
          "required": [
            "procs"
          ],
          "title": "Configuration options for references",
          "type": "object"
        },
        "rootUrl": {
          "description": "The url pointing to your deployment's ingress.",
          "format": "uri",
          "type": "string"
        },
        "secrets": {
          "additionalProperties": false,
          "properties": {
            "azure_crypto_key": {
              "type": "string"
            },
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expire": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "expire"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url"
          ],
          "title": "Configuration options for secrets",
          "type": "object"
        },
        "trustProxy": {
          "description": "If true, only the external ingress needs to use ssl. connections to services are allowed however.",
          "type": "boolean"
        },
        "ui": {
          "additionalProperties": false,
          "properties": {
            "banner_message": {
              "type": "string"
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "graphql_endpoint": {
              "type": "string"
            },
            "graphql_subscription_endpoint": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "site_specific": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "ui_login_strategy_names": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "graphql_subscription_endpoint",
            "graphql_endpoint",
            "ui_login_strategy_names"
          ],
          "title": "Configuration options for ui",
          "type": "object"
        },
        "useKubernetesDnsServiceDiscovery": {
          "description": "If true, requests will not pass back in through load balancer to pass between services.",
          "type": "boolean"
        },
        "web_server": {
          "additionalProperties": false,
          "properties": {
            "additional_allowed_cors_origin": {
              "type": "string"
            },
            "azure_crypto_key": {
              "type": "string"
            },
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "cleanup_expire_access_tokens": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "cleanup_expire_auth_codes": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "scanner": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "scanner",
                "cleanup_expire_auth_codes",
                "cleanup_expire_access_tokens"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "public_url": {
              "type": "string"
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "registered_clients": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "session_secret": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "ui_login_strategies": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "public_url",
            "additional_allowed_cors_origin",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url",
            "pulse_username",
            "pulse_password",
            "registered_clients",
            "ui_login_strategies",
            "session_secret"
          ],
          "title": "Configuration options for web-server",
          "type": "object"
        },
        "worker_manager": {
          "additionalProperties": false,
          "properties": {
            "db_crypto_keys": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "debug": {
              "title": "node debug env var",
              "type": "string"
            },
            "level": {
              "type": "string"
            },
            "procs": {
              "additionalProperties": false,
              "properties": {
                "expire_errors": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expire_worker_pools": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "expire_workers": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "provisioner": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "web": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "workerscanner": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                },
                "workerscanner_azure": {
                  "additionalProperties": false,
                  "properties": {
                    "cpu": {
                      "type": "string"
                    },
                    "memory": {
                      "type": "string"
                    },
                    "replicas": {
                      "type": "integer"
                    }
                  },
                  "required": [
                    "replicas",
                    "memory",
                    "cpu"
                  ],
                  "type": "object"
                }
              },
              "required": [
                "web",
                "provisioner",
                "workerscanner",
                "workerscanner_azure",
                "expire_workers",
                "expire_worker_pools",
                "expire_errors"
              ],
              "title": "Process settings for this service",
              "type": "object"
            },
            "providers": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "provisioner_iterate_config": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "pulse_password": {
              "type": "string"
            },
            "pulse_username": {
              "type": "string"
            },
            "read_db_url": {
              "type": "string"
            },
            "taskcluster_access_token": {
              "type": "string"
            },
            "taskcluster_client_id": {
              "type": "string"
            },
            "worker_scanner_iterate_config": {
              "oneOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "array"
                }
              ]
            },
            "write_db_url": {
              "type": "string"
            }
          },
          "required": [
            "procs",
            "taskcluster_client_id",
            "taskcluster_access_token",
            "read_db_url",
            "write_db_url",
            "pulse_username",
            "pulse_password",
            "providers"
          ],
          "title": "Configuration options for worker-manager",
          "type": "object"
        }
      },
      "required": [
        "rootUrl",
        "dockerImage",
        "pulseHostname",
        "pulseVhost",
        "forceSSL",
        "trustProxy",
        "nodeEnv",
        "useKubernetesDnsServiceDiscovery",
        "auth",
        "built_in_workers",
        "github",
        "hooks",
        "index",
        "notify",
        "object",
        "purge_cache",
        "queue",
        "secrets",
        "web_server",
        "worker_manager",
        "ui",
        "references"
      ],
      "title": "Taskcluster Configuration Values",
      "type": "object"
    },
    "filename": "schemas/common/values.schema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metaschema.json#",
      "$ref": "http://json-schema.org/draft-06/schema#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "description": "This is simply a reference to the draft-06 JSON-schema.  It remains here\nfor historical compatibility.\n",
      "title": "Taskcluster JSON-Schema Meta-Schema"
    },
    "filename": "schemas/common/metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metadata-metaschema.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "allOf": [
        {
          "$ref": "./metaschema.json#"
        },
        {
          "$ref": "#/definitions/topLevelMetadata"
        }
      ],
      "definitions": {
        "topLevelMetadata": {
          "additionalProperties": true,
          "properties": {
            "metadata": {
              "additionalProperties": false,
              "description": "Metadata identifying the documents that the schema document describes,\ngiving both a name (a category of document) and a version (to allow\nseveral versions of the same category).  Consumers of the documents can\nconsult the schema metadata to determine how to process the document.\n\nAny changes to a schema that require changes to consumers of the described\ndocuments should be accompanied by a version increase.\n",
              "properties": {
                "name": {
                  "description": "This is used to identify the category of document for later consumption.\nIt is also used to determine schema id's.  Common values for Taskcluster\nreferences are `manifest`, `exchanges`, and `api`.\n",
                  "title": "Name of the document category",
                  "type": "string"
                },
                "version": {
                  "title": "Version of the document format",
                  "type": "integer"
                }
              },
              "required": [
                "version",
                "name"
              ],
              "title": "Metadata for this schema",
              "type": "object"
            }
          },
          "required": [
            "metadata"
          ],
          "type": "object"
        }
      },
      "description": "This is a refinement of the Taskcluster metaschema, with the following changes:\n\n  * top level must be an object (no trivial true or false schemas)\n  * `{metadata: {name, version}}` must be present at the top level\n\nNote that any schema that validates against this metaschema will also\nvalidate against the upstream draft-06 metaschema, and is usable by any\nJSON-schema tool.\n",
      "title": "JSON-Schema Meta-Schema, with the addition of a `metadata` property"
    },
    "filename": "schemas/common/metadata-metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v3.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "metadata": {
        "name": "manifest",
        "version": 3
      },
      "properties": {
        "references": {
          "description": "Array of URLs of reference documents",
          "items": {
            "formt": "uri",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "references"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v3.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v2.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "properties": {
        "services": {
          "default": [
          ],
          "description": "List of services that comprise a taskcluster build.",
          "items": {
            "additionalProperties": false,
            "description": "A taskcluster microservice's APIs",
            "properties": {
              "apis": {
                "default": [
                ],
                "description": "HTTP API exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "HTTP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/api-reference-v1.json#` describing the API exposed by service.",
                      "title": "HTTP API reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "HTTP API Reference",
                  "type": "object"
                },
                "title": "HTTP APIs",
                "type": "array",
                "uniqueItems": true
              },
              "pulse": {
                "default": [
                ],
                "description": "Pulse exchanges exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "AMQP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/exchanges-reference-v1.json#` describing the API exposed by service.",
                      "title": "Pulse exchanges reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "Pulse reference",
                  "type": "object"
                },
                "title": "Pulse references",
                "type": "array",
                "uniqueItems": true
              },
              "serviceName": {
                "description": "A short name for the service, such as `queue` / `purge-cache` / `ec2-manager`.\nThis matches the `serviceName` field in any references linked from here.\n",
                "pattern": "^[a-z][a-z0-9_-]*$",
                "title": "Service Name",
                "type": "string"
              }
            },
            "required": [
              "serviceName"
            ],
            "title": "Service",
            "type": "object"
          },
          "title": "List of taskcluster services",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "services"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v2.json"
  },
  {
    "content": {
      "$id": "/schemas/common/logs-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of messages output by structured logging",
      "metadata": {
        "name": "logs",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Log Message Reference",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of the taskcluster service",
          "pattern": "^[a-z][a-z0-9_-]*$",
          "title": "Service Name",
          "type": "string"
        },
        "types": {
          "description": "Array of log message types",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "A description of this message type",
                "type": "string"
              },
              "fields": {
                "additionalProperties": true,
                "description": "The set of fields that will be in every instance of this message type. Mapping field name to description.",
                "type": "object"
              },
              "level": {
                "description": "Either \"any\" or the syslog level that this log will write at.",
                "enum": [
                  "emerg",
                  "alert",
                  "crit",
                  "err",
                  "warning",
                  "notice",
                  "info",
                  "debug",
                  "any"
                ]
              },
              "name": {
                "description": "The service-specific name of this message type.",
                "pattern": "^[a-z][a-zA-Z0-9_]*",
                "type": "string"
              },
              "title": {
                "description": "A human-readable name for the message type.",
                "type": "string"
              },
              "type": {
                "description": "The \"type\" of the message will be in the top-level keys of a message under the name \"Type\".",
                "pattern": "^[a-z][a-z0-9.-_]*",
                "type": "string"
              },
              "version": {
                "description": "The version of the fields for this log type. Will increment for breaking changes.",
                "minimum": 1,
                "type": "integer"
              }
            },
            "required": [
              "type",
              "title",
              "name",
              "level",
              "version",
              "description",
              "fields"
            ],
            "title": "Message Type",
            "type": "object"
          },
          "title": "Types",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "serviceName",
        "$schema",
        "types"
      ],
      "title": "Log Messages Reference File",
      "type": "object"
    },
    "filename": "schemas/common/logs-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/exchanges-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of exchanges published",
      "metadata": {
        "name": "exchanges",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "Description of set of exchanges in markdown",
          "type": "string"
        },
        "entries": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description (ie. documentation) for the exchange",
                "type": "string"
              },
              "exchange": {
                "description": "Exchange name on AMQP server, must be prefixed with `exchangePrefix` from this document.",
                "type": "string"
              },
              "name": {
                "description": "Name of exchange, this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "routingKey": {
                "items": {
                  "additionalProperties": false,
                  "properties": {
                    "constant": {
                      "description": "Constant to be used for this field, cannot be overwritten, only present if applicable.",
                      "type": "string"
                    },
                    "multipleWords": {
                      "description": "True, if key may contain dots, which AMQP will consider as words. This determines if `#` or `*` should be used in client libraries",
                      "type": "boolean"
                    },
                    "name": {
                      "description": "Identifier usable in client libraries",
                      "type": "string"
                    },
                    "required": {
                      "description": "True, if the key is always present, if `false` the value `_` will be used in place when no appropriate value is available for the key.",
                      "type": "boolean"
                    },
                    "summary": {
                      "description": "Short description of key in markdown",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "summary",
                    "multipleWords",
                    "required"
                  ],
                  "type": "object"
                },
                "type": "array",
                "uniqueItems": true
              },
              "schema": {
                "description": "JSON schema for messages on this exchange. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName>`.",
                "type": "string"
              },
              "title": {
                "description": "Title of exchange entry",
                "type": "string"
              },
              "type": {
                "const": "topic-exchange",
                "description": "Type of entry, currently only `topic-exchange`.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "exchange",
              "name",
              "title",
              "description",
              "routingKey",
              "schema"
            ],
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "exchangePrefix": {
          "description": "Prefix for all exchanges described in this document",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "Title for set of exchanges in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "serviceName",
        "title",
        "description",
        "exchangePrefix",
        "entries"
      ],
      "title": "Exchange Reference File",
      "type": "object"
    },
    "filename": "schemas/common/exchanges-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/api-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "scopeExpressionTemplate": {
          "oneOf": [
            {
              "$ref": "#/definitions/scopeExpressionTemplateString"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAllOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateIf"
            },
            {
              "additionalProperties": false,
              "description": "for/each/in objects will replace themselves with an array of basic scopes. They will be flattened into the array this object is a part of.",
              "properties": {
                "each": {
                  "pattern": "^[\\x20-\\x7e]*$",
                  "type": "string"
                },
                "for": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                },
                "in": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                }
              },
              "required": [
                "for",
                "each",
                "in"
              ],
              "title": "For-All",
              "type": "object"
            }
          ]
        },
        "scopeExpressionTemplateAllOf": {
          "additionalProperties": false,
          "description": "AllOf objects will evaluate to true if all subexpressions are true",
          "properties": {
            "AllOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AllOf"
          ],
          "title": "Conjunction",
          "type": "object"
        },
        "scopeExpressionTemplateAnyOf": {
          "additionalProperties": false,
          "description": "AnyOf objects will evaluate to true if any subexpressions are true",
          "properties": {
            "AnyOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AnyOf"
          ],
          "title": "Disjunction",
          "type": "object"
        },
        "scopeExpressionTemplateIf": {
          "additionalProperties": false,
          "description": "if/then objects will replace themselves with the contents of then if the `if` is true",
          "properties": {
            "else": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            },
            "if": {
              "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
              "type": "string"
            },
            "then": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            }
          },
          "required": [
            "if",
            "then"
          ],
          "title": "Conditional",
          "type": "object"
        },
        "scopeExpressionTemplateString": {
          "description": "The most basic element of a scope expression",
          "pattern": "^[\\x20-\\x7e]*$",
          "title": "Required-Scope",
          "type": "string"
        }
      },
      "description": "Reference of methods implemented by API",
      "metadata": {
        "name": "api",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "API description in markdown",
          "type": "string"
        },
        "entries": {
          "description": "Array of methods in this reference",
          "items": {
            "additionalProperties": false,
            "properties": {
              "args": {
                "description": "Arguments from `route` that must be replaced, they'll appear wrapped in brackets inside `route`.",
                "items": {
                  "description": "Argument that appears in `route` warpped in angle brackets. It must be replaced to call the function.",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "category": {
                "description": "Category for the API method",
                "type": "string"
              },
              "description": {
                "description": "Description (ie. documentation) for the API entry",
                "type": "string"
              },
              "input": {
                "description": "JSON schema for input, if input is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                "type": "string"
              },
              "method": {
                "description": "HTTP method (verb) used to access the function",
                "enum": [
                  "get",
                  "post",
                  "put",
                  "head",
                  "delete",
                  "options",
                  "trace",
                  "copy",
                  "lock",
                  "mkcol",
                  "move",
                  "purge",
                  "propfind",
                  "proppatch",
                  "unlock",
                  "report",
                  "mkactivity",
                  "checkout",
                  "merge",
                  "m-search",
                  "notify",
                  "subscribe",
                  "unsubscribe",
                  "patch",
                  "search"
                ],
                "type": "string"
              },
              "name": {
                "description": "Name of the `function` this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "output": {
                "oneOf": [
                  {
                    "description": "JSON schema for output, if output is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                    "title": "Output Schema",
                    "type": "string"
                  },
                  {
                    "description": "Output kind if not JSON matching a specific schema.",
                    "enum": [
                      "blob"
                    ],
                    "title": "Blob",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "query": {
                "description": "List of accepted query-string parameters, these are always optional.",
                "items": {
                  "description": "Optional query-string parameter",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "route": {
                "description": "Route for the call, note that arguments wrapped with brackets, like `/user/<userId>/` must be replaced.",
                "type": "string"
              },
              "scopes": {
                "description": "Scope expression template specifying required scopes for a method. Not provided if authentication isn't required.",
                "oneOf": [
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateString"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAllOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateIf"
                  }
                ]
              },
              "stability": {
                "description": "Stability level of the API",
                "enum": [
                  "deprecated",
                  "experimental",
                  "stable"
                ],
                "title": "Stability-Level",
                "type": "string"
              },
              "title": {
                "description": "Title of API entry",
                "type": "string"
              },
              "type": {
                "description": "Type of entry, currently only `function`.",
                "enum": [
                  "function"
                ],
                "type": "string"
              }
            },
            "required": [
              "type",
              "method",
              "route",
              "args",
              "name",
              "stability",
              "title",
              "description",
              "category"
            ],
            "title": "API Entry",
            "type": "object"
          },
          "title": "Entries",
          "type": "array",
          "uniqueItems": true
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "API title in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "title",
        "description",
        "serviceName",
        "entries"
      ],
      "title": "API Reference File",
      "type": "object"
    },
    "filename": "schemas/common/api-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/action-schema-v1.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "definitions": {
        "context": {
          "default": [
          ],
          "description": "The `context` property determines in what context the action is\nrelevant. Thus, what context the action should be presented to the\nend-user.\n",
          "items": {
            "additionalProperties": {
              "maxLength": 4096,
              "type": "string"
            },
            "description": "A set of key-value pairs specifying a _tag-set_.\n",
            "title": "tag-set",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "description": {
          "description": "Human readable description of the action in markdown. This\ncan be displayed in a tooltip, popup and/or dialog when triggering\nthe action.\n",
          "maxLength": 4096,
          "type": "string"
        },
        "extra": {
          "description": "Extra data that the decision task wishes to include for use by other\nservices interpreting `actions.json`.  Consumers of this file are free to\nignore any and all data in this field.\n",
          "type": "object"
        },
        "name": {
          "description": "The name of this action.  This is used by user interfaces to\nidentify the action.\n",
          "maxLength": 255,
          "type": "string"
        },
        "schema": {
          "description": "JSON schema for user input to the action.  If this property is omitted,\nthen the input is `null`.\n"
        },
        "title": {
          "description": "Title text to be displayed on the button or link triggering the action.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "description": "This document specifies the schema for the `public/actions.json` used by\n_decision tasks_ to expose actions that can be triggered by end-users.\n\nFor the purpose of this document the _consumer_ is the user-interface that\ndisplays task results to the end-user and allows end-users to trigger actions\ndefined by `public/actions.json`. A _consumer_ might be Treeherder.\nThe _end-user_ is a developer who is inspecting the results, and wishes to\ntrigger actions.\n",
      "properties": {
        "actions": {
          "description": "List of actions that can be triggered.\n",
          "items": {
            "anyOf": [
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "kind": {
                    "enum": [
                      "task"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "task": {
                    "description": "Task template for triggering the action.\n\nWhen an action have been selected in the appropriate context and\ninput satisfying the `schema` (if any) has been collected. The\naction is triggered by parameterizing the task template given in\nthis property, and creating the resulting task.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the context\ndescribed in the documentation.\n",
                    "title": "Task Template",
                    "type": "object"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "task"
                ],
                "type": "object"
              },
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "hookGroupId": {
                    "description": "The `hookGroupId` of the hook to trigger to run this action",
                    "title": "Hook Group ID",
                    "type": "string"
                  },
                  "hookId": {
                    "description": "The `hookId` of the hook to trigger to run this action",
                    "title": "Hook ID",
                    "type": "string"
                  },
                  "hookPayload": {
                    "description": "JSON-e template that renders to the payload for `hooks.triggerHook`.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the\ncontext described in the documentation. The output of this\nrendering is provided as the payload to `hooks.triggerHook`\n(where it becomes the context for another JSON-e rendering\nstep - don't get the two confused!)\n",
                    "title": "Hook Payload Template",
                    "type": "object"
                  },
                  "kind": {
                    "enum": [
                      "hook"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "hookGroupId",
                  "hookId",
                  "hookPayload"
                ],
                "type": "object"
              }
            ]
          },
          "type": "array",
          "uniqueItems": true
        },
        "variables": {
          "additionalProperties": true,
          "description": "Additional variables included in JSON-e context.\n",
          "type": "object"
        },
        "version": {
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "actions",
        "variables"
      ],
      "title": "Schema for Exposing Actions",
      "type": "object"
    },
    "filename": "schemas/common/action-schema-v1.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/websocktunnel-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Token for connecting a worker to websocktunnel proxy\n",
      "properties": {
        "expires": {
          "description": "The time at which the JWT will expire.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "token": {
          "description": "The JWT to be used as `Bearer <token>` when connecting to the service.\n",
          "title": "Token",
          "type": "string"
        },
        "wstAudience": {
          "description": "Audience identifying the websocktunnel servers that will honor this token; this will be the\nsame as the requested `wstAudience`.\n",
          "pattern": "^[a-zA-Z0-9_-]{1,38}$",
          "title": "Websocktunnel Audience",
          "type": "string"
        },
        "wstClient": {
          "description": "Id for the websocktunnel client connection; this will be the same as the requested `wstClient`.\n",
          "pattern": "^[a-zA-Z0-9_~.%-]+$",
          "title": "Websocktunnel Client",
          "type": "string"
        }
      },
      "required": [
        "wstClient",
        "wstAudience",
        "token",
        "expires"
      ],
      "title": "Websocktunnel Token Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/websocktunnel-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request was authenticated.\n",
      "properties": {
        "clientId": {
          "description": "ClientId from the request as it will be logged\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the request was authorized.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "scopes"
      ],
      "title": "Test Authenticate Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request should be authenticated.\n",
      "properties": {
        "clientScopes": {
          "default": [
          ],
          "description": "List of scopes that should be client used should be given.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "requiredScopes": {
          "default": [
          ],
          "description": "List of scopes the request should require.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientScopes",
        "requiredScopes"
      ],
      "title": "Test Authenticate Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/sentry-dsn-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Sentry DSN for submitting errors.\n",
      "properties": {
        "dsn": {
          "additionalProperties": false,
          "description": "Access credentials and urls for the Sentry project.\nCredentials will expire in 24-48 hours, you should refresh them within\n24 hours.\n",
          "properties": {
            "public": {
              "description": "Access credential and URL for public error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in client-side applications only.\n",
              "format": "uri",
              "type": "string"
            },
            "secret": {
              "description": "Access credential and URL for private error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in serser-side applications and should **not** be\nleaked.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "secret",
            "public"
          ],
          "type": "object"
        },
        "expires": {
          "description": "Expiration time for the credentials. The credentials should not be used\nafter this time. They might not be revoked immediately, but will be at\nsome arbitrary point after this date-time.\n",
          "format": "date-time",
          "type": "string"
        },
        "project": {
          "description": "Project name that the DSN grants access to.\n",
          "title": "Project",
          "type": "string"
        }
      },
      "required": [
        "project",
        "dsn",
        "expires"
      ],
      "title": "Sentry DSN Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/sentry-dsn-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/scopeset.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A set of scopes\n",
      "properties": {
        "scopes": {
          "description": "List of scopes.  Scopes must be composed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes"
      ],
      "title": "Set of scopes",
      "type": "object"
    },
    "filename": "schemas/auth/v1/scopeset.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/role-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a role has changed\n",
      "properties": {
        "roleId": {
          "description": "`roleId` of the role that was changed\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "roleId"
      ],
      "title": "Role Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/role-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles2-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roles": {
          "description": "A list of requested roles\n",
          "items": {
            "$ref": "get-role-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roles"
      ],
      "title": "Get All Roles Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-roles2-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "List of roles\n",
      "items": {
        "$ref": "get-role-response.json#"
      },
      "title": "Get All Roles (no pagination)",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/auth/v1/list-roles-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-role-ids-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roleIds": {
          "description": "A list of requested roleIds\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roleIds"
      ],
      "title": "Get Role Ids Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-role-ids-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-clients-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of clients\n",
      "properties": {
        "clients": {
          "items": {
            "$ref": "get-client-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "clients"
      ],
      "title": "List Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-clients-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-role-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a role\n",
      "properties": {
        "created": {
          "description": "Date and time when this role was created\n",
          "format": "date-time",
          "type": "string"
        },
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expandedScopes": {
          "description": "List of scopes granted anyone who assumes this role, including anything\ngranted by roles that can be assumed when you have this role.\nHence, this includes any scopes in-directly granted as well.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "roleId": {
          "description": "roleId of the role requested\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "roleId",
        "scopes",
        "description",
        "created",
        "lastModified",
        "expandedScopes"
      ],
      "title": "Get Role Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-role-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a client, useful for tools modifying a client\n",
      "properties": {
        "clientId": {
          "description": "ClientId of the client scopes is requested about\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope that client is granted by a role\n",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Get Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/gcp-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for a request to get a GCP temporary credential.\n",
      "properties": {
        "accessToken": {
          "description": "Temporary oauth2 access token to access the given service account\n",
          "title": "Temporary access token",
          "type": "string"
        },
        "expireTime": {
          "description": "The access token expire time",
          "format": "date-time",
          "title": "Expire time",
          "type": "string"
        }
      },
      "required": [
        "accessToken",
        "expireTime"
      ],
      "title": "GCP Credentials Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/gcp-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-role-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Data to create or update a role.\n",
      "properties": {
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes",
        "description"
      ],
      "title": "Create Role Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-role-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "All details about a client including the `accessToken`\n",
      "properties": {
        "accessToken": {
          "description": "AccessToken used for authenticating requests, you should store this\nyou won't be able to retrive it again!\n",
          "pattern": "^[a-zA-Z0-9_-]{22,66}$",
          "type": "string"
        },
        "clientId": {
          "description": "ClientId of the client\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles, including the\nclient's scopes and the implicit role `client-id:<clientId>`.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Create Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Properties to create a client.\n",
      "properties": {
        "deleteOnExpiration": {
          "default": false,
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false` (the default), the client will remain after expiration, although\nit cannot be used for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "pattern": "^[ -~]*$",
            "title": "Scope",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "expires",
        "description"
      ],
      "title": "Create Client Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/client-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a client has changed\n",
      "properties": {
        "clientId": {
          "description": "`clientId` of the client that was changed\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "clientId"
      ],
      "title": "Client Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/client-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure tables in an account\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tables.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `azureAccountTables` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tables": {
          "description": "A list of tables that are in an account. These are\nthe tables that can have SAS credentials fetched for them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Tables",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tables"
      ],
      "title": "Azure List Table Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-access-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access and Azure\nTable Storage table.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Table Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-access-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access an Azure\nBlob Storage container.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Blob Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure containers in an account\n",
      "properties": {
        "containers": {
          "description": "A list of containers that are in an account.  Credentials are available for\nthese containers from the `azureBlobSAS` method.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Containers",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of containers.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called this method with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "containers"
      ],
      "title": "Azure List Containers Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-account-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure accounts managed by taskcluster-auth\n",
      "properties": {
        "accounts": {
          "description": "A list of accountIds that are managed by auth. These are\nthe accounts that can have SAS credentials fetched for tables\nwithin them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Accounts",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "accounts"
      ],
      "title": "Azure List Account Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-account-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/aws-s3-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for a request to get access to an S3 bucket.\n",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "Temporary STS credentials for use when operating on S3\n",
          "properties": {
            "accessKeyId": {
              "description": "Access key identifier that identifies the temporary security\ncredentials.\n",
              "title": "AccessKeyId",
              "type": "string"
            },
            "secretAccessKey": {
              "description": "Secret access key used to sign requests\n",
              "title": "SecretAccessKey",
              "type": "string"
            },
            "sessionToken": {
              "description": "A token that must passed with request to use the temporary\nsecurity credentials.\n",
              "title": "SessionToken",
              "type": "string"
            }
          },
          "required": [
            "accessKeyId",
            "secretAccessKey",
            "sessionToken"
          ],
          "title": "Temporary Security Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Date and time of when the temporary credentials expires.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "credentials",
        "expires"
      ],
      "title": "AWS S3 Credentials Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/aws-s3-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response from a request to authenticate a hawk request.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "clientId": {
              "description": "The `clientId` that made this request.  This may be the `id` supplied in\nthe Authorization header, or in the case of a named temporary credential\nmay be embedded in the payload.  In any case, this clientId can be used\nfor logging, auditing, and identifying the credential but **must** not be\nused for access control.  That's what scopes are for.\n",
              "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
              "type": "string"
            },
            "expires": {
              "description": "The expiration time that the returned scopes are valid for.\nThis should be treated as the latest time at which the authorization\nis valid. For most cases, where the access being authorized occurs\nimmediately, this field can be ignored, as the value will always be\nin the future.\n",
              "format": "date-time",
              "type": "string"
            },
            "hash": {
              "description": "Payload as extracted from `Authentication` header. This property is\nonly present if a hash is available. You are not required to validate\nthis hash, but if you do, please check `scheme` to ensure that it's\non a scheme you support.\n"
            },
            "scheme": {
              "description": "Authentication scheme the client used. Generally, you don't need to\nread this property unless `hash` is provided and you want to validate\nthe payload hash. Additional values may be added in the future.\n",
              "enum": [
                "hawk"
              ],
              "type": "string"
            },
            "scopes": {
              "description": "List of scopes the client is authorized to access.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
              "items": {
                "pattern": "^[ -~]*$",
                "type": "string"
              },
              "type": "array",
              "uniqueItems": true
            },
            "status": {
              "description": "If `auth-success`, the request has successfully authenticated.\nThis does not imply authorization (i.e. scope satisfaction not guaranteed).\n",
              "enum": [
                "auth-success"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "scopes",
            "scheme",
            "clientId",
            "expires"
          ],
          "title": "Authentication Successful Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "description": "Message saying why the authentication failed.\n",
              "type": "string"
            },
            "status": {
              "description": "If `auth-failed`, the request failed to authenticate (e.g., invalid credentials).\n",
              "enum": [
                "auth-failed"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "message"
          ],
          "title": "Authentication Failed Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "expires": {
              "description": "The expiration time that the returned scopes are valid for.\nThis should be treated as the latest time at which the authorization\nis valid. For most cases, where the access being authorized occurs\nimmediately, this field can be ignored, as the value will always be\nin the future.\n",
              "format": "date-time",
              "type": "string"
            },
            "scheme": {
              "description": "Authentication scheme the client used. Generally, you don't need to\nread this property unless `hash` is provided and you want to validate\nthe payload hash. Additional values may be added in the future.\n",
              "enum": [
                "none"
              ],
              "type": "string"
            },
            "scopes": {
              "description": "List of scopes the client is authorized to access.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
              "items": {
                "pattern": "^[ -~]*$",
                "type": "string"
              },
              "type": "array",
              "uniqueItems": true
            },
            "status": {
              "description": "If `no-auth`, the request provided no credentials or bewit.\n",
              "enum": [
                "no-auth"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "scheme",
            "scopes",
            "expires"
          ],
          "title": "No Authentication Response",
          "type": "object"
        }
      ],
      "title": "Hawk Signature Authentication Response"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to authenticate a hawk request.\n",
      "properties": {
        "authorization": {
          "description": "Authorization header, **must** only be specified if request being\nauthenticated has a `Authorization` header.\n",
          "type": "string"
        },
        "host": {
          "description": "Host for which the request came in, this is typically the `Host` header\nexcluding the port if any.\n",
          "format": "hostname",
          "title": "Hostname or IPv4",
          "type": "string"
        },
        "method": {
          "description": "HTTP method of the request being authenticated.\n",
          "enum": [
            "get",
            "post",
            "put",
            "head",
            "delete",
            "options",
            "trace",
            "copy",
            "lock",
            "mkcol",
            "move",
            "purge",
            "propfind",
            "proppatch",
            "unlock",
            "report",
            "mkactivity",
            "checkout",
            "merge",
            "m-search",
            "notify",
            "subscribe",
            "unsubscribe",
            "patch",
            "search",
            "connect"
          ],
          "type": "string"
        },
        "port": {
          "description": "Port on which the request came in, this is typically `80` or `443`.\nIf you are running behind a reverse proxy look for the `x-forwarded-port`\nheader.\n",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "resource": {
          "description": "Resource the request operates on including querystring. This is the\nstring that follows the HTTP method.\n**Note,** order of querystring elements is important.\n",
          "type": "string"
        },
        "sourceIp": {
          "description": "Source IP of the authentication request or request that requires\nauthentication. This is only used for audit logging.\n",
          "oneOf": [
            {
              "format": "ipv6"
            },
            {
              "format": "ipv4"
            }
          ],
          "title": "Source IP",
          "type": "string"
        }
      },
      "required": [
        "method",
        "resource",
        "host",
        "port"
      ],
      "title": "Hawk Signature Authentication Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-request.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "worker-manager",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "Rate limiting engaged for a cloud api",
          "fields": {
            "duration": "Length of time the queue is paused for in ms.",
            "providerId": "Which provider has hit a limit",
            "queueName": "Which queue is paused -- there is one for each class of api request",
            "queueSize": "Number of requests remaining in the queue when it is paused.",
            "reason": "Either `errors` or `rateLimit`."
          },
          "level": "any",
          "name": "cloudApiPaused",
          "title": "Cloud API Paused",
          "type": "cloud-api-paused",
          "version": 1
        },
        {
          "description": "A provider has resumed api requests.",
          "fields": {
            "providerId": "Which provider has hit a limit (each provider manages a single project)",
            "queueName": "Which queue is paused -- there is one for each class of api request"
          },
          "level": "notice",
          "name": "cloudApiResumed",
          "title": "Cloud API Resumed",
          "type": "cloud-api-resumed",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Something has tried to register as a worker but failed. This could indicate either a bug\nor that somebody is trying to impersonate a worker.",
          "fields": {
            "error": "Error message from cloud that triggered this",
            "message": "Description of this error from the taskcluster side",
            "providerId": "The provider that did the work for this worker pool.",
            "workerId": "The worker that failed",
            "workerPoolId": "The worker pool ID"
          },
          "level": "warning",
          "name": "registrationErrorWarning",
          "title": "Registration Error Warning",
          "type": "registration-error-warning",
          "version": 1
        },
        {
          "description": "A worker's identify proof message was signed by an unknown intermediate certificate.\nThis was successfully downloaded, verified by root CAs, and added to the CA store.",
          "fields": {
            "fingerprint": "The fingerprint of the certificate",
            "issuer": "The distinguished name of the certificate issuer",
            "subject": "The distinguished name of the certificate subject",
            "url": "The URL from which the certificate was downloaded"
          },
          "level": "warning",
          "name": "registrationNewIntermediateCertificate",
          "title": "Registration of New Intermediate Certificate",
          "type": "registration-new-intermediate-certificate",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "The results of a worker-scanner run",
          "fields": {
            "providerId": "The provider that has completed this scan",
            "seen": "A map of workerPoolId that were seen to how much capacity was seen",
            "total": "Total number of workers seen"
          },
          "level": "notice",
          "name": "scanSeen",
          "title": "Scan Seen",
          "type": "scan-seen",
          "version": 3
        },
        {
          "description": "The simple estimator has decided that we need some number of instances.",
          "fields": {
            "desiredCapacity": "Amount of capacity that this estimator thinks we should have",
            "existingCapacity": "Amount of currently requested and available capacity",
            "maxCapacity": "The maximum amount of capacity that should be running",
            "minCapacity": "The minimum amount of capacity that should be running",
            "pendingTasks": "The number of tasks the queue reports are pending for this worker pool",
            "requestedCapacity": "Amount of capacity that this estimator thinks we should add",
            "scalingRatio": "The ratio of workers to spawn per pending task for this worker pool.",
            "workerPoolId": "The worker pool name"
          },
          "level": "any",
          "name": "simpleEstimate",
          "title": "Simple Estimate Provided",
          "type": "simple-estimate",
          "version": 3
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An error was reported regarding the given worker pool.  Such errors are generally\nthe responsibility of the owner of the worker pool, but may also indicate issues\nwith the Taskcluster deployment and as such are reported in the service logs as\nwell.  Note that the 'extra' data associated with such a report is not included\nhere.  To see that, use the UI or API to view the worker pool errors directly.",
          "fields": {
            "description": "Description of the error",
            "errorId": "The unique id of this error report",
            "kind": "The error kind",
            "title": "The error title",
            "workerPoolId": "The workerPool where the error occurred"
          },
          "level": "notice",
          "name": "workerError",
          "title": "Worker Error",
          "type": "worker-error",
          "version": 1
        },
        {
          "description": "A worker pool's provisioning run has completed",
          "fields": {
            "duration": "Time taken to provision the worker pool in ms",
            "providerId": "The provider that did the work for this worker pool.",
            "workerPoolId": "The worker pool ID"
          },
          "level": "info",
          "name": "workerPoolProvisioned",
          "title": "Worker Pool Provisioned",
          "type": "worker-pool-provisioned",
          "version": 2
        },
        {
          "description": "A request has been made to stop a worker.  This operation can sometimes\ntake some time.",
          "fields": {
            "providerId": "The provider that did the work for this worker pool.",
            "reason": "The reason this worker is being removed",
            "workerId": "The worker that is being removed",
            "workerPoolId": "The worker pool ID"
          },
          "level": "notice",
          "name": "workerRemoved",
          "title": "Worker Removed",
          "type": "worker-removed",
          "version": 1
        },
        {
          "description": "A worker has been requested from a cloud api",
          "fields": {
            "providerId": "The provider that did the work for this worker pool.",
            "terminateAfter": "Time after which worker should be terminated",
            "workerGroup": "The worker group for this worker",
            "workerId": "The worker that was created",
            "workerPoolId": "The worker pool ID"
          },
          "level": "notice",
          "name": "workerRequested",
          "title": "Worker Requested",
          "type": "worker-requested",
          "version": 1
        },
        {
          "description": "A worker has been marked as running",
          "fields": {
            "providerId": "The provider that did the work for this worker pool.",
            "workerId": "The worker that is running",
            "workerPoolId": "The worker pool ID"
          },
          "level": "notice",
          "name": "workerRunning",
          "title": "Worker Running",
          "type": "worker-running",
          "version": 1
        },
        {
          "description": "A worker has been marked as stopped",
          "fields": {
            "providerId": "The provider that did the work for this worker pool.",
            "workerId": "The worker that was stopped",
            "workerPoolId": "The worker pool ID"
          },
          "level": "notice",
          "name": "workerStopped",
          "title": "Worker Stopped",
          "type": "worker-stopped",
          "version": 1
        }
      ]
    },
    "filename": "references/worker-manager/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "These exchanges provide notifications when a worker pool is created or updated.This is so that the provisioner running in a differentprocess at the other end can synchronize to the changes. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create aworker pool, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "worker-pool-created",
          "name": "workerPoolCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-worker-pool-message.json#",
          "title": "Worker Pool Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update aworker pool, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "worker-pool-updated",
          "name": "workerPoolUpdated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-worker-pool-message.json#",
          "title": "Worker Pool Updated Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-worker-manager/v1/",
      "serviceName": "worker-manager",
      "title": "Worker Manager Exchanges"
    },
    "filename": "references/worker-manager/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This service manages workers, including provisioning for dynamic worker pools.\n\nMethods interacting with a provider may return a 503 response if that provider has\nnot been able to start up, such as if the service to which it interfaces has an\noutage.  Such requests can be retried as for any other 5xx response.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Providers",
          "description": "Retrieve a list of providers that are available for worker pools.",
          "method": "get",
          "name": "listProviders",
          "output": "v1/provider-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/providers",
          "scopes": "worker-manager:list-providers",
          "stability": "stable",
          "title": "List Providers",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Pools",
          "description": "Create a new worker pool. If the worker pool already exists, this will throw an error.",
          "input": "v1/create-worker-pool-request.json#",
          "method": "put",
          "name": "createWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "worker-manager:manage-worker-pool:<workerPoolId>",
              "worker-manager:provider:<providerId>"
            ]
          },
          "stability": "stable",
          "title": "Create Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Pools",
          "description": "Given an existing worker pool definition, this will modify it and return\nthe new definition.\n\nTo delete a worker pool, set its `providerId` to `\"null-provider\"`.\nAfter any existing workers have exited, a cleanup job will remove the\nworker pool.  During that time, the worker pool can be updated again, such\nas to set its `providerId` to a real provider.",
          "input": "v1/update-worker-pool-request.json#",
          "method": "post",
          "name": "updateWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "worker-manager:manage-worker-pool:<workerPoolId>",
              "worker-manager:provider:<providerId>"
            ]
          },
          "stability": "experimental",
          "title": "Update Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Pools",
          "description": "Mark a worker pool for deletion.  This is the same as updating the pool to\nset its providerId to `\"null-provider\"`, but does not require scope\n`worker-manager:provider:null-provider`.",
          "method": "delete",
          "name": "deleteWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": "worker-manager:manage-worker-pool:<workerPoolId>",
          "stability": "stable",
          "title": "Delete Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Pools",
          "description": "Fetch an existing worker pool defition.",
          "method": "get",
          "name": "workerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": "worker-manager:get-worker-pool:<workerPoolId>",
          "stability": "stable",
          "title": "Get Worker Pool",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Pools",
          "description": "Get the list of all the existing worker pools.",
          "method": "get",
          "name": "listWorkerPools",
          "output": "v1/worker-pool-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/worker-pools",
          "scopes": "worker-manager:list-worker-pools",
          "stability": "stable",
          "title": "List All Worker Pools",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Interface",
          "description": "Report an error that occurred on a worker.  This error will be included\nwith the other errors in `listWorkerPoolErrors(workerPoolId)`.\n\nWorkers can use this endpoint to report startup or configuration errors\nthat might be associated with the worker pool configuration and thus of\ninterest to a worker-pool administrator.\n\nNOTE: errors are publicly visible.  Ensure that none of the content\ncontains secrets or other sensitive information.",
          "input": "v1/report-worker-error-request.json#",
          "method": "post",
          "name": "reportWorkerError",
          "output": "v1/worker-pool-error.json#",
          "query": [
          ],
          "route": "/worker-pool-errors/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "assume:worker-pool:<workerPoolId>",
              "assume:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "stable",
          "title": "Report an error from a worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Pools",
          "description": "Get the list of worker pool errors.",
          "method": "get",
          "name": "listWorkerPoolErrors",
          "output": "v1/worker-pool-error-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/worker-pool-errors/<workerPoolId>",
          "scopes": "worker-manager:list-worker-pool-errors:<workerPoolId>",
          "stability": "stable",
          "title": "List Worker Pool Errors",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup"
          ],
          "category": "Workers",
          "description": "Get the list of all the existing workers in a given group in a given worker pool.",
          "method": "get",
          "name": "listWorkersForWorkerGroup",
          "output": "v1/worker-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>",
          "scopes": "worker-manager:list-workers:<workerPoolId>/<workerGroup>",
          "stability": "stable",
          "title": "Workers in a specific Worker Group in a Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Workers",
          "description": "Get a single worker.",
          "method": "get",
          "name": "worker",
          "output": "v1/worker-full.json#",
          "query": [
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
          "scopes": "worker-manager:get-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Get a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Workers",
          "description": "Create a new worker.  This is only useful for worker pools where the provider\ndoes not create workers automatically, such as those with a `static` provider\ntype.  Providers that do not support creating workers will return a 400 error.\nSee the documentation for the individual providers, and in particular the\n[static provider](https://docs.taskcluster.net/docs/reference/core/worker-manager/)\nfor more information.",
          "input": "v1/create-worker-request.json#",
          "method": "put",
          "name": "createWorker",
          "output": "v1/worker-full.json#",
          "query": [
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
          "scopes": "worker-manager:create-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Create a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Workers",
          "description": "Update an existing worker in-place.  Like `createWorker`, this is only useful for\nworker pools where the provider does not create workers automatically.\nThis method allows updating all fields in the schema unless otherwise indicated\nin the provider documentation.\nSee the documentation for the individual providers, and in particular the\n[static provider](https://docs.taskcluster.net/docs/reference/core/worker-manager/)\nfor more information.",
          "input": "v1/create-worker-request.json#",
          "method": "post",
          "name": "updateWorker",
          "output": "v1/worker-full.json#",
          "query": [
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
          "scopes": "worker-manager:update-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Update an existing Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Workers",
          "description": "Remove an existing worker.  The precise behavior of this method depends\non the provider implementing the given worker.  Some providers\ndo not support removing workers at all, and will return a 400 error.\nOthers may begin removing the worker, but it may remain available via\nthe API (perhaps even in state RUNNING) afterward.",
          "method": "delete",
          "name": "removeWorker",
          "query": [
          ],
          "route": "/workers/<workerPoolId>/<workerGroup>/<workerId>",
          "scopes": "worker-manager:remove-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Remove a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Workers",
          "description": "Get the list of all the existing workers in a given worker pool.",
          "method": "get",
          "name": "listWorkersForWorkerPool",
          "output": "v1/worker-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/workers/<workerPoolId>",
          "scopes": "worker-manager:list-workers:<workerPoolId>",
          "stability": "stable",
          "title": "Workers in a Worker Pool",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Interface",
          "description": "Register a running worker.  Workers call this method on worker start-up.\n\nThis call both marks the worker as running and returns the credentials\nthe worker will require to perform its work.  The worker must provide\nsome proof of its identity, and that proof varies by provider type.",
          "input": "v1/register-worker-request.json#",
          "method": "post",
          "name": "registerWorker",
          "output": "v1/register-worker-response.json#",
          "query": [
          ],
          "route": "/worker/register",
          "stability": "stable",
          "title": "Register a running worker",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Workers",
          "description": "Reregister a running worker.\n\nThis will generate and return new Taskcluster credentials for the worker\non that instance to use. The credentials will not live longer the\n`registrationTimeout` for that worker. The endpoint will update `terminateAfter`\nfor the worker so that worker-manager does not terminate the instance.",
          "input": "v1/reregister-worker-request.json#",
          "method": "post",
          "name": "reregisterWorker",
          "output": "v1/reregister-worker-response.json#",
          "query": [
          ],
          "route": "/worker/reregister",
          "scopes": "worker-manager:reregister-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "experimental",
          "title": "Reregister a Worker",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Worker Metadata",
          "description": "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers,\nas well as the current state of the worker.\nTo filter the query, you should call the end-point with one of [`quarantined`, `workerState`]\nas a query-string option with a true or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkers",
          "output": "v1/list-workers-response.json#",
          "query": [
            "continuationToken",
            "limit",
            "quarantined",
            "workerState"
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
          "scopes": "worker-manager:list-workers:<provisionerId>/<workerType>",
          "stability": "experimental",
          "title": "Get a list of all active workers of a workerType",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Metadata",
          "description": "Get a worker from a worker-type.",
          "method": "get",
          "name": "getWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "scopes": "worker-manager:get-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>",
          "stability": "experimental",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "worker-manager",
      "title": "Worker Manager Service"
    },
    "filename": "references/worker-manager/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "web-server",
      "types": [
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "The PulseEngine has created a queue and bound it to one or more exchanges in\nresponse to a GraphQL subsscription request.",
          "fields": {
            "subscriptionId": "The subscriptionId, which will also appear in the AMQP queue name"
          },
          "level": "debug",
          "name": "bindPulseSubscription",
          "title": "Bind a Pulse Subscription",
          "type": "bind-pulse-subscription",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A client has been issued Taskcluster credentials",
          "fields": {
            "clientId": "The clientId of the issued credentials",
            "expires": "Date time when the issued credentials expires.",
            "userIdentity": "The identity of the user to which the credentials were issued"
          },
          "level": "info",
          "name": "createCredentials",
          "title": "Credentials Created",
          "type": "create-credentials",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "A GraphQL request has been received. The traceId/request is at the top-level of the log message, above these fields.",
          "fields": {
            "operationName": "The name of the graphql query performed. If the operation is anonymous\n(i.e., the operation is query { ... } instead of query NamedQuery { ... })\n, then operationName is null.",
            "query": "The graphQL query string"
          },
          "level": "notice",
          "name": "requestReceived",
          "title": "Request Received",
          "type": "request-received",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "The PulseEngine has deleted a queue bound to one or more exchanges in\nresponse to termination of a GraphQL subsscription request.",
          "fields": {
            "subscriptionId": "The subscriptionId, which will also appear in the AMQP queue name"
          },
          "level": "debug",
          "name": "unbindPulseSubscription",
          "title": "Unbind a Pulse Subscription",
          "type": "unbind-pulse-subscription",
          "version": 1
        }
      ]
    },
    "filename": "references/web-server/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "secrets",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/secrets/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
          "input": "v1/secret.json#",
          "method": "put",
          "name": "set",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Set Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Delete the secret associated with some key. It will succeed whether or not the secret exists",
          "method": "delete",
          "name": "remove",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Delete Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
          "method": "get",
          "name": "get",
          "output": "v1/secret.json#",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:get:<name>",
          "stability": "stable",
          "title": "Read Secret",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Secrets Service",
          "description": "List the names of all secrets.\n\nBy default this end-point will try to return up to 1000 secret names in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "list",
          "output": "v1/secret-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/secrets",
          "scopes": "secrets:list-secrets",
          "stability": "stable",
          "title": "List Secrets",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "secrets",
      "title": "Secrets Service"
    },
    "filename": "references/secrets/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "queue",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Report result of polling messages from an azure queue.",
          "fields": {
            "failed": "Number of these messages that failed to be handled.",
            "messages": "Number of messages fetched.",
            "resolver": "The name of the queue being polled."
          },
          "level": "info",
          "name": "azureQueuePoll",
          "title": "Azure Queue Poll",
          "type": "azure-queue-poll",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "Metrics of an iteration of the hint poller.",
          "fields": {
            "claimed": "Number of hints claimed on an iteration.",
            "released": "Number of hints released on an iteration. Should usually be 0.",
            "slept": "If true, there were no hints to claim and the poller slept before claiming again."
          },
          "level": "info",
          "name": "hintPoller",
          "title": "Hint Poller Report",
          "type": "hint-poller",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A worker has claimed a task.  In cases where multple tasks were claimed,\none log message will be produced for each task.",
          "fields": {
            "runId": "The run of this task assigned to the worker.",
            "taskId": "The task given to the worker.",
            "taskQueueId": "The task queue ID for which work is being claimed",
            "workerGroup": "Group of worker claiming work.",
            "workerId": "The id of the claiming worker."
          },
          "level": "notice",
          "name": "taskClaimed",
          "title": "Task Claimed",
          "type": "task-claimed",
          "version": 1
        },
        {
          "description": "A task run has been resolved as completed.  This is logged when the task-completed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskCompleted",
          "title": "Task Completed",
          "type": "task-completed",
          "version": 1
        },
        {
          "description": "A task has been created (createTask).  This is logged when the task-defined\npulse message is sent.",
          "fields": {
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskDefined",
          "title": "Task Defined",
          "type": "task-defined",
          "version": 1
        },
        {
          "description": "A task run has been resolved as an exception.  This is logged when the task-exception pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskException",
          "title": "Task Exception",
          "type": "task-exception",
          "version": 1
        },
        {
          "description": "A task run has been resolved as failed.  This is logged when the task-failed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskFailed",
          "title": "Task Failed",
          "type": "task-failed",
          "version": 1
        },
        {
          "description": "Task group was sealed and will no longer allow creation of tasks.",
          "fields": {
            "schedulerId": "Id of the reclaiming worker.",
            "taskGroupId": "Task group ID"
          },
          "level": "notice",
          "name": "taskGroupSealed",
          "title": "Task Group Sealed",
          "type": "task-group-sealed",
          "version": 1
        },
        {
          "description": "A task is now pending and ready to be executed.  This is logged when the task-pending pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that is now pending.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskPending",
          "title": "Task Pending",
          "type": "task-pending",
          "version": 1
        },
        {
          "description": "A worker has reclaimed a task it had previously claimed, extending its takenUntil\ntimestamp.",
          "fields": {
            "runId": "The run of this task being reclaimed.",
            "taskId": "The task being reclaimed.",
            "workerGroup": "Group of the reclaiming worker.",
            "workerId": "Id of the reclaiming worker."
          },
          "level": "notice",
          "name": "taskReclaimed",
          "title": "Task Reclaimed",
          "type": "task-reclaimed",
          "version": 1
        },
        {
          "description": "A task is now being executed.  This is logged when the task-running pulse message is sent.",
          "fields": {
            "runId": "The runId that is now running.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskRunning",
          "title": "Task Running",
          "type": "task-running",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/queue/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes AMQP exchanges offered by the queue, which allows\nthird-party listeners to monitor tasks as they progress to resolution.\nThese exchanges targets the following audience:\n * Schedulers, who takes action after tasks are completed,\n * Workers, who wants to listen for new or canceled tasks (optional),\n * Tools, that wants to update their view as task progress.\n\nYou'll notice that all the exchanges in the document shares the same\nrouting key pattern. This makes it very easy to bind to all messages\nabout a certain kind tasks.\n\n**Task specific routes**, a task can define a task specific route using\nthe `task.routes` property. See task creation documentation for details\non permissions required to provide task specific routes. If a task has\nthe entry `'notify.by-email'` in as task specific route defined in\n`task.routes` all messages about this task will be CC'ed with the\nrouting-key `'route.notify.by-email'`.\n\nThese routes will always be prefixed `route.`, so that cannot interfere\nwith the _primary_ routing key as documented here. Notice that the\n_primary_ routing key is always prefixed `primary.`. This is ensured\nin the routing key reference, so API clients will do this automatically.\n\nPlease, note that the way RabbitMQ works, the message will only arrive\nin your queue once, even though you may have bound to the exchange with\nmultiple routing key patterns that matches more of the CC'ed routing\nrouting keys.\n\n**Delivery guarantees**, most operations on the queue are idempotent,\nwhich means that if repeated with the same arguments then the requests\nwill ensure completion of the operation and return the same response.\nThis is useful if the server crashes or the TCP connection breaks, but\nwhen re-executing an idempotent operation, the queue will also resend\nany related AMQP messages. Hence, messages may be repeated.\n\nThis shouldn't be much of a problem, as the best you can achieve using\nconfirm messages with AMQP is at-least-once delivery semantics. Hence,\nthis only prevents you from obtaining at-most-once delivery semantics.\n\n**Remark**, some message generated by timeouts maybe dropped if the\nserver crashes at wrong time. Ideally, we'll address this in the\nfuture. For now we suggest you ignore this corner case, and notify us\nif this corner case is of concern to you.",
      "entries": [
        {
          "description": "When a task is created or just defined a message is posted to this\nexchange.\n\nThis message exchange is mainly useful when tasks are created with dependencies\non incomplete tasks, as this does not make the task\n`pending`. Thus, no `taskPending` message is published.",
          "exchange": "task-defined",
          "name": "taskDefined",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-defined-message.json#",
          "title": "Task Defined Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task becomes `pending` a message is posted to this exchange.\n\nThis is useful for workers who doesn't want to constantly poll the queue\nfor new tasks. The queue will also be authority for task states and\nclaims. But using this exchange workers should be able to distribute work\nefficiently and they would be able to reduce their polling interval\nsignificantly without affecting general responsiveness.",
          "exchange": "task-pending",
          "name": "taskPending",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-pending-message.json#",
          "title": "Task Pending Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever a task is claimed by a worker, a run is started on the worker,\nand a message is posted on this exchange.",
          "exchange": "task-running",
          "name": "taskRunning",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-running-message.json#",
          "title": "Task Running Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the `createArtifact` end-point is called, the queue will create\na record of the artifact and post a message on this exchange. All of this\nhappens before the queue returns a signed URL for the caller to upload\nthe actual artifact with (pending on `storageType`).\n\nThis means that the actual artifact is rarely available when this message\nis posted. But it is not unreasonable to assume that the artifact will\nwill become available at some point later. Most signatures will expire in\n30 minutes or so, forcing the uploader to call `createArtifact` with\nthe same payload again in-order to continue uploading the artifact.\n\nHowever, in most cases (especially for small artifacts) it's very\nreasonable assume the artifact will be available within a few minutes.\nThis property means that this exchange is mostly useful for tools\nmonitoring task evaluation. One could also use it count number of\nartifacts per task, or _index_ artifacts though in most cases it'll be\nsmarter to index artifacts after the task in question have completed\nsuccessfully.\n\n*NOTE*: this message is currently only sent for reference and error\nartifacts.  This will be remedied in a future version of Taskcluster.",
          "exchange": "artifact-created",
          "name": "artifactCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/artifact-created-message.json#",
          "title": "Artifact Creation Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task is successfully completed by a worker a message is posted\nthis exchange.\nThis message is routed using the `runId`, `workerGroup` and `workerId`\nthat completed the task. But information about additional runs is also\navailable from the task status structure.",
          "exchange": "task-completed",
          "name": "taskCompleted",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-completed-message.json#",
          "title": "Task Completed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task ran, but failed to complete successfully a message is posted\nto this exchange. This is same as worker ran task-specific code, but the\ntask specific code exited non-zero.",
          "exchange": "task-failed",
          "name": "taskFailed",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-failed-message.json#",
          "title": "Task Failed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever Taskcluster fails to run a message is posted to this exchange.\nThis happens if the task isn't completed before its `deadlìne`,\nall retries failed (i.e. workers stopped responding), the task was\ncanceled by another entity, or the task carried a malformed payload.\n\nThe specific _reason_ is evident from that task status structure, refer\nto the `reasonResolved` property for the last run.",
          "exchange": "task-exception",
          "name": "taskException",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-exception-message.json#",
          "title": "Task Exception Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message is published on task-group-resolved whenever all submitted\ntasks (whether scheduled or unscheduled) for a given task group have\nbeen resolved, regardless of whether they resolved as successful or\nnot. A task group may be resolved multiple times, since new tasks may\nbe submitted against an already resolved task group.",
          "exchange": "task-group-resolved",
          "name": "taskGroupResolved",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` for the task-group this message concerns"
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` for the task-group this message concerns"
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-group-resolved.json#",
          "title": "Task Group Resolved Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message is published on task-group-sealed whenever task group is sealed.\nThis task group will no longer allow creation of new tasks.",
          "exchange": "task-group-sealed",
          "name": "taskGroupSealed",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` for the task-group this message concerns"
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` for the task-group this message concerns"
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-group-sealed.json#",
          "title": "Task Group Sealed Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-queue/v1/",
      "serviceName": "queue",
      "title": "Queue AMQP Exchanges"
    },
    "filename": "references/queue/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and tracking their state\nas they are executed by workers, in order to ensure they are eventually\nresolved.\n\n## Artifact Storage Types\n\n* **Object artifacts** contain arbitrary data, stored via the object service.\n* **Redirect artifacts**, will redirect the caller to URL when fetched\nwith a a 303 (See Other) response.  Clients will not apply any kind of\nauthentication to that URL.\n* **Link artifacts**, will be treated as if the caller requested the linked\nartifact on the same task.  Links may be chained, but cycles are forbidden.\nThe caller must have scopes for the linked artifact, or a 403 response will\nbe returned.\n* **Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `424` (Failed Dependency) response. This is mainly designed to\nensure that dependent tasks can distinguish between artifacts that were\nsuppose to be generated and artifacts for which the name is misspelled.\n* **S3 artifacts** are used for static files which will be\nstored on S3. When creating an S3 artifact the queue will return a\npre-signed URL to which you can do a `PUT` request to upload your\nartifact. Note that `PUT` request **must** specify the `content-length`\nheader and **must** give the `content-type` header the same value as in\nthe request to `createArtifact`. S3 artifacts will be deprecated soon,\nand users should prefer object artifacts instead.\n\n## Artifact immutability\n\nGenerally speaking you cannot overwrite an artifact when created.\nBut if you repeat the request with the same properties the request will\nsucceed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nThe queue defines the following *immutability special cases*:\n\n* A `reference` artifact can replace an existing `reference` artifact.\n* A `link` artifact can replace an existing `reference` artifact.\n* Any artifact's `expires` can be extended (made later, but not earlier).",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
          "method": "get",
          "name": "task",
          "output": "v1/task.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "scopes": "queue:get-task:<taskId>",
          "stability": "stable",
          "title": "Get Task Definition",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "Get task status structure from `taskId`",
          "method": "get",
          "name": "status",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/status",
          "scopes": "queue:status:<taskId>",
          "stability": "stable",
          "title": "Get task status",
          "type": "function"
        },
        {
          "args": [
            "taskGroupId"
          ],
          "category": "Tasks",
          "description": "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listTaskGroup",
          "output": "v1/list-task-group-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task-group/<taskGroupId>/list",
          "scopes": "queue:list-task-group:<taskGroupId>",
          "stability": "stable",
          "title": "List Task Group",
          "type": "function"
        },
        {
          "args": [
            "taskGroupId"
          ],
          "category": "Tasks",
          "description": "Seal task group to prevent creation of new tasks.\n\nTask group can be sealed once and is irreversible. Calling it multiple times\nwill return same result and will not update it again.",
          "method": "post",
          "name": "sealTaskGroup",
          "output": "v1/seal-task-group-response.json#",
          "query": [
          ],
          "route": "/task-group/<taskGroupId>/seal",
          "scopes": {
            "AnyOf": [
              "queue:seal-task-group:<taskGroupId>",
              {
                "AllOf": [
                  {
                    "each": "queue:seal-task-group-in-project:<projectId>",
                    "for": "projectId",
                    "in": "projectIds"
                  }
                ]
              }
            ]
          },
          "stability": "experimental",
          "title": "Seal Task Group",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDependentTasks",
          "output": "v1/list-dependent-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/dependents",
          "scopes": "queue:list-dependent-tasks:<taskId>",
          "stability": "stable",
          "title": "List Dependent Tasks",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline`**: the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**: the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice that artifacts created by a task must expire before the\ntask's expiration.\n\n**Task specific routing-keys**: using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific\nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key:\n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**: any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Scopes**: Note that the scopes required to complete this API call depend\non the content of the `scopes`, `routes`, `schedulerId`, `priority`,\n`provisionerId`, and `workerType` properties of the task definition.\n\nIf the task group was sealed, this end-point will return `409` reporting\n`RequestConflict` to indicate that it is no longer possible to add new tasks\nfor this `taskGroupId`.",
          "input": "v1/create-task-request.json#",
          "method": "put",
          "name": "createTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "scopes": {
            "AllOf": [
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              },
              {
                "each": "queue:route:<route>",
                "for": "route",
                "in": "routes"
              },
              "queue:create-task:project:<projectId>",
              "queue:scheduler-id:<schedulerId>",
              {
                "AnyOf": [
                  {
                    "each": "queue:create-task:<priority>:<provisionerId>/<workerType>",
                    "for": "priority",
                    "in": "priorities"
                  }
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Create New Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
          "method": "post",
          "name": "scheduleTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/schedule",
          "scopes": {
            "AnyOf": [
              "queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",
              "queue:schedule-task-in-project:<projectId>",
              {
                "AllOf": [
                  "queue:schedule-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Schedule Defined Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed. It will schedule a task that is _unscheduled_\nregardless of the state of its dependencies.\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent: if it is invoked for a task that\nis `pending` or `running`, it will just return the current task status.",
          "method": "post",
          "name": "rerunTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/rerun",
          "scopes": {
            "AnyOf": [
              "queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>",
              "queue:rerun-task-in-project:<projectId>",
              {
                "AllOf": [
                  "queue:rerun-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Rerun a Resolved Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Tasks",
          "description": "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
          "method": "post",
          "name": "cancelTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/cancel",
          "scopes": {
            "AnyOf": [
              "queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>",
              "queue:cancel-task-in-project:<projectId>",
              {
                "AllOf": [
                  "queue:cancel-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Cancel Task",
          "type": "function"
        },
        {
          "args": [
            "taskQueueId"
          ],
          "category": "Worker Interface",
          "description": "Claim pending task(s) for the given task queue.\n\nIf any work is available (even if fewer than the requested number of\ntasks, this will return immediately. Otherwise, it will block for tens of\nseconds waiting for work.  If no work appears, it will return an emtpy\nlist of tasks.  Callers should sleep a short while (to avoid denial of\nservice in an error condition) and call the endpoint again.  This is a\nsimple implementation of \"long polling\".",
          "input": "v1/claim-work-request.json#",
          "method": "post",
          "name": "claimWork",
          "output": "v1/claim-work-response.json#",
          "query": [
          ],
          "route": "/claim-work/<taskQueueId>",
          "scopes": {
            "AllOf": [
              "queue:claim-work:<taskQueueId>",
              "queue:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "stable",
          "title": "Claim Work",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Worker Interface",
          "description": "claim a task - never documented",
          "input": "v1/task-claim-request.json#",
          "method": "post",
          "name": "claimTask",
          "output": "v1/task-claim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/claim",
          "scopes": {
            "AllOf": [
              "queue:claim-task:<provisionerId>/<workerType>",
              "queue:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "deprecated",
          "title": "Claim Task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Worker Interface",
          "description": "Refresh the claim for a specific `runId` for given `taskId`. This updates\nthe `takenUntil` property and returns a new set of temporary credentials\nfor performing requests on behalf of the task. These credentials should\nbe used in-place of the credentials returned by `claimWork`.\n\nThe `reclaimTask` requests serves to:\n * Postpone `takenUntil` preventing the queue from resolving\n   `claim-expired`,\n * Refresh temporary credentials used for processing the task, and\n * Abort execution if the task/run have been resolved.\n\nIf the `takenUntil` timestamp is exceeded the queue will resolve the run\nas _exception_ with reason `claim-expired`, and proceeded to retry to the\ntask. This ensures that tasks are retried, even if workers disappear\nwithout warning.\n\nIf the task is resolved, this end-point will return `409` reporting\n`RequestConflict`. This typically happens if the task have been canceled\nor the `task.deadline` have been exceeded. If reclaiming fails, workers\nshould abort the task and forget about the given `runId`. There is no\nneed to resolve the run or upload artifacts.",
          "method": "post",
          "name": "reclaimTask",
          "output": "v1/task-reclaim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/reclaim",
          "scopes": "queue:reclaim-task:<taskId>/<runId>",
          "stability": "stable",
          "title": "Reclaim task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Worker Interface",
          "description": "Report a task completed, resolving the run as `completed`.",
          "method": "post",
          "name": "reportCompleted",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/completed",
          "scopes": "queue:resolve-task:<taskId>/<runId>",
          "stability": "stable",
          "title": "Report Run Completed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Worker Interface",
          "description": "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
          "method": "post",
          "name": "reportFailed",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/failed",
          "scopes": "queue:resolve-task:<taskId>/<runId>",
          "stability": "stable",
          "title": "Report Run Failed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Worker Interface",
          "description": "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
          "input": "v1/task-exception-request.json#",
          "method": "post",
          "name": "reportException",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/exception",
          "scopes": "queue:resolve-task:<taskId>/<runId>",
          "stability": "stable",
          "title": "Report Task Exception",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Artifacts",
          "description": "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they expire. The queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This feature makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.",
          "input": "v1/post-artifact-request.json#",
          "method": "post",
          "name": "createArtifact",
          "output": "v1/post-artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": "queue:create-artifact:<taskId>/<runId>",
          "stability": "stable",
          "title": "Create Artifact",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Artifacts",
          "description": "This endpoint marks an artifact as present for the given task, and\nshould be called when the artifact data is fully uploaded.\n\nThe storage types `reference`, `link`, and `error` do not need to\nbe finished, as they are finished immediately by `createArtifact`.\nThe storage type `s3` does not support this functionality and cannot\nbe finished.  In all such cases, calling this method is an input error\n(400).",
          "input": "v1/finish-artifact-request.json#",
          "method": "put",
          "name": "finishArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": "queue:create-artifact:<taskId>/<runId>",
          "stability": "stable",
          "title": "Finish Artifact",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Get artifact by `<name>` from a specific run.\n\n**Artifact Access**, in order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nTo allow access to fetch artifacts with a client like `curl` or a web\nbrowser, without using Taskcluster credentials, include a scope in the\n`anonymous` role.  The convention is to include\n`queue:get-artifact:public/*`.\n\n**Response**: the HTTP response to this method is a 303 redirect to the\nURL from which the artifact can be downloaded.  The body of that response\ncontains the data described in the output schema, contianing the same URL.\nCallers are encouraged to use whichever method of gathering the URL is\nmost convenient.  Standard HTTP clients will follow the redirect, while\nAPI client libraries will return the JSON body.\n\nIn order to download an artifact the following must be done:\n\n1. Obtain queue url.  Building a signed url with a taskcluster client is\nrecommended\n1. Make a GET request which does not follow redirects\n1. In all cases, if specified, the\nx-taskcluster-location-{content,transfer}-{sha256,length} values must be\nvalidated to be equal to the Content-Length and Sha256 checksum of the\nfinal artifact downloaded. as well as any intermediate redirects\n1. If this response is a 500-series error, retry using an exponential\nbackoff.  No more than 5 retries should be attempted\n1. If this response is a 400-series error, treat it appropriately for\nyour context.  This might be an error in responding to this request or\nan Error storage type body.  This request should not be retried.\n1. If this response is a 200-series response, the response body is the artifact.\nIf the x-taskcluster-location-{content,transfer}-{sha256,length} and\nx-taskcluster-location-content-encoding are specified, they should match\nthis response body\n1. If the response type is a 300-series redirect, the artifact will be at the\nlocation specified by the `Location` header.  There are multiple artifact storage\ntypes which use a 300-series redirect.\n1. For all redirects followed, the user must verify that the content-sha256, content-length,\ntransfer-sha256, transfer-length and content-encoding match every further request.  The final\nartifact must also be validated against the values specified in the original queue response\n1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`\nmust not occur\n\n**Headers**\nThe following important headers are set on the response to this method:\n\n* location: the url of the artifact if a redirect is to be performed\n* x-taskcluster-artifact-storage-type: the storage type.  Example: s3",
          "method": "get",
          "name": "getArtifact",
          "output": "v1/get-artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:get-artifact:<name>",
                "for": "name",
                "in": "names"
              }
            ]
          },
          "stability": "stable",
          "title": "Get Artifact Data from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Get artifact by `<name>` from the last run of a task.\n\n**Artifact Access**, in order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nTo allow access to fetch artifacts with a client like `curl` or a web\nbrowser, without using Taskcluster credentials, include a scope in the\n`anonymous` role.  The convention is to include\n`queue:get-artifact:public/*`.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
          "method": "get",
          "name": "getLatestArtifact",
          "output": "v1/get-artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/artifacts/<name>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:get-artifact:<name>",
                "for": "name",
                "in": "names"
              }
            ]
          },
          "stability": "stable",
          "title": "Get Artifact Data from Latest Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Artifacts",
          "description": "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts",
          "scopes": "queue:list-artifacts:<taskId>:<runId>",
          "stability": "stable",
          "title": "Get Artifacts from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Artifacts",
          "description": "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listLatestArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/artifacts",
          "scopes": "queue:list-artifacts:<taskId>",
          "stability": "stable",
          "title": "Get Artifacts from Latest Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Returns associated metadata for a given artifact, in the given task run.\nThe metadata is the same as that returned from `listArtifacts`, and does\nnot grant access to the artifact data.\n\nNote that this method does *not* automatically follow link artifacts.",
          "method": "get",
          "name": "artifactInfo",
          "output": "v1/artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifact-info/<name>",
          "scopes": "queue:list-artifacts:<taskId>:<runId>",
          "stability": "stable",
          "title": "Get Artifact Information From Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Returns associated metadata for a given artifact, in the latest run of the\ntask.  The metadata is the same as that returned from `listArtifacts`,\nand does not grant access to the artifact data.\n\nNote that this method does *not* automatically follow link artifacts.",
          "method": "get",
          "name": "latestArtifactInfo",
          "output": "v1/artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/artifact-info/<name>",
          "scopes": "queue:list-artifacts:<taskId>",
          "stability": "stable",
          "title": "Get Artifact Information From Latest Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Returns information about the content of the artifact, in the given task run.\n\nDepending on the storage type, the endpoint returns the content of the artifact\nor enough information to access that content.\n\nThis method follows link artifacts, so it will not return content\nfor a link artifact.",
          "method": "get",
          "name": "artifact",
          "output": "v1/artifact-content-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifact-content/<name>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:get-artifact:<name>",
                "for": "name",
                "in": "names"
              }
            ]
          },
          "stability": "stable",
          "title": "Get Artifact Content From Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "name"
          ],
          "category": "Artifacts",
          "description": "Returns information about the content of the artifact, in the latest task run.\n\nDepending on the storage type, the endpoint returns the content of the artifact\nor enough information to access that content.\n\nThis method follows link artifacts, so it will not return content\nfor a link artifact.",
          "method": "get",
          "name": "latestArtifact",
          "output": "v1/artifact-content-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/artifact-content/<name>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:get-artifact:<name>",
                "for": "name",
                "in": "names"
              }
            ]
          },
          "stability": "stable",
          "title": "Get Artifact Content From Latest Run",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Metadata",
          "description": "Get all active provisioners.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 provisioners in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listProvisioners",
          "output": "v1/list-provisioners-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners",
          "scopes": "queue:list-provisioners",
          "stability": "deprecated",
          "title": "Get a list of all active provisioners",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Worker Metadata",
          "description": "Get an active provisioner.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "method": "get",
          "name": "getProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "scopes": "queue:get-provisioner:<provisionerId>",
          "stability": "deprecated",
          "title": "Get an active provisioner",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Worker Metadata",
          "description": "Declare a provisioner, supplying some details about it.\n\n`declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are\npossessed. For example, a request to update the `my-provisioner`\nprovisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope\n`queue:declare-provisioner:my-provisioner#description`.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "input": "v1/update-provisioner-request.json#",
          "method": "put",
          "name": "declareProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-provisioner:<provisionerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "deprecated",
          "title": "Update a provisioner",
          "type": "function"
        },
        {
          "args": [
            "taskQueueId"
          ],
          "category": "Worker Metadata",
          "description": "Get an approximate number of pending tasks for the given `taskQueueId`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
          "method": "get",
          "name": "pendingTasks",
          "output": "v1/pending-tasks-response.json#",
          "query": [
          ],
          "route": "/pending/<taskQueueId>",
          "scopes": "queue:pending-count:<taskQueueId>",
          "stability": "stable",
          "title": "Get Number of Pending Tasks",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Worker Metadata",
          "description": "Get all active worker-types for the given provisioner.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 worker-types in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkerTypes",
          "output": "v1/list-workertypes-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners/<provisionerId>/worker-types",
          "scopes": "queue:list-worker-types:<provisionerId>",
          "stability": "deprecated",
          "title": "Get a list of all active worker-types",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Worker Metadata",
          "description": "Get a worker-type from a provisioner.",
          "method": "get",
          "name": "getWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "scopes": "queue:get-worker-type:<provisionerId>/<workerType>",
          "stability": "deprecated",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Worker Metadata",
          "description": "Declare a workerType, supplying some details about it.\n\n`declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are\npossessed. For example, a request to update the `highmem` worker-type within the `my-provisioner`\nprovisioner with a body `{description: 'This worker type is great'}` would require you to have the scope\n`queue:declare-worker-type:my-provisioner/highmem#description`.",
          "input": "v1/update-workertype-request.json#",
          "method": "put",
          "name": "declareWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker-type:<provisionerId>/<workerType>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "deprecated",
          "title": "Update a worker-type",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Metadata",
          "description": "Get all active task queues.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 task queues in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listTaskQueues",
          "output": "v1/list-taskqueues-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task-queues",
          "scopes": "queue:list-task-queues",
          "stability": "stable",
          "title": "Get a list of all active task queues",
          "type": "function"
        },
        {
          "args": [
            "taskQueueId"
          ],
          "category": "Worker Metadata",
          "description": "Get a task queue.",
          "method": "get",
          "name": "getTaskQueue",
          "output": "v1/taskqueue-response.json#",
          "query": [
          ],
          "route": "/task-queues/<taskQueueId>",
          "scopes": "queue:get-task-queue:<taskQueueId>",
          "stability": "stable",
          "title": "Get a task queue",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Worker Metadata",
          "description": "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers.\nTo filter the query, you should call the end-point with `quarantined` as a query-string option with a\ntrue or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkers",
          "output": "v1/list-workers-response.json#",
          "query": [
            "continuationToken",
            "limit",
            "quarantined"
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
          "scopes": "queue:list-workers:<provisionerId>/<workerType>",
          "stability": "deprecated",
          "title": "Get a list of all active workers of a workerType",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Metadata",
          "description": "Get a worker from a worker-type.",
          "method": "get",
          "name": "getWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "scopes": "queue:get-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>",
          "stability": "deprecated",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Metadata",
          "description": "Quarantine a worker",
          "input": "v1/quarantine-worker-request.json#",
          "method": "put",
          "name": "quarantineWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              "queue:quarantine-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>"
            ]
          },
          "stability": "experimental",
          "title": "Quarantine a worker",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Metadata",
          "description": "Declare a worker, supplying some details about it.\n\n`declareWorker` allows updating one or more properties of a worker as long as the required scopes are\npossessed.",
          "input": "v1/update-worker-request.json#",
          "method": "put",
          "name": "declareWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Declare a worker",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "queue",
      "title": "Queue Service"
    },
    "filename": "references/queue/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "purge-cache",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/purge-cache/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The purge-cache service is responsible for tracking cache-purge requests.\n\nUser create purge requests for specific caches on specific workers, and\nthese requests are timestamped.  Workers consult the service before\nstarting a new task, and purge any caches older than the timestamp.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Purge-Cache Service",
          "description": "Publish a request to purge caches named `cacheName` with\non `workerPoolId` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
          "input": "v1/purge-cache-request.json#",
          "method": "post",
          "name": "purgeCache",
          "query": [
          ],
          "route": "/purge-cache/<workerPoolId>",
          "scopes": "purge-cache:<workerPoolId>:<cacheName>",
          "stability": "stable",
          "title": "Purge Worker Cache",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Purge-Cache Service",
          "description": "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
          "method": "get",
          "name": "allPurgeRequests",
          "output": "v1/all-purge-cache-request-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/purge-cache/list",
          "scopes": "purge-cache:all-purge-requests",
          "stability": "stable",
          "title": "All Open Purge Requests",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Purge-Cache Service",
          "description": "List the caches for this `workerPoolId` that should to be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
          "method": "get",
          "name": "purgeRequests",
          "output": "v1/purge-cache-request-list.json#",
          "query": [
            "since"
          ],
          "route": "/purge-cache/<workerPoolId>",
          "scopes": "purge-cache:purge-requests::<workerPoolId>",
          "stability": "stable",
          "title": "Open Purge Requests for a worker pool",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "purge-cache",
      "title": "Purge Cache Service"
    },
    "filename": "references/purge-cache/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "object",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/object/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The object service provides HTTP-accessible storage for large blobs of data.\n\nObjects can be uploaded and downloaded, with the object data flowing directly\nfrom the storage \"backend\" to the caller, and not directly via this service.\nOnce uploaded, objects are immutable until their expiration time.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Upload",
          "description": "Create a new object by initiating upload of its data.\n\nThis endpoint implements negotiation of upload methods.  It can be called\nmultiple times if necessary, either to propose new upload methods or to\nrenew credentials for an already-agreed upload.\n\nThe `name` parameter can contain any printable ASCII character (0x20 - 0x7e).\nThe `uploadId` must be supplied by the caller, and any attempts to upload\nan object with the same name but a different `uploadId` will fail.\nThus the first call to this method establishes the `uploadId` for the\nobject, and as long as that value is kept secret, no other caller can\nupload an object of that name, regardless of scopes.  Object expiration\ncannot be changed after the initial call, either.  It is possible to call\nthis method with no proposed upload methods, which has the effect of \"locking\nin\" the `expiration`, `projectId`, and `uploadId` properties and any\nsupplied hashes.\n\nUnfinished uploads expire after 1 day.",
          "input": "v1/create-upload-request.json#",
          "method": "put",
          "name": "createUpload",
          "output": "v1/create-upload-response.json#",
          "query": [
          ],
          "route": "/upload/<name>",
          "scopes": "object:upload:<projectId>:<name>",
          "stability": "stable",
          "title": "Begin upload of a new object",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Upload",
          "description": "This endpoint marks an upload as complete.  This indicates that all data has been\ntransmitted to the backend.  After this call, no further calls to `uploadObject` are\nallowed, and downloads of the object may begin.  This method is idempotent, but will\nfail if given an incorrect uploadId for an unfinished upload.\n\nIt is possible to finish an upload with no hashes specified via either\n`startUpload` or `finishUpload`.  However, many clients will refuse to\ndownload an object with no hashes.  The utility methods included with the\nclient libraries always include hashes as of version 44.0.0.\n\nNote that, once `finishUpload` is complete, the object is considered immutable.",
          "input": "v1/finish-upload-request.json#",
          "method": "post",
          "name": "finishUpload",
          "query": [
          ],
          "route": "/finish-upload/<name>",
          "scopes": "object:upload:<projectId>:<name>",
          "stability": "stable",
          "title": "Mark an upload as complete.",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Download",
          "description": "Start the process of downloading an object's data.  Call this endpoint with a list of acceptable\ndownload methods, and the server will select a method and return the corresponding payload.\n\nReturns a 406 error if none of the given download methods are available.\n\nSee [Download Methods](https://docs.taskcluster.net/docs/reference/platform/object/download-methods) for more detail.",
          "input": "v1/download-object-request.json#",
          "method": "put",
          "name": "startDownload",
          "output": "v1/download-object-response.json#",
          "query": [
          ],
          "route": "/start-download/<name>",
          "scopes": "object:download:<name>",
          "stability": "stable",
          "title": "Download object data",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Objects",
          "description": "Get the metadata for the named object.  This metadata is not sufficient to\nget the object's content; for that use `startDownload`.",
          "method": "get",
          "name": "object",
          "output": "v1/get-object-response.json#",
          "query": [
          ],
          "route": "/metadata/<name>",
          "scopes": "object:download:<name>",
          "stability": "stable",
          "title": "Get an object's metadata",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Download",
          "description": "Get the data in an object directly.  This method does not return a JSON body, but\nredirects to a location that will serve the object content directly.\n\nURLs for this endpoint, perhaps with attached authentication (`?bewit=..`),\nare typically used for downloads of objects by simple HTTP clients such as\nweb browsers, curl, or wget.\n\nThis method is limited by the common capabilities of HTTP, so it may not be\nthe most efficient, resilient, or featureful way to retrieve an artifact.\nSituations where such functionality is required should ues the\n`startDownload` API endpoint.\n\nSee [Simple Downloads](https://docs.taskcluster.net/docs/reference/platform/object/simple-downloads) for more detail.",
          "method": "get",
          "name": "download",
          "query": [
          ],
          "route": "/download/<name>",
          "scopes": "object:download:<name>",
          "stability": "stable",
          "title": "Get an object's data",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "object",
      "title": "Object Service"
    },
    "filename": "references/object/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "notify",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "Email has been sent.",
          "fields": {
            "address": "The requested recepient of the email."
          },
          "level": "info",
          "name": "email",
          "title": "Email Sent",
          "type": "email",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A matrix message has been sent.",
          "fields": {
            "dest": "A user or room."
          },
          "level": "info",
          "name": "matrix",
          "title": "Matrix Message Sent",
          "type": "matrix",
          "version": 1
        },
        {
          "description": "We have been rejected from messaging a room. This is expected if the user\nhas not invited our client into the room yet but we log it as a notice to\nhelp debug confused users.",
          "fields": {
            "roomId": "The roomId that we were forbidden from."
          },
          "level": "notice",
          "name": "matrixForbidden",
          "title": "Matrix Forbidden",
          "type": "matrix-forbidden",
          "version": 1
        },
        {
          "description": "Log events from the matrix sdk. Contains arbitrary data from them.",
          "fields": {
            "level": "The level that matrix logged this at. We send all logs to debug no matter what.",
            "message": "Arbitrary message from matrix sdk."
          },
          "level": "debug",
          "name": "matrixSdkDebug",
          "title": "Matrix SDK Debug",
          "type": "matrix-sdk-debug",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A pulse event has been published.",
          "fields": {
            "routingKey": "The requested routingKey of the message."
          },
          "level": "info",
          "name": "pulse",
          "title": "Pulse Event Published",
          "type": "pulse",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A Slack message has been sent.",
          "fields": {
            "channelId": "The unique Slack channel ID."
          },
          "level": "info",
          "name": "slack",
          "title": "Slack Message Sent",
          "type": "slack",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/notify/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This pretty much only contains the simple free-form\nmessage that can be published from this service from a request\nby anybody with the proper scopes.",
      "entries": [
        {
          "description": "An arbitrary message that a taskcluster user\ncan trigger if they like.\n\nThe standard one that is published by us watching\nfor the completion of tasks is just the task status\ndata that we pull from the queue `status()` endpoint\nwhen we notice a task is complete.",
          "exchange": "notification",
          "name": "notify",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/notification-message.json#",
          "title": "Notification Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-notify/v1/",
      "serviceName": "notify",
      "title": "Notify AMQP Exchanges"
    },
    "filename": "references/notify/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The notification service listens for tasks with associated notifications\nand handles requests to send emails and post pulse messages.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notifications",
          "description": "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
          "input": "v1/email-request.json#",
          "method": "post",
          "name": "email",
          "query": [
          ],
          "route": "/email",
          "scopes": "notify:email:<address>",
          "stability": "experimental",
          "title": "Send an Email",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notifications",
          "description": "Publish a message on pulse with the given `routingKey`.",
          "input": "v1/pulse-request.json#",
          "method": "post",
          "name": "pulse",
          "query": [
          ],
          "route": "/pulse",
          "scopes": "notify:pulse:<routingKey>",
          "stability": "experimental",
          "title": "Publish a Pulse Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notifications",
          "description": "Post a message to a room in Matrix. Optionally includes formatted message.\n\nThe `roomId` in the scopes is a fully formed `roomId` with leading `!` such\nas `!foo:bar.com`.\n\nNote that the matrix client used by taskcluster must be invited to a room before\nit can post there!",
          "input": "v1/matrix-request.json#",
          "method": "post",
          "name": "matrix",
          "query": [
          ],
          "route": "/matrix",
          "scopes": "notify:matrix-room:<roomId>",
          "stability": "experimental",
          "title": "Post Matrix Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notifications",
          "description": "Post a message to a Slack channel.\n\nThe `channelId` in the scopes is a Slack channel ID, starting with a capital C.\n\nThe Slack app can post into public channels by default but will need to be added\nto private channels before it can post messages there.",
          "input": "v1/slack-request.json#",
          "method": "post",
          "name": "slack",
          "query": [
          ],
          "route": "/slack",
          "scopes": "notify:slack-channel:<channelId>",
          "stability": "experimental",
          "title": "Post Slack Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Denylist",
          "description": "Add the given address to the notification denylist. Addresses in the denylist will be ignored\nby the notification service.",
          "input": "v1/notification-address.json#",
          "method": "post",
          "name": "addDenylistAddress",
          "query": [
          ],
          "route": "/denylist/add",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Denylist Given Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Denylist",
          "description": "Delete the specified address from the notification denylist.",
          "input": "v1/notification-address.json#",
          "method": "delete",
          "name": "deleteDenylistAddress",
          "query": [
          ],
          "route": "/denylist/delete",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Delete Denylisted Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Denylist",
          "description": "Lists all the denylisted addresses.\n\nBy default this end-point will try to return up to 1000 addresses in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `list` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDenylist",
          "output": "v1/notification-address-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/denylist/list",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "List Denylisted Notifications",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "notify",
      "title": "Notification Service"
    },
    "filename": "references/notify/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/manifest-v3.json#",
      "references": [
        "/references/auth/v1/api.json",
        "/references/auth/v1/exchanges.json",
        "/references/auth/v1/logs.json",
        "/references/built-in-workers/v1/logs.json",
        "/references/github/v1/api.json",
        "/references/github/v1/exchanges.json",
        "/references/github/v1/logs.json",
        "/references/hooks/v1/api.json",
        "/references/hooks/v1/exchanges.json",
        "/references/hooks/v1/logs.json",
        "/references/index/v1/api.json",
        "/references/index/v1/logs.json",
        "/references/notify/v1/api.json",
        "/references/notify/v1/exchanges.json",
        "/references/notify/v1/logs.json",
        "/references/object/v1/api.json",
        "/references/object/v1/logs.json",
        "/references/purge-cache/v1/api.json",
        "/references/purge-cache/v1/logs.json",
        "/references/queue/v1/api.json",
        "/references/queue/v1/exchanges.json",
        "/references/queue/v1/logs.json",
        "/references/secrets/v1/api.json",
        "/references/secrets/v1/logs.json",
        "/references/web-server/v1/logs.json",
        "/references/worker-manager/v1/api.json",
        "/references/worker-manager/v1/exchanges.json",
        "/references/worker-manager/v1/logs.json"
      ]
    },
    "filename": "references/manifest.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "index",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/index/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The index service is responsible for indexing tasks. The service ensures that\ntasks can be located by user-defined names.\n\nAs described in the service documentation, tasks are typically indexed via Pulse\nmessages, so the most common use of API methods is to read from the index.\n\nSlashes (`/`) aren't allowed in index paths.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
            "indexPath"
          ],
          "category": "Index Service",
          "description": "Find a task by index path, returning the highest-rank task with that path. If no\ntask exists for the given path, this API end-point will respond with a 404 status.",
          "method": "get",
          "name": "findTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<indexPath>",
          "scopes": "index:find-task:<indexPath>",
          "stability": "stable",
          "title": "Find Indexed Task",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "List the namespaces immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 namespaces. If more namespaces are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.",
          "method": "get",
          "name": "listNamespaces",
          "output": "v1/list-namespaces-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/namespaces/<namespace>",
          "scopes": "index:list-namespaces:<namespace>",
          "stability": "stable",
          "title": "List Namespaces",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "List the tasks immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 tasks. If more tasks are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
          "method": "get",
          "name": "listTasks",
          "output": "v1/list-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/tasks/<namespace>",
          "scopes": "index:list-tasks:<namespace>",
          "stability": "stable",
          "title": "List Tasks",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "Insert a task into the index.  If the new rank is less than the existing rank\nat the given index path, the task is not indexed but the response is still 200 OK.\n\nPlease see the introduction above for information\nabout indexing successfully completed tasks automatically using custom routes.",
          "input": "v1/insert-task-request.json#",
          "method": "put",
          "name": "insertTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<namespace>",
          "scopes": "index:insert-task:<namespace>",
          "stability": "stable",
          "title": "Insert Task into Index",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "Remove a task from the index.  This is intended for administrative use,\nwhere an index entry is no longer appropriate.  The parent namespace is\nnot automatically deleted.  Index entries with lower rank that were\npreviously inserted will not re-appear, as they were never stored.",
          "method": "delete",
          "name": "deleteTask",
          "query": [
          ],
          "route": "/task/<namespace>",
          "scopes": "index:delete-task:<namespace>",
          "stability": "stable",
          "title": "Remove Task from Index",
          "type": "function"
        },
        {
          "args": [
            "indexPath",
            "name"
          ],
          "category": "Index Service",
          "description": "Find a task by index path and redirect to the artifact on the most recent\nrun with the given `name`.\n\nNote that multiple calls to this endpoint may return artifacts from differen tasks\nif a new task is inserted into the index between calls. Avoid using this method as\na stable link to multiple, connected files if the index path does not contain a\nunique identifier.  For example, the following two links may return unrelated files:\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/installer.exe`\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/debug-symbols.zip`\n\nThis problem be remedied by including the revision in the index path or by bundling both\ninstaller and debug symbols into a single artifact.\n\nIf no task exists for the given index path, this API end-point responds with 404.",
          "method": "get",
          "name": "findArtifactFromTask",
          "query": [
          ],
          "route": "/task/<indexPath>/artifacts/<name>",
          "scopes": "queue:get-artifact:<name>",
          "stability": "stable",
          "title": "Get Artifact From Indexed Task",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "index",
      "title": "Index Service"
    },
    "filename": "references/index/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "hooks",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A hook was fired, meaning that a task was created for it.  This is also\nlogged when the attempt to fire the hook failed, in which case the 'result'\nfield is \"failed\".  Since this is often the result of user error, the error\nmessage itself is not included; consult the last-fires for the indicated\nhook to see them.",
          "fields": {
            "firedBy": "The event leading to the hook being fired",
            "hookGroupId": "The group ID of the hook that failed",
            "hookId": "The ID of the hook that failed",
            "result": "\"success\" (task created), \"failure\" (task not created), or \"declined\" (hook did not generate a task)\"",
            "taskId": "The taskId of the task that was (or would have been) created"
          },
          "level": "info",
          "name": "hookFire",
          "title": "A hook was fired",
          "type": "hook-fire",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/hooks/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service is responsible for creating tasks at specific times orin .  response to webhooks and API calls.Using this exchange allows us tomake hooks which repsond to particular pulse messagesThese exchanges provide notifications when a hook is created, updatedor deleted. This is so that the listener running in a different hooks process at the other end can direct another listener specified by`hookGroupId` and `hookId` to synchronize its bindings. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create apulse based hook, a message is posted to this exchange andthe receiver creates a listener with the bindings, to create a task",
          "exchange": "hook-created",
          "name": "hookCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update apulse based hook, a message is posted to this exchange andthe receiver updates the listener associated with that hook.",
          "exchange": "hook-updated",
          "name": "hookUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to delete apulse based hook, a message is posted to this exchange andthe receiver deletes the listener associated with that hook.",
          "exchange": "hook-deleted",
          "name": "hookDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-hooks/v1/",
      "serviceName": "hooks",
      "title": "Exchanges to manage hooks"
    },
    "filename": "references/hooks/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service provides a mechanism for creating tasks in response to events.\n",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Hooks",
          "description": "This endpoint will return a list of all hook groups with at least one hook.",
          "method": "get",
          "name": "listHookGroups",
          "output": "v1/list-hook-groups-response.json#",
          "query": [
          ],
          "route": "/hooks",
          "scopes": "hooks:list-hooks:",
          "stability": "stable",
          "title": "List hook groups",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId"
          ],
          "category": "Hooks",
          "description": "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
          "method": "get",
          "name": "listHooks",
          "output": "v1/list-hooks-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>",
          "scopes": "hooks:list-hooks:<hookGroupId>",
          "stability": "stable",
          "title": "List hooks in a given group",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
          "method": "get",
          "name": "hook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": "hooks:get:<hookGroupId>:<hookId>",
          "stability": "stable",
          "title": "Get hook definition",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hook Status",
          "description": "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.\n\nThis method is deprecated in favor of listLastFires.",
          "method": "get",
          "name": "getHookStatus",
          "output": "v1/hook-status.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/status",
          "scopes": "hooks:status:<hookGroupId>/<hookId>",
          "stability": "deprecated",
          "title": "Get hook status",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.",
          "input": "v1/create-hook-request.json#",
          "method": "put",
          "name": "createHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Create a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
          "input": "v1/create-hook-request.json#",
          "method": "post",
          "name": "updateHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Update a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "This endpoint will remove a hook definition.",
          "method": "delete",
          "name": "removeHook",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": "hooks:modify-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Delete a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "This endpoint will trigger the creation of a task from a hook definition.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHook",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger",
          "scopes": "hooks:trigger-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Trigger a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
          "method": "get",
          "name": "getTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:get-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks",
          "description": "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
          "method": "post",
          "name": "resetTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:reset-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Reset a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId",
            "token"
          ],
          "category": "Hooks",
          "description": "This endpoint triggers a defined hook with a valid token.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHookWithToken",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
          "stability": "stable",
          "title": "Trigger a hook with a token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hook Status",
          "description": "This endpoint will return information about the the last few times this hook has been\nfired, including whether the hook was fired successfully or not\n\nBy default this endpoint will return up to 1000 most recent fires in one request.",
          "method": "get",
          "name": "listLastFires",
          "output": "v1/list-lastFires-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/last-fires",
          "scopes": "hooks:list-last-fires:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get information about recent hook fires",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "hooks",
      "title": "Hooks Service"
    },
    "filename": "references/hooks/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "github",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "This message logs the number of running and errored handlers periodically.",
          "fields": {
            "errorCount": "The number of handlers that finished with errors",
            "handlerName": "The name of handler",
            "runningCount": "The number of handles that are still running",
            "totalCount": "The total number of events handled"
          },
          "level": "notice",
          "name": "githubActiveHandlers",
          "title": "Github active handler count",
          "type": "github-handler-count",
          "version": 1
        },
        {
          "description": "Narrative debug logging for event handling.  These messages have attributes that\ncan be useful in filtering to a specific event, but note that all fields are not\nalways available.  For example, when a task completes, the eventId that led to\nthe task's creation is not available and not logged.",
          "fields": {
            "eventId": "The GUID of the webhook delivery (`X-GitHub-Delivery` header), if any",
            "installationId": "The installation ID associated with this event (`installation.id`), if any",
            "message": "Free-form message",
            "owner": "The repository owner (organization or username), if any",
            "repo": "The repository name, if any",
            "sha": "The SHA of the commit being addressed, if any",
            "taskGroupId": "The taskGroupId of the affected tasks, if any",
            "taskId": "The taskId of the affected task, if any"
          },
          "level": "debug",
          "name": "handlerDebug",
          "title": "Event Handler Debug Information",
          "type": "handler-debug",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "A valid webhook payload was received from GitHub.",
          "fields": {
            "eventId": "The GUID of this webhook delivery (`X-GitHub-Delivery` header)",
            "eventType": "The event type (`X-GitHub-Event` header)",
            "installationId": "The installation ID associated with this event (`installation.id`), if any"
          },
          "level": "notice",
          "name": "webhookReceived",
          "title": "Webhook Received",
          "type": "webhook-received",
          "version": 1
        }
      ]
    },
    "filename": "references/github/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service publishes a pulse\nmessage for supported github events, translating Github webhook\nevents into pulse messages.\n\nThis document describes the exchange offered by the taskcluster\ngithub service",
      "entries": [
        {
          "description": "When a GitHub pull request event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "pull-request",
          "name": "pullRequest",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "action",
              "required": true,
              "summary": "The GitHub `action` which triggered an event. See for possible values see the payload actions property."
            }
          ],
          "schema": "v1/github-pull-request-message.json#",
          "title": "GitHub Pull Request Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub push event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "push",
          "name": "push",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-push-message.json#",
          "title": "GitHub push Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub release event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "release",
          "name": "release",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-release-message.json#",
          "title": "GitHub release Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub check_run event with action=\"rerequested\" is posted \nit will be broadcast on this exchange with the designated \n`organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "rerun",
          "name": "rerun",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-rerun-message.json#",
          "title": "GitHub re-run task Event",
          "type": "topic-exchange"
        },
        {
          "description": "supposed to signal that taskCreate API has been called for every task in the task group\nfor this particular repo and this particular organization\ncurrently used for creating initial status indicators in GitHub UI using Statuses API.\nThis particular exchange can also be bound to RabbitMQ queues by custom routes - for that,\nPass in the array of routes as a second argument to the publish method. Currently, we do\nuse the statuses routes to bind the handler that creates the initial status.",
          "exchange": "task-group-creation-requested",
          "name": "taskGroupCreationRequested",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/task-group-creation-requested.json#",
          "title": "tc-gh requested the Queue service to create all the tasks in a group",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-github/v1/",
      "serviceName": "github",
      "title": "Taskcluster-Github Exchanges"
    },
    "filename": "references/github/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service is responsible for creating tasks in response\nto GitHub events, and posting results to the GitHub UI.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks, as well as some useful consumer APIs.\n\nWhen Github forbids an action, this service returns an HTTP 403\nwith code ForbiddenByGithub.",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Github Service",
          "description": "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease, check run or pull request.",
          "method": "post",
          "name": "githubWebHookConsumer",
          "query": [
          ],
          "route": "/github",
          "stability": "stable",
          "title": "Consume GitHub WebHook",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Github Service",
          "description": "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
          "method": "get",
          "name": "builds",
          "output": "v1/build-list.json#",
          "query": [
            "continuationToken",
            "limit",
            "organization",
            "repository",
            "sha"
          ],
          "route": "/builds",
          "scopes": "github:list-builds",
          "stability": "stable",
          "title": "List of Builds",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "category": "Github Service",
          "description": "Checks the status of the latest build of a given branch\nand returns corresponding badge svg.",
          "method": "get",
          "name": "badge",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/badge.svg",
          "scopes": "github:get-badge:<owner>:<repo>:<branch>",
          "stability": "experimental",
          "title": "Latest Build Status Badge",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo"
          ],
          "category": "Github Service",
          "description": "Returns any repository metadata that is\nuseful within Taskcluster related services.",
          "method": "get",
          "name": "repository",
          "output": "v1/repository.json#",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>",
          "scopes": "github:get-repository:<owner>:<repo>",
          "stability": "experimental",
          "title": "Get Repository Info",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "category": "Github Service",
          "description": "For a given branch of a repository, this will always point\nto a status page for the most recent task triggered by that\nbranch.\n\nNote: This is a redirect rather than a direct link.",
          "method": "get",
          "name": "latest",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/latest",
          "scopes": "github:latest-status:<owner>:<repo>:<branch>",
          "stability": "stable",
          "title": "Latest Status for Branch",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "sha"
          ],
          "category": "Github Service",
          "description": "For a given changeset (SHA) of a repository, this will attach a \"commit status\"\non github. These statuses are links displayed next to each revision.\nThe status is either OK (green check) or FAILURE (red cross),\nmade of a custom title and link.",
          "input": "v1/create-status.json#",
          "method": "post",
          "name": "createStatus",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/statuses/<sha>",
          "scopes": "github:create-status:<owner>/<repo>",
          "stability": "experimental",
          "title": "Post a status against a given changeset",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "number"
          ],
          "category": "Github Service",
          "description": "For a given Issue or Pull Request of a repository, this will write a new message.",
          "input": "v1/create-comment.json#",
          "method": "post",
          "name": "createComment",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/issues/<number>/comments",
          "scopes": "github:create-comment:<owner>/<repo>",
          "stability": "stable",
          "title": "Post a comment on a given GitHub Issue or Pull Request",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "github",
      "title": "GitHub Service"
    },
    "filename": "references/github/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "built-in-workers",
      "types": [
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/built-in-workers/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "auth",
      "types": [
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "authenticated": "Will be `true` if the request has successfully authenticated (`auth-success` or `no-auth`) but\n`false` if req.authenticate() has not been called (for example when no scopes are required), or\nif the request has invalid credentials (`auth-failed`). It does *not* imply\nauthorization (i.e. scope satisfaction not guaranteed).",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 2
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "This message is logged for each invocation of a Postgres stored function.",
          "fields": {
            "name": "The name of the DB function"
          },
          "level": "info",
          "name": "dbFunctionCall",
          "title": "DB Method Call",
          "type": "db-function-call",
          "version": 1
        },
        {
          "description": "This message is logged every minute from each process that is using the database,\nonce for each pool.  Most services have both a \"read\" pool and a \"write\" pool.  The\nfields come from the node-postgres package.",
          "fields": {
            "idleCount": "The number of connections (out of the total) which are not currently in use",
            "pool": "The name of the pool within the process",
            "totalCount": "The total number of connections",
            "waitingCount": "The number of operations waiting for an idle connection"
          },
          "level": "notice",
          "name": "dbPoolCounts",
          "title": "DB Pool Counts",
          "type": "db-pool-counts",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        }
      ]
    },
    "filename": "references/auth/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The auth service is responsible for storing credentials, managing\nassignment of scopes, and validation of request signatures from other\nservices.\n\nThese exchanges provides notifications when credentials or roles are\nupdated. This is mostly so that multiple instances of the auth service\ncan purge their caches and synchronize state. But you are of course\nwelcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Message that a new client has been created.",
          "exchange": "client-created",
          "name": "clientCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been updated.",
          "exchange": "client-updated",
          "name": "clientUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been deleted.",
          "exchange": "client-deleted",
          "name": "clientDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Deleted Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been created.",
          "exchange": "role-created",
          "name": "roleCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been updated.",
          "exchange": "role-updated",
          "name": "roleUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been deleted.",
          "exchange": "role-deleted",
          "name": "roleDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-auth/v1/",
      "serviceName": "auth",
      "title": "Auth Pulse Exchanges"
    },
    "filename": "references/auth/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "Authentication related API end-points for Taskcluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authorize a request signed with Taskcluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n",
      "entries": [
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "lbheartbeat",
          "query": [
          ],
          "route": "/__lbheartbeat__",
          "stability": "stable",
          "title": "Load Balancer Heartbeat",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with the JSON version object.\nhttps://github.com/mozilla-services/Dockerflow/blob/main/docs/version_object.md",
          "method": "get",
          "name": "version",
          "query": [
          ],
          "route": "/__version__",
          "stability": "stable",
          "title": "Taskcluster Version",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Clients",
          "description": "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.\n\nBy default this end-point will try to return up to 1000 clients in one\nrequest. But it **may return less, even none**.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listClients` with the last `continuationToken` until you\nget a result without a `continuationToken`.",
          "method": "get",
          "name": "listClients",
          "output": "v1/list-clients-response.json#",
          "query": [
            "prefix",
            "continuationToken",
            "limit"
          ],
          "route": "/clients/",
          "scopes": "auth:list-clients",
          "stability": "stable",
          "title": "List Clients",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Get information about a single client.",
          "method": "get",
          "name": "client",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": "auth:get-client:<clientId>",
          "stability": "stable",
          "title": "Get Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
          "input": "v1/create-client-request.json#",
          "method": "put",
          "name": "createClient",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:create-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
          "method": "post",
          "name": "resetAccessToken",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/reset",
          "scopes": "auth:reset-access-token:<clientId>",
          "stability": "stable",
          "title": "Reset `accessToken`",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
          "input": "v1/create-client-request.json#",
          "method": "post",
          "name": "updateClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:update-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
          "method": "post",
          "name": "enableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/enable",
          "scopes": "auth:enable-client:<clientId>",
          "stability": "stable",
          "title": "Enable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
          "method": "post",
          "name": "disableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/disable",
          "scopes": "auth:disable-client:<clientId>",
          "stability": "stable",
          "title": "Disable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Clients",
          "description": "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
          "method": "delete",
          "name": "deleteClient",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": "auth:delete-client:<clientId>",
          "stability": "stable",
          "title": "Delete Client",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Roles",
          "description": "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This always returns all roles in a single HTTP\nrequest.\n\nTo get paginated results, use `listRoles2`.",
          "method": "get",
          "name": "listRoles",
          "output": "v1/list-roles-response.json#",
          "query": [
          ],
          "route": "/roles/",
          "scopes": "auth:list-roles",
          "stability": "stable",
          "title": "List Roles (no pagination)",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Roles",
          "description": "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This is similar to `listRoles` but differs in the\nformat of the response.\n\nIf no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoles2",
          "output": "v1/list-roles2-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roles2/",
          "scopes": "auth:list-roles",
          "stability": "stable",
          "title": "List Roles",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Roles",
          "description": "Get a list of all role IDs.\n\nIf no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoleIds",
          "output": "v1/list-role-ids-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roleids/",
          "scopes": "auth:list-roles",
          "stability": "stable",
          "title": "List Role IDs",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Roles",
          "description": "Get information about a single role, including the set of scopes that the\nrole expands to.",
          "method": "get",
          "name": "role",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": "auth:get-role:<roleId>",
          "stability": "stable",
          "title": "Get Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Roles",
          "description": "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.\n\nCreation of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "put",
          "name": "createRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:create-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Roles",
          "description": "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the role's existing scopes.\n\nAn update of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "post",
          "name": "updateRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:update-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Roles",
          "description": "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
          "method": "delete",
          "name": "deleteRole",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": "auth:delete-role:<roleId>",
          "stability": "stable",
          "title": "Delete Role",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Scopes and Auth",
          "description": "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
          "input": "v1/scopeset.json#",
          "method": "post",
          "name": "expandScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/expand",
          "scopes": "auth:expand-scopes",
          "stability": "stable",
          "title": "Expand Scopes",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Scopes and Auth",
          "description": "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
          "method": "get",
          "name": "currentScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/current",
          "scopes": "auth:current-scopes",
          "stability": "stable",
          "title": "Get Current Scopes",
          "type": "function"
        },
        {
          "args": [
            "level",
            "bucket",
            "prefix"
          ],
          "category": "AWS Credentials",
          "description": "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets, as configured\nin the Taskcluster deployment\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
          "method": "get",
          "name": "awsS3Credentials",
          "output": "v1/aws-s3-credentials-response.json#",
          "query": [
            "format"
          ],
          "route": "/aws/s3/<level>/<bucket>/<prefix>",
          "scopes": {
            "else": "auth:aws-s3:read-write:<bucket>/<prefix>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:aws-s3:read-only:<bucket>/<prefix>",
                "auth:aws-s3:read-write:<bucket>/<prefix>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Temporary Read/Write Credentials S3",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Azure Credentials",
          "description": "Retrieve a list of all Azure accounts managed by Taskcluster Auth.",
          "method": "get",
          "name": "azureAccounts",
          "output": "v1/azure-account-list-response.json#",
          "query": [
          ],
          "route": "/azure/accounts",
          "scopes": "auth:azure-table:list-accounts",
          "stability": "deprecated",
          "title": "List Accounts Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "category": "Azure Credentials",
          "description": "Retrieve a list of all tables in an account.",
          "method": "get",
          "name": "azureTables",
          "output": "v1/azure-table-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/tables",
          "scopes": "auth:azure-table:list-tables:<account>",
          "stability": "deprecated",
          "title": "List Tables in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "table",
            "level"
          ],
          "category": "Azure Credentials",
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ntable if it doesn't already exist.",
          "method": "get",
          "name": "azureTableSAS",
          "output": "v1/azure-table-access-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/table/<table>/<level>",
          "scopes": {
            "else": "auth:azure-table:read-write:<account>/<table>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-table:read-only:<account>/<table>",
                "auth:azure-table:read-write:<account>/<table>"
              ]
            }
          },
          "stability": "deprecated",
          "title": "Get Shared-Access-Signature for Azure Table",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "category": "Azure Credentials",
          "description": "Retrieve a list of all containers in an account.",
          "method": "get",
          "name": "azureContainers",
          "output": "v1/azure-container-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/containers",
          "scopes": "auth:azure-container:list-containers:<account>",
          "stability": "deprecated",
          "title": "List containers in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "container",
            "level"
          ],
          "category": "Azure Credentials",
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nBlob Storage container.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ncontainer if it doesn't already exist.",
          "method": "get",
          "name": "azureContainerSAS",
          "output": "v1/azure-container-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/containers/<container>/<level>",
          "scopes": {
            "else": "auth:azure-container:read-write:<account>/<container>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-container:read-only:<account>/<container>",
                "auth:azure-container:read-write:<account>/<container>"
              ]
            }
          },
          "stability": "deprecated",
          "title": "Get Shared-Access-Signature for Azure Container",
          "type": "function"
        },
        {
          "args": [
            "project"
          ],
          "category": "Sentry Credentials",
          "description": "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
          "method": "get",
          "name": "sentryDSN",
          "output": "v1/sentry-dsn-response.json#",
          "query": [
          ],
          "route": "/sentry/<project>/dsn",
          "scopes": "auth:sentry:<project>",
          "stability": "stable",
          "title": "Get DSN for Sentry Project",
          "type": "function"
        },
        {
          "args": [
            "wstAudience",
            "wstClient"
          ],
          "category": "Websocktunnel Credentials",
          "description": "Get a temporary token suitable for use connecting to a\n[websocktunnel](https://github.com/taskcluster/taskcluster/tree/main/tools/websocktunnel) server.\n\nThe resulting token will only be accepted by servers with a matching audience\nvalue.  Reaching such a server is the callers responsibility.  In general,\na server URL or set of URLs should be provided to the caller as configuration\nalong with the audience value.\n\nThe token is valid for a limited time (on the scale of hours). Callers should\nrefresh it before expiration.",
          "method": "get",
          "name": "websocktunnelToken",
          "output": "v1/websocktunnel-token-response.json#",
          "query": [
          ],
          "route": "/websocktunnel/<wstAudience>/<wstClient>",
          "scopes": "auth:websocktunnel-token:<wstAudience>/<wstClient>",
          "stability": "stable",
          "title": "Get a client token for the Websocktunnel service",
          "type": "function"
        },
        {
          "args": [
            "projectId",
            "serviceAccount"
          ],
          "category": "GCP Credentials",
          "description": "Get temporary GCP credentials for the given serviceAccount in the given project.\n\nOnly preconfigured projects and serviceAccounts are allowed, as defined in the\ndeployment of the Taskcluster services.\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.",
          "method": "get",
          "name": "gcpCredentials",
          "output": "v1/gcp-credentials-response.json#",
          "query": [
          ],
          "route": "/gcp/credentials/<projectId>/<serviceAccount>",
          "scopes": "auth:gcp:access-token:<projectId>/<serviceAccount>",
          "stability": "stable",
          "title": "Get Temporary GCP Credentials",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Scopes and Auth",
          "description": "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on Taskcluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
          "input": "v1/authenticate-hawk-request.json#",
          "method": "post",
          "name": "authenticateHawk",
          "output": "v1/authenticate-hawk-response.json#",
          "query": [
          ],
          "route": "/authenticate-hawk",
          "stability": "stable",
          "title": "Authenticate Hawk Request",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Scopes and Auth",
          "description": "Utility method to test client implementations of Taskcluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
          "input": "v1/test-authenticate-request.json#",
          "method": "post",
          "name": "testAuthenticate",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate",
          "stability": "stable",
          "title": "Test Authentication",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Scopes and Auth",
          "description": "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the\n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
          "method": "get",
          "name": "testAuthenticateGet",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate-get/",
          "stability": "stable",
          "title": "Test Authentication (GET)",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Monitoring",
          "description": "Respond with a service heartbeat.\n\nThis endpoint is used to check on backing services this service\ndepends on.",
          "method": "get",
          "name": "heartbeat",
          "query": [
          ],
          "route": "/__heartbeat__",
          "stability": "stable",
          "title": "Heartbeat",
          "type": "function"
        }
      ],
      "serviceName": "auth",
      "title": "Auth Service"
    },
    "filename": "references/auth/v1/api.json"
  }
]