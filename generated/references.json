[
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/workertype-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of worker types",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerTypes": {
          "description": "List of all workertypes",
          "items": {
            "$ref": "workertype-full.json#"
          },
          "title": "List of all workertypes",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerTypes"
      ],
      "title": "WorkerType List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/workertype-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/workertype-full.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete workerType definition.\n",
      "properties": {
        "config": {
          "additionalProperties": true,
          "type": "object"
        },
        "created": {
          "description": "Date and time when this workerType was created\n",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "description": {
          "description": "A description of this workerType.\n",
          "maxLength": 10240,
          "title": "Description",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time when this workerType was last updated\n",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "name": {
          "description": "The name of this workertype.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "[a-z]([-a-z0-9]*[a-z0-9])?",
          "title": "WorkerType Name",
          "type": "string"
        },
        "owner": {
          "description": "An email address to notify when there are provisioning errors for this\nworkertype.\n",
          "format": "email",
          "title": "Owner Email",
          "type": "string"
        },
        "provider": {
          "description": "The provider responsible for managing this workertype.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "scheduledForDeletion": {
          "description": "If true, a user has requested that this workertype be deleted",
          "title": "Scheduled For Deletion",
          "type": "boolean"
        },
        "wantsEmail": {
          "description": "If true, the owner should be emailed on provisioning errors",
          "title": "Wants Email",
          "type": "boolean"
        }
      },
      "required": [
        "provider",
        "description",
        "created",
        "lastModified",
        "config",
        "owner",
        "scheduledForDeletion",
        "wantsEmail"
      ],
      "title": "WorkerType Full",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/workertype-full.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/temp-creds-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for workers that want Taskcluster credentials",
      "properties": {
        "accessToken": {
          "description": "AccessToken used for authenticating requests, you should store this\nyou won't be able to retrive it again!\n",
          "type": "string"
        },
        "certificate": {
          "description": "Needed to access taskcluster apis using temporary credentials",
          "type": "string"
        },
        "clientId": {
          "description": "ClientId of the client",
          "type": "string"
        }
      },
      "required": [
        "accessToken",
        "clientId",
        "certificate"
      ],
      "title": "Temporary Credentials Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/temp-creds-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/pulse-workertype-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "The message that is emitted when workertypes are created/changed/deleted.",
      "properties": {
        "name": {
          "$ref": "workertype-full.json#/properties/provider"
        },
        "previousProvider": {
          "description": "If this is defined, it was the provider that handled this workertype in the \nconfiguration before the current one. This will be used by providers to clean\nup any resources created for this workerType when they are no longer responsible\nfor it.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Previous Provider",
          "type": "string"
        },
        "provider": {
          "$ref": "workertype-full.json#/properties/provider"
        }
      },
      "required": [
        "name",
        "provider"
      ],
      "title": "WorkerType Pulse Message",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/pulse-workertype-message.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/credentials-google-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Called by workers to get Taskcluster credentials",
      "properties": {
        "token": {
          "description": "A JWT token as defined in [this google documentation](https://cloud.google.com/compute/docs/instances/verifying-instance-identity)",
          "title": "Token",
          "type": "string"
        }
      },
      "required": [
        "token"
      ],
      "title": "Google Credential Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/credentials-google-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/create-workertype-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Fields that are defined by a user for a workertype.\nUsed to create and modify definitions. There is a larger\nset of fields for viewing since some parts are generated\nby the service.\n",
      "properties": {
        "config": {
          "$ref": "workertype-full.json#/properties/config"
        },
        "description": {
          "$ref": "workertype-full.json#/properties/description"
        },
        "owner": {
          "$ref": "workertype-full.json#/properties/owner"
        },
        "provider": {
          "$ref": "workertype-full.json#/properties/provider"
        },
        "wantsEmail": {
          "$ref": "workertype-full.json#/properties/wantsEmail"
        }
      },
      "required": [
        "provider",
        "description",
        "config",
        "owner",
        "wantsEmail"
      ],
      "title": "WorkerType Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/create-workertype-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-testing.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A provider used for testing",
      "title": "Testing Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-testing.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-static.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A configuration for static workertypes",
      "title": "Static Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-static.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-google.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "'The config section of a workertype is using a provider with implementation google must match this.\nMuch of these fields are documented [here](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates)'\n",
      "properties": {
        "capacityPerInstance": {
          "description": "The number of tasks a single worker of this type can run at any given time.",
          "minimum": 1,
          "title": "Capacity Per Instance",
          "type": "integer"
        },
        "disks": {
          "description": "Configure the networking available to the instance. Permitted fields documented in\nthe full instance template docs above. It is likely that you will want to have at least\na single `PERSISTENT` disk where the source image is one that contains a taskcluster worker\nconfigured to run on boot and talk to worker-manager for credentials.\n",
          "items": {
            "additionalProperties": true,
            "type": "object"
          },
          "title": "Disks",
          "type": "array",
          "uniqueItems": false
        },
        "machineType": {
          "description": "'The google machine type to use to run this instance. This refers to\n[these types](https://cloud.google.com/compute/docs/machine-types)'\n",
          "title": "Machine Type",
          "type": "string"
        },
        "maxCapacity": {
          "description": "The maximum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "The minimum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Minimum Capacity",
          "type": "integer"
        },
        "networkInterfaces": {
          "description": "Configure the networking available to the instance. Permitted fields documented in\nthe full instance template docs above.\n",
          "items": {
            "additionalProperties": true,
            "type": "object"
          },
          "title": "Network Interfaces",
          "type": "array",
          "uniqueItems": false
        },
        "regions": {
          "description": "The google cloud regions to run these instances in. Google documents these [here](https://cloud.google.com/compute/docs/regions-zones/)",
          "items": {
            "type": "string"
          },
          "title": "Regions",
          "type": "array",
          "uniqueItems": true
        },
        "scheduling": {
          "additionalProperties": true,
          "description": "Extra documentation [here](https://cloud.google.com/compute/docs/instances/setting-instance-scheduling-options)",
          "title": "Scheduling",
          "type": "object"
        },
        "userData": {
          "additionalProperties": true,
          "description": "Arbitrary configuration that Worker Manager will make available to the worker\non start up via instance metadata.\n",
          "title": "User Data",
          "type": "object"
        }
      },
      "required": [
        "minCapacity",
        "maxCapacity",
        "capacityPerInstance",
        "machineType",
        "regions",
        "userData",
        "scheduling",
        "networkInterfaces",
        "disks"
      ],
      "title": "Google Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-google.json"
  },
  {
    "content": {
      "$id": "/schemas/treeherder/v1/task-treeherder-config.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "Definition of the Treeherder configuration data that can be contained within\na task definition under task.extra.treeherder.  This information is useful for\ndetermining job properties to report to Treeherder.\n",
      "properties": {
        "groupName": {
          "maxLength": 100,
          "minLength": 1,
          "title": "group name",
          "type": "string"
        },
        "groupSymbol": {
          "description": "Group Symbol is the symbol that job symbols will be grouped under.  This\nis useful if there is a particular group of jobs that should be displayed\ntogether.  For example, a test suite named \"Media Tests\" with the group symbol\nof \"ME\" would have all jobs with that group symbol appear as\nME(symbol 1, symbol 2, ...).\n",
          "maxLength": 25,
          "minLength": 1,
          "title": "group symbol",
          "type": "string"
        },
        "jobKind": {
          "default": "other",
          "description": "jobKind specifies the type of task that should be reported to Treeherder.\nThe jobKind could cause Treeherder to display/treat the task differently.\nFor instance, tasks with a jobKind of 'build' will be reported as red when\nthe task fails, 'test' as orange, and any jobs not specifying jobKind or\n'other' will be red.\n",
          "enum": [
            "build",
            "test",
            "other"
          ],
          "type": "string"
        },
        "labels": {
          "description": "Labels are a dimension of a platform.  The values here can vary wildly,\nso most strings are valid for this.  The list of labels that are used\nis malleable going forward.\n\nThese were formerly known as \"Collection\" calling labels now so they\ncan be understood to be just strings that denotes a characteristic of the job.\n\nThese labels will be used for grouping jobs with a particular job platform.\nFor instance, a job with the label \"debug\" will be put into the debug platform\non Treeherder.  By default, if no label is specified, the job will be classified\nas \"opt\"\n\nSome examples of labels that have been used:\n  opt    Optimize Compiler GCC optimize flags\n  debug  Debug flags passed in\n  pgo    Profile Guided Optimization - Like opt, but runs with profiling, then builds again using that profiling\n  asan   Address Sanitizer\n  tsan   Thread Sanitizer Build\n",
          "items": {
            "maxLength": 50,
            "minLength": 1,
            "pattern": "^[A-Za-z0-9_-]+$",
            "type": "string"
          },
          "title": "labels",
          "type": "array",
          "uniqueItems": false
        },
        "machine": {
          "additionalProperties": false,
          "properties": {
            "architecture": {
              "maxLength": 25,
              "minLength": 1,
              "pattern": "^[A-Za-z0-9_-]+$",
              "type": "string"
            },
            "os": {
              "maxLength": 25,
              "minLength": 1,
              "pattern": "^[A-Za-z0-9_-]+$",
              "type": "string"
            },
            "platform": {
              "description": "The platform specified here maps to platforms that Treeherder recognizes.\nJobs with the same platform will be displayed within the same row on\nTreeherder and obey any ordering that is defined'.\n\nIf no build platform is specified, the workerType specified for the job\nwill be used.\n",
              "maxLength": 50,
              "minLength": 1,
              "pattern": "^[A-Za-z0-9_-]+$",
              "type": "string"
            }
          },
          "required": [
            "platform"
          ],
          "type": "object"
        },
        "productName": {
          "description": "Examples include:\n-  'firefox'\n-  'taskcluster'\n-  'xulrunner'\n",
          "maxLength": 125,
          "minLength": 1,
          "type": "string"
        },
        "reason": {
          "description": "Examples include:\n- scheduled\n- scheduler\n- Self-serve: Rebuilt by foo@example.com\n- Self-serve: Requested by foo@example.com\n- The Nightly scheduler named 'mozilla-inbound periodic' triggered this build\n- unknown\n",
          "maxLength": 125,
          "minLength": 1,
          "type": "string"
        },
        "symbol": {
          "description": "This is the symbol that will appear in a Treeherder resultset for a\ngiven push.  This symbol could be something such as \"B\" or a number representing\nthe current chunk.\n",
          "maxLength": 25,
          "minLength": 0,
          "title": "symbol",
          "type": "string"
        },
        "tier": {
          "description": "Tiers are used for classifying jobs according to the Sheriffing policy.\nThese jobs can be hidden based on exclusion profiles within Treeherder and\ndisplay of these jobs toggled by UI settings.\n\nBy default jobs which do not specify a tier will be classified as Tier 1.\n",
          "maximum": 3,
          "minimum": 1,
          "type": "integer"
        }
      },
      "required": [
        "symbol"
      ],
      "title": "Treeherder Configuration",
      "type": "object"
    },
    "filename": "schemas/treeherder/v1/task-treeherder-config.json"
  },
  {
    "content": {
      "$id": "/schemas/treeherder/v1/pulse-job.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "machine": {
          "additionalProperties": false,
          "properties": {
            "architecture": {
              "maxLength": 25,
              "minLength": 1,
              "pattern": "^[\\w-]+$",
              "type": "string"
            },
            "name": {
              "maxLength": 50,
              "minLength": 1,
              "pattern": "^[\\w-]+$",
              "type": "string"
            },
            "os": {
              "maxLength": 25,
              "minLength": 1,
              "pattern": "^[\\w-]+$",
              "type": "string"
            },
            "platform": {
              "maxLength": 100,
              "minLength": 1,
              "pattern": "^[\\w-]+$",
              "type": "string"
            }
          },
          "required": [
            "platform",
            "os",
            "architecture"
          ],
          "type": "object"
        }
      },
      "description": "Definition of a single job that can be added to Treeherder\nProject is determined by the routing key, so we don't need to specify it here.\n",
      "properties": {
        "buildMachine": {
          "$ref": "#/definitions/machine"
        },
        "buildSystem": {
          "description": "The name of the build system that initiated this content.  Some examples\nare \"buildbot\" and \"taskcluster\".  But this could be any name.  This\nvalue will be used in the routing key for retriggering jobs in the\npublish-job-action task.\n",
          "maxLength": 25,
          "minLength": 1,
          "pattern": "^[\\w-]+$",
          "type": "string"
        },
        "coalesced": {
          "description": "The job guids that were coalesced to this job.",
          "items": {
            "maxLength": 50,
            "minLength": 1,
            "pattern": "^[\\w/+-]+$",
            "title": "Job GUID",
            "type": "string"
          },
          "title": "Coalesced job GUID",
          "type": "array",
          "uniqueItems": false
        },
        "display": {
          "additionalProperties": false,
          "properties": {
            "chunkCount": {
              "minimum": 1,
              "title": "Chunk Count",
              "type": "integer"
            },
            "chunkId": {
              "minimum": 1,
              "title": "Chunk ID",
              "type": "integer"
            },
            "groupName": {
              "maxLength": 100,
              "minLength": 1,
              "title": "Group Name",
              "type": "string"
            },
            "groupSymbol": {
              "maxLength": 25,
              "minLength": 1,
              "title": "Group Symbol",
              "type": "string"
            },
            "jobName": {
              "maxLength": 100,
              "minLength": 1,
              "title": "Job Name",
              "type": "string"
            },
            "jobSymbol": {
              "maxLength": 25,
              "minLength": 0,
              "title": "Job Symbol",
              "type": "string"
            }
          },
          "required": [
            "jobName",
            "jobSymbol",
            "groupSymbol"
          ],
          "type": "object"
        },
        "extra": {
          "description": "Extra information that Treeherder reads on a best-effort basis",
          "type": "object"
        },
        "isRetried": {
          "description": "True indicates this job has been retried.",
          "type": "boolean"
        },
        "jobInfo": {
          "additionalProperties": false,
          "description": "Definition of the Job Info for a job.  These are extra data\nfields that go along with a job that will be displayed in\nthe details panel within Treeherder.\n",
          "properties": {
            "links": {
              "items": {
                "additionalProperties": false,
                "description": "List of URLs shown as key/value pairs.  Shown as:\n\"<label>: <linkText>\" where linkText will be a link to the url.\n",
                "properties": {
                  "label": {
                    "maxLength": 70,
                    "minLength": 1,
                    "type": "string"
                  },
                  "linkText": {
                    "maxLength": 125,
                    "minLength": 1,
                    "type": "string"
                  },
                  "url": {
                    "format": "uri",
                    "maxLength": 512,
                    "type": "string"
                  }
                },
                "required": [
                  "url",
                  "linkText",
                  "label"
                ],
                "title": "Link",
                "type": "object"
              },
              "type": "array",
              "uniqueItems": false
            },
            "summary": {
              "description": "Plain text description of the job and its state.  Submitted with\nthe final message about a task.\n",
              "type": "string"
            }
          },
          "required": [
            "summary",
            "links"
          ],
          "type": "object"
        },
        "jobKind": {
          "default": "other",
          "enum": [
            "build",
            "test",
            "other"
          ],
          "type": "string"
        },
        "labels": {
          "description": "Labels are a dimension of a platform.  The values here can vary wildly,\nso most strings are valid for this.  The list of labels that are used\nis maleable going forward.\n\nThese were formerly known as \"Options\" within \"Option Collections\" but\ncalling labels now so they can be understood to be just strings that\ndenotes a characteristic of the job.\n\nSome examples of labels that have been used:\n  opt    Optimize Compiler GCC optimize flags\n  debug  Debug flags passed in\n  pgo    Profile Guided Optimization - Like opt, but runs with profiling, then builds again using that profiling\n  asan   Address Sanitizer\n  tsan   Thread Sanitizer Build\n",
          "items": {
            "maxLength": 50,
            "minLength": 1,
            "pattern": "^[\\w-]+$",
            "title": "Label",
            "type": "string"
          },
          "title": "Labels",
          "type": "array",
          "uniqueItems": false
        },
        "logs": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "errorsTruncated": {
                "description": "If true, indicates that the number of errors in the log was too\nlarge and not all of those lines are indicated here.\n",
                "type": "boolean"
              },
              "name": {
                "maxLength": 50,
                "minLength": 1,
                "type": "string"
              },
              "steps": {
                "description": "This object defines what is seen in the Treeherder Log Viewer.\nThese values can be submitted here, or they will be generated\nby Treeherder's internal log parsing process from the\nsubmitted log.  If this value is submitted, Treeherder will\nconsider the log already parsed and skip parsing.\n",
                "items": {
                  "additionalProperties": false,
                  "properties": {
                    "errors": {
                      "items": {
                        "additionalProperties": false,
                        "properties": {
                          "line": {
                            "maxLength": 255,
                            "minLength": 1,
                            "type": "string"
                          },
                          "linenumber": {
                            "minimum": 0,
                            "type": "integer"
                          }
                        },
                        "required": [
                          "line",
                          "linenumber"
                        ],
                        "title": "Error",
                        "type": "object"
                      },
                      "type": "array",
                      "uniqueItems": false
                    },
                    "lineFinished": {
                      "minimum": 0,
                      "type": "integer"
                    },
                    "lineStarted": {
                      "minimum": 0,
                      "type": "integer"
                    },
                    "name": {
                      "maxLength": 255,
                      "minLength": 1,
                      "type": "string"
                    },
                    "result": {
                      "enum": [
                        "success",
                        "fail",
                        "exception",
                        "canceled",
                        "unknown"
                      ],
                      "type": "string"
                    },
                    "timeFinished": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "timeStarted": {
                      "format": "date-time",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "timeStarted",
                    "lineStarted",
                    "lineFinished",
                    "timeFinished",
                    "result"
                  ],
                  "title": "Step",
                  "type": "object"
                },
                "type": "array",
                "uniqueItems": false
              },
              "url": {
                "format": "uri",
                "maxLength": 255,
                "minLength": 1,
                "type": "string"
              }
            },
            "required": [
              "url",
              "name"
            ],
            "title": "Log",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "origin": {
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "PREFERRED: An HG job that only has a revision.  This is for all\njobs going forward.\n",
              "properties": {
                "kind": {
                  "enum": [
                    "hg.mozilla.org"
                  ],
                  "type": "string"
                },
                "project": {
                  "maxLength": 50,
                  "minLength": 1,
                  "pattern": "^[\\w-]+$",
                  "type": "string"
                },
                "pushLogID": {
                  "type": "integer"
                },
                "revision": {
                  "maxLength": 40,
                  "minLength": 40,
                  "pattern": "^[0-9a-f]+$",
                  "type": "string"
                }
              },
              "required": [
                "kind",
                "project",
                "revision"
              ],
              "title": "HG Push",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "kind": {
                  "enum": [
                    "github.com"
                  ],
                  "type": "string"
                },
                "owner": {
                  "description": "This could be the organization or the individual git username\ndepending on who owns the repo.\n",
                  "maxLength": 50,
                  "minLength": 1,
                  "pattern": "^[\\w-]+$",
                  "type": "string"
                },
                "project": {
                  "maxLength": 50,
                  "minLength": 1,
                  "pattern": "^[\\w-]+$",
                  "type": "string"
                },
                "pullRequestID": {
                  "type": "integer"
                },
                "revision": {
                  "maxLength": 40,
                  "minLength": 40,
                  "type": "string"
                }
              },
              "required": [
                "kind",
                "project",
                "revision"
              ],
              "title": "Github Pull Request",
              "type": "object"
            }
          ]
        },
        "owner": {
          "description": "Description of who submitted the job: scheduler name | username | email\n",
          "maxLength": 50,
          "minLength": 1,
          "title": "Owner",
          "type": "string"
        },
        "productName": {
          "description": "Examples include:\n-  'firefox'\n-  'taskcluster'\n-  'xulrunner'\n",
          "maxLength": 125,
          "minLength": 1,
          "type": "string"
        },
        "reason": {
          "description": "Examples include:\n- scheduled\n- scheduler\n- Self-serve: Rebuilt by foo@example.com\n- Self-serve: Requested by foo@example.com\n- The Nightly scheduler named 'mozilla-inbound periodic' triggered this build\n- unknown\n",
          "maxLength": 125,
          "minLength": 1,
          "type": "string"
        },
        "result": {
          "description": "fail: A failure\nexception: An infrastructure error/exception\nsuccess: Build/Test executed without error or failure\ncanceled: The job was cancelled by a user\nunknown: When the job is not yet completed\nsuperseded: When a job has been superseded by another job\n",
          "enum": [
            "success",
            "fail",
            "exception",
            "canceled",
            "superseded",
            "unknown"
          ],
          "title": "Result",
          "type": "string"
        },
        "retryId": {
          "default": 0,
          "description": "The infrastructure retry iteration on this job.  The number of times this\njob has been retried by the infrastructure.\nIf it's the 1st time running, then it should be 0. If this is the first\nretry, it will be 1, etc.\n",
          "minimum": 0,
          "title": "Retry ID",
          "type": "integer"
        },
        "runMachine": {
          "$ref": "#/definitions/machine"
        },
        "state": {
          "description": "unscheduled: not yet scheduled\npending: not yet started\nrunning: currently in progress\ncompleted: Job ran through to completion\n",
          "enum": [
            "unscheduled",
            "pending",
            "running",
            "completed"
          ],
          "title": "State",
          "type": "string"
        },
        "taskId": {
          "description": "This could just be what was formerly submitted as a job_guid in the\nREST API.\n",
          "maxLength": 50,
          "minLength": 1,
          "pattern": "^[A-Za-z0-9/+-]+$",
          "title": "Task ID",
          "type": "string"
        },
        "tier": {
          "maximum": 3,
          "minimum": 1,
          "type": "integer"
        },
        "timeCompleted": {
          "format": "date-time",
          "type": "string"
        },
        "timeScheduled": {
          "format": "date-time",
          "type": "string"
        },
        "timeStarted": {
          "format": "date-time",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "taskId",
        "origin",
        "buildSystem",
        "display",
        "state",
        "jobKind",
        "version"
      ],
      "title": "Job Definition",
      "type": "object"
    },
    "filename": "schemas/treeherder/v1/pulse-job.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a Taskcluster Secret\n",
      "properties": {
        "expires": {
          "description": "An expiration date for this secret.\n",
          "format": "date-time",
          "type": "string"
        },
        "secret": {
          "description": "The secret value to be encrypted.\n",
          "type": "object"
        }
      },
      "required": [
        "secret",
        "expires"
      ],
      "title": "Secret",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a list of secret names\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "secrets": {
          "description": "Secret names",
          "items": {
            "description": "Secret name",
            "title": "Secret",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "secrets"
      ],
      "title": "Secrets List",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret-list.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/workertype-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a worker-type request from a provisioner.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker-type` are included.\n",
                "enum": [
                  "worker-type"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker-type Action",
            "type": "object"
          },
          "title": "Worker-type Actions",
          "type": "array",
          "uniqueItems": false
        },
        "description": {
          "description": "Description of the worker-type.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this worker-type was seen active. `lastDateActive` is updated every 6 hours\nbut may be off by up-to 6 hours. Nonetheless, `lastDateActive` is a good indicator\nof when the worker-type was last seen active.\n",
          "format": "date-time",
          "title": "Worker-type Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provisioner ID",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the worker-type. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        },
        "workerType": {
          "description": "WorkerType name.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker-type Name",
          "type": "string"
        }
      },
      "required": [
        "workerType",
        "provisionerId",
        "description",
        "stability",
        "expires",
        "lastDateActive",
        "actions"
      ],
      "title": "Worker-type Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/workertype-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a worker.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker` are included.\n",
                "enum": [
                  "worker"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker Action",
            "type": "object"
          },
          "title": "Worker Actions",
          "type": "array",
          "uniqueItems": false
        },
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        },
        "firstClaim": {
          "description": "Date of the first time this worker claimed a task.\n",
          "format": "date-time",
          "title": "First task claimed",
          "type": "string"
        },
        "provisionerId": {
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provisioner ID",
          "type": "string"
        },
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        },
        "recentTasks": {
          "description": "List of 20 most recent tasks claimed by the worker.\n",
          "items": {
            "$ref": "task-run.json#"
          },
          "title": "Most Recent Tasks",
          "type": "array",
          "uniqueItems": false
        },
        "workerGroup": {
          "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Group",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker evaluating this run within given\n`workerGroup`.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Identifier",
          "type": "string"
        },
        "workerType": {
          "description": "WorkerType name.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "WorkerType name",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "workerGroup",
        "workerId",
        "recentTasks",
        "expires",
        "firstClaim",
        "actions"
      ],
      "title": "Worker Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-workertype-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker-type.\n",
      "properties": {
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker-type Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-workertype-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-provisioner-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Provisioner Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-provisioner-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "default": [
          ],
          "description": "List of dependent tasks. These must either be _completed_ or _resolved_\nbefore this task is scheduled. See `requires` for semantics.\n",
          "items": {
            "description": "The `taskId` of a task that must be resolved before this task is\nscheduled.\n",
            "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
            "title": "Task Dependency",
            "type": "string"
          },
          "maxItems": 100,
          "title": "Task Dependencies",
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Task expiration, time at which task definition and status is deleted.\nNotice that all artifacts for the task must have an expiration that is no\nlater than this. If this property isn't it will be set to `deadline`\nplus one year (this default may change).\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "extra": {
          "default": {
          },
          "description": "Object with properties that can hold any kind of extra data that should be\nassociated with the task. This can be data for the task which doesn't\nfit into `payload`, or it can supplementary data for use in services\nlistening for events from this task. For example this could be details to\ndisplay on _treeherder_, or information for indexing the task. Please, try\nto put all related information under one property, so `extra` data keys\nfor treeherder reporting and task indexing don't conflict, hence, we have\nreusable services. **Warning**, do not stuff large data-sets in here --\ntask definitions should not take-up multiple MiBs.\n",
          "title": "Extra Data",
          "type": "object"
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "description": "Task-specific payload following worker-specific format.\nRefer to the documentation for the worker implementing\n`<provisionerId>/<workerType>` for details.\n",
          "title": "Task Payload",
          "type": "object"
        },
        "priority": {
          "default": "lowest",
          "description": "Priority of task. This defaults to `lowest` and the scope\n`queue:create-task:<priority>/<provisionerId>/<workerType>` is required\nto define a task with `<priority>`. The `normal` priority is treated as\n`lowest`.\n",
          "enum": [
            "highest",
            "very-high",
            "high",
            "medium",
            "low",
            "very-low",
            "lowest",
            "normal"
          ],
          "title": "Task Priority",
          "type": "string"
        },
        "provisionerId": {
          "description": "Unique identifier for a provisioner, that can supply specified\n`workerType`\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provisioner Id",
          "type": "string"
        },
        "requires": {
          "default": "all-completed",
          "description": "The tasks relation to its dependencies. This property specifies the\nsemantics of the `task.dependencies` property.\nIf `all-completed` is given the task will be scheduled when all\ndependencies are resolved _completed_ (successful resolution).\nIf `all-resolved` is given the task will be scheduled when all dependencies\nhave been resolved, regardless of what their resolution is.\n",
          "enum": [
            "all-completed",
            "all-resolved"
          ],
          "title": "Dependency Requirement Semantics",
          "type": "string"
        },
        "retries": {
          "default": 5,
          "description": "Number of times to retry the task in case of infrastructure issues.\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\nthese events are to be expected.\n",
          "maximum": 49,
          "minimum": 0,
          "title": "Retries",
          "type": "integer"
        },
        "routes": {
          "default": [
          ],
          "description": "List of task-specific routes. Pulse messages about the task will be CC'ed to\n`route.<value>` for each `<value>` in this array.\n",
          "items": {
            "description": "A task specific route.\n",
            "maxLength": 249,
            "minLength": 1,
            "title": "Task Specific Route",
            "type": "string"
          },
          "maxItems": 64,
          "title": "Task Specific Routes",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "default": "-",
          "description": "All tasks in a task group must have the same `schedulerId`. This is used for several purposes:\n\n* it can represent the entity that created the task;\n* it can limit addition of new tasks to a task group: the caller of\n    `createTask` must have a scope related to the `schedulerId` of the task\n    group;\n* it controls who can manipulate tasks, again by requiring\n    `schedulerId`-related scopes; and\n* it appears in the routing key for Pulse messages about the task.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes that the task is authorized to use during its execution.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "title": "Scopes",
          "type": "array",
          "uniqueItems": false
        },
        "tags": {
          "additionalProperties": {
            "maxLength": 4096,
            "type": "string"
          },
          "default": {
          },
          "description": "Arbitrary key-value tags (only strings limited to 4k). These can be used\nto attach informal metadata to a task. Use this for informal tags that\ntasks can be classified by. You can also think of strings here as\ncandidates for formal metadata. Something like\n`purpose: 'build' || 'test'` is a good example.\n",
          "title": "Tags",
          "type": "object"
        },
        "taskGroupId": {
          "description": "Identifier for a group of tasks scheduled together with this task.\nGenerally, all tasks related to a single event such as a version-control\npush or a nightly build have the same `taskGroupId`.  This property\ndefaults to `taskId` if it isn't specified.  Tasks with `taskId` equal to\nthe `taskGroupId` are, [by convention](/docs/manual/using/task-graph),\ndecision tasks.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "workerType": {
          "description": "Unique identifier for a worker-type within a specific provisioner\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Type",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "schedulerId",
        "taskGroupId",
        "dependencies",
        "requires",
        "routes",
        "priority",
        "retries",
        "created",
        "deadline",
        "scopes",
        "payload",
        "metadata",
        "tags",
        "extra"
      ],
      "title": "Task Definition Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A representation of **task status** as known by the queue\n",
      "properties": {
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "expires": {
          "description": "Task expiration, time at which task definition and\nstatus is deleted. Notice that all artifacts for the task\nmust have an expiration that is no later than this.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "retriesLeft": {
          "description": "Number of retries left for the task in case of infrastructure issues\n",
          "maximum": 999,
          "minimum": 0,
          "title": "Retries Left",
          "type": "integer"
        },
        "runs": {
          "description": "List of runs, ordered so that index `i` has `runId == i`\n",
          "items": {
            "additionalProperties": false,
            "description": "JSON object with information about a run\n",
            "properties": {
              "reasonCreated": {
                "description": "Reason for the creation of this run,\n**more reasons may be added in the future**.\n",
                "enum": [
                  "scheduled",
                  "retry",
                  "task-retry",
                  "rerun",
                  "exception"
                ],
                "title": "Reason Created",
                "type": "string"
              },
              "reasonResolved": {
                "description": "Reason that run was resolved, this is mainly\nuseful for runs resolved as `exception`.\nNote, **more reasons may be added in the future**, also this\nproperty is only available after the run is resolved. Some of these\nreasons, notably `intermittent-task`, `worker-shutdown`, and\n`claim-expired`, will trigger an automatic retry of the task.\n",
                "enum": [
                  "completed",
                  "failed",
                  "deadline-exceeded",
                  "canceled",
                  "superseded",
                  "claim-expired",
                  "worker-shutdown",
                  "malformed-payload",
                  "resource-unavailable",
                  "internal-error",
                  "intermittent-task"
                ],
                "title": "Reason Resolved",
                "type": "string"
              },
              "resolved": {
                "description": "Date-time at which this run was resolved, ie. when the run changed\nstate from `running` to either `completed`, `failed` or `exception`.\nThis property is only present after the run as been resolved.\n",
                "format": "date-time",
                "title": "Resolved",
                "type": "string"
              },
              "runId": {
                "description": "Id of this task run, `run-id`s always starts from `0`\n",
                "maximum": 1000,
                "minimum": 0,
                "title": "Run Identifier",
                "type": "integer"
              },
              "scheduled": {
                "description": "Date-time at which this run was scheduled, ie. when the run was\ncreated in state `pending`.\n",
                "format": "date-time",
                "title": "Scheduled",
                "type": "string"
              },
              "started": {
                "description": "Date-time at which this run was claimed, ie. when the run changed\nstate from `pending` to `running`. This property is only present\nafter the run has been claimed.\n",
                "format": "date-time",
                "title": "Started",
                "type": "string"
              },
              "state": {
                "description": "State of this run\n",
                "enum": [
                  "pending",
                  "running",
                  "completed",
                  "failed",
                  "exception"
                ],
                "title": "Run State",
                "type": "string"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `failed`, if the\nrun isn't reclaimed. Note, only present after the run has been\nclaimed.\n",
                "format": "date-time",
                "title": "Taken Until",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\nNote, this property is only present after the run is claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Group",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for worker evaluating this run within given\n`workerGroup`. Note, this property is only available after the run\nhas been claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Identifier",
                "type": "string"
              }
            },
            "required": [
              "runId",
              "state",
              "reasonCreated",
              "scheduled"
            ],
            "title": "Run Information",
            "type": "object"
          },
          "title": "List of Runs",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "state": {
          "description": "State of this task. This is just an auxiliary property derived from state\nof latests run, or `unscheduled` if none.\n",
          "enum": [
            "unscheduled",
            "pending",
            "running",
            "completed",
            "failed",
            "exception"
          ],
          "title": "State",
          "type": "string"
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "taskId",
        "provisionerId",
        "workerType",
        "schedulerId",
        "taskGroupId",
        "deadline",
        "expires",
        "retriesLeft",
        "state",
        "runs"
      ],
      "title": "Task Status Structure",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a task status request\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        }
      },
      "required": [
        "status"
      ],
      "title": "Task Status Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-running-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a given run of a task have started\n",
      "properties": {
        "runId": {
          "description": "Id of the run that just started, always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `failed`, if the run\nisn't reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil"
      ],
      "title": "Task Running Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-running-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-run.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A run of a task.\n",
      "properties": {
        "runId": {
          "description": "Id of this task run, `run-id`s always starts from `0`\n",
          "maximum": 1000,
          "minimum": 0,
          "title": "Run Identifier",
          "type": "integer"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "runId"
      ],
      "title": "Task Run",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-run.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-reclaim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "credentials"
      ],
      "title": "Task Reclaim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-reclaim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-pending-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task is now pending\n",
      "properties": {
        "runId": {
          "description": "Id of run that became pending, `run-id`s always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status",
        "runId"
      ],
      "title": "Task Pending Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-pending-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Required task metadata\n",
      "properties": {
        "description": {
          "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "name": {
          "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "E-mail of person who caused this task, e.g. the person who did\n`hg push`. The person we should contact to ask why this task is here.\n",
          "format": "email",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        },
        "source": {
          "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
          "format": "uri",
          "maxLength": 4096,
          "pattern": "^https?://",
          "title": "Source",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner",
        "source"
      ],
      "title": "Task Metadata",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-group-resolved.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message written once a task group has no tasks to be run. It is\npossible for a task group to later have another task added, in which\ncase this message will be sent again once it finishes.\n",
      "properties": {
        "schedulerId": {
          "description": "Identifier for the scheduler that created this task-group.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "taskGroupId",
        "schedulerId"
      ],
      "title": "Task Group Resolved Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-group-resolved.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-failed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task failed to complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that failed.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Failed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-failed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request for a run of a task to be resolved with an exception\n",
      "properties": {
        "reason": {
          "description": "Reason that the task is resolved with an exception. This is a subset\nof the values for `resolvedReason` given in the task status structure.\n**Report `worker-shutdown`** if the run failed because the worker\nhad to shutdown (spot node disappearing). In case of `worker-shutdown`\nthe queue will immediately **retry** the task, by making a new run.\nThis is much faster than ignoreing the issue and letting the task _retry_\nby claim expiration. For any other _reason_ reported the queue will not\nretry the task.\n**Report `malformed-payload`** if the `task.payload` doesn't match the\nschema for the worker payload, or referenced resource doesn't exists.\nIn either case, you should still log the error to a log file for the\nspecific run.\n**Report `resource-unavailable`** if a resource/service needed or\nreferenced in `task.payload` is _temporarily_ unavailable. Do not use this\nunless you know the resource exists, if the resource doesn't exist you\nshould report `malformed-payload`. Example use-case if you contact the\nindex (a service) on behalf of the task, because of a declaration in\n`task.payload`, and the service (index) is temporarily down. Don't use\nthis if a URL returns 404, but if it returns 503 or hits a timeout when\nyou retry the request, then this _may_ be a valid exception. The queue\nassumes that workers have applied retries as needed, and will not retry\n the task.\n**Report `internal-error`** if the worker experienced an unhandled internal\nerror from which it couldn't recover. The queue will not retry runs\nresolved with this reason, but you are clearly signaling that this is a\nbug in the worker code.\n**Report `superseded`** if the task was determined to have been\nsuperseded by another task, and its results are no longer needed.  It is\nconvention in this case to create an artifact entitled\n`public/superseded-by` containing the taskId of the task that superseded\nthis one.\n**Report `intermittent-task`** if the task explicitly requested a retry\nbecause task is intermittent. Workers can choose whether or not to\nsupport this, but workers shouldn't blindly report this for every task\nthat fails.\n",
          "enum": [
            "worker-shutdown",
            "malformed-payload",
            "resource-unavailable",
            "internal-error",
            "superseded",
            "intermittent-task"
          ],
          "type": "string"
        }
      },
      "required": [
        "reason"
      ],
      "title": "Task Exception Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that Taskcluster have failed to run a task.\n",
      "properties": {
        "runId": {
          "description": "Id of the last run for the task, not provided if `deadline`\nwas exceeded before a run was started.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the last attempt of the task\nran. Not provided, if `deadline` was exceeded before a run was started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the last worker that failed to report, causing the task\nto fail. Not provided, if `deadline` was exceeded before a run\nwas started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Exception Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-definition-and-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Task Definition and task status structure.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task.json#"
        }
      },
      "required": [
        "task",
        "status"
      ],
      "title": "Task definition and status",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-definition-and-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-defined-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has been defined. The task may or may not be\n_scheduled_ too.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Defined Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-defined-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-credentials.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Temporary credentials granting `task.scopes` and the scope:\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\nthe task, upload artifacts and report task resolution.\n\nThe temporary credentials are set to expire after `takenUntil`. They\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\ncoming close `takenUntil` won't have problems even if there is a little\nclock drift.\n\nWorkers should use these credentials when making requests on behalf of\na task. This includes requests to create artifacts, reclaiming the task\nreporting the task `completed`, `failed` or `exception`.\n\nNote, a new set of temporary credentials is issued when the worker\nreclaims the task.\n",
      "properties": {
        "accessToken": {
          "description": "The `accessToken` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        },
        "certificate": {
          "description": "The `certificate` for the temporary credentials, these are required\nfor the temporary credentials to work.\n",
          "minLength": 1,
          "type": "string"
        },
        "clientId": {
          "description": "The `clientId` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "certificate"
      ],
      "title": "Task Credentials",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-credentials.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-completed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that completed the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Completed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-completed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "task": {
          "$ref": "task.json#"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "task",
        "credentials"
      ],
      "title": "Task Claim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim (or reclaim) a task\n",
      "properties": {
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId"
      ],
      "title": "Task Claim Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/quarantine-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker's quarantineUntil property.\n",
      "properties": {
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        }
      },
      "required": [
        "quarantineUntil"
      ],
      "title": "Quarantine Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/quarantine-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/put-artifact-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Complete an aritifact",
      "properties": {
        "etags": {
          "description": "A list of the etags given by the API of the blob storage provider.  This is an opaque\nstring value provided by the API.\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "etags"
      ],
      "title": "Complete Artifact Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/put-artifact-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/provisioner-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this provisioner was seen active. `lastDateActive` is updated every 6 hours\nbut may be off by up-to 6 hours. Nonetheless, `lastDateActive` is a good indicator\nof when the provisioner was last seen active.\n",
          "format": "date-time",
          "title": "Provisioner Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provisioner ID",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "description",
        "actions",
        "stability",
        "expires",
        "lastDateActive"
      ],
      "title": "Provisioner Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/provisioner-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response to a request for posting an artifact.\nNote that the `storageType` property is referenced in the request as well.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Response to a request for creating a new blob artifact\n",
          "properties": {
            "expires": {
              "description": "Date-time after which the signed `requests` no longer work\n",
              "format": "date-time",
              "type": "string"
            },
            "requests": {
              "description": "A list of generalized HTTP requests which must be run to upload the\nartifact.\n",
              "items": {
                "additionalProperties": false,
                "properties": {
                  "headers": {
                    "additionalProperties": {
                      "type": "string"
                    },
                    "description": "Headers of request",
                    "type": "object"
                  },
                  "method": {
                    "description": "HTTP 1.1 method of request",
                    "enum": [
                      "GET",
                      "POST",
                      "PUT",
                      "DELETE",
                      "OPTIONS",
                      "HEAD",
                      "PATCH"
                    ],
                    "type": "string"
                  },
                  "url": {
                    "description": "URL of request",
                    "type": "string"
                  }
                },
                "required": [
                  "url",
                  "method",
                  "headers"
                ],
                "title": "HTTP Request",
                "type": "object"
              },
              "type": "array",
              "uniqueItems": true
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'blob'`\n",
              "enum": [
                "blob"
              ],
              "type": "string"
            }
          },
          "required": [
            "requests",
            "storageType",
            "expires"
          ],
          "title": "Blob Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for a signed PUT URL that will allow you to\nupload an artifact to an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, must be specified as header when uploading with\nthe signed `putUrl`.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the signed `putUrl` no longer works\n",
              "format": "date-time",
              "type": "string"
            },
            "putUrl": {
              "description": "URL to which a `PUT` request can be made to upload the artifact\nrequested. Note, the `Content-Length` must be specified correctly,\nand the `ContentType` header must be set the value specified below.\n",
              "format": "uri",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "putUrl",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for an Azure Shared Access Signature (SAS)\nthat will allow you to upload an artifact to an Azure blob storage\ncontainer managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, should be specified with the\n`x-ms-blob-content-type` when committing the block.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which Shared Access Signature (SAS) will\nseize to work.\n",
              "format": "date-time",
              "type": "string"
            },
            "putUrl": {
              "description": "Shared Access Signature (SAS) with write permissions, see\n[Azure REST API]\n(http://msdn.microsoft.com/en-US/library/azure/dn140256.aspx)\nreference for details on how to use this.\n",
              "format": "uri",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `azure`\n",
              "enum": [
                "azure"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType",
            "putUrl"
          ],
          "title": "Azure Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to redirect to a URL for a given\nartifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Redirect Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to reply `424` (Failed Dependency)\nwith `reason` and `message` to any `GET` request for this artifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Error Artifact Response",
          "type": "object"
        }
      ],
      "title": "Post Artifact Response"
    },
    "filename": "schemas/queue/v1/post-artifact-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Request a authorization to put and artifact or posting of a URL as an artifact. Note that the `storageType` property is referenced in the response as well.",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Request a list of requests in a generalized format which can be run to\nupload an artifact to storage managed by the queue.\n",
          "properties": {
            "contentEncoding": {
              "description": "Optionally provide an encoding type which should be set as the HTTP\nContent-Encoding header for this artifact.\n",
              "maxLength": 255,
              "type": "string"
            },
            "contentLength": {
              "description": "The number of bytes of the entire artifact.  This must be the number\nof bytes in the file to be uploaded.  For single part uploads, the\nupload will fail if the number of bytes uploaded does not match this\nvalue.  A single part upload (e.g. no parts list) may be at most 5GB.\nThis limit is enforced in the code because it is not possible to\nrepresent all of the restrictions in a json-schema.  A multipart\nupload may be at most 5TB, with each part other than the last being\nbetween 5MB and 5GB in size.\n",
              "minimum": 0,
              "type": "integer"
            },
            "contentSha256": {
              "description": "The complete SHA256 value of the entire artifact.  This must be the\nSHA256 of the file which is to be uploaded.  For single part uploads,\nthe upload will fail if the SHA256 value of what is uploaded does not\nmatch this value\n",
              "pattern": "^[a-fA-F0-9]{64}$",
              "type": "string"
            },
            "contentType": {
              "description": "Artifact mime-type, when uploading artifact to the signed\n`PUT` URL returned from this request this must given with the\n `ContentType` header. Please, provide correct mime-type,\n this make tooling a lot easier, specifically,\n always using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted. Note, that\nthese will be collected over time, and artifacts may remain\navailable after expiration. S3 based artifacts are identified in\nazure table storage and explicitly deleted on S3 after expiration.\n",
              "format": "date-time",
              "type": "string"
            },
            "parts": {
              "description": "A list of parts for a multipart upload.  The presence of this list is\nhow a multipart upload is differentiated from a single part upload.\nThe items in this list represent individual parts for upload.  For a\nmultipart upload, the sha256 values provided here must match the\nsha256 value that S3 internally computes for the upload to be\nconsidered a success.  The overall sha256 value is not checked\nexplicitly because the S3 API does not allow for that, but the same\ncode that is responsible for generating the parts hashes would also\nbe generating the overall hash, which makes this less of a concern.\nThe worst case is that we have artifacts which incorrectly do not\nvalidate, which is not as big of a security concern.\n",
              "items": {
                "additionalProperties": false,
                "properties": {
                  "sha256": {
                    "description": "The sha256 hash of the part.\n",
                    "maxLength": 64,
                    "minLength": 64,
                    "pattern": "^[a-fA-F0-9]{64}$",
                    "type": "string"
                  },
                  "size": {
                    "description": "The number of bytes in this part.  Keep in mind for S3 that\nall but the last part must be minimum 5MB and the maximum for\na single part is 5GB.  The overall size may not exceed 5TB\n",
                    "minimum": 0,
                    "type": "integer"
                  }
                },
                "required": [
                  "sha256",
                  "size"
                ],
                "title": "Multipart Part",
                "type": "object"
              },
              "minItems": 1,
              "type": "array",
              "uniqueItems": true
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'blob'`",
              "enum": [
                "blob"
              ],
              "type": "string"
            },
            "transferLength": {
              "description": "The number of bytes transfered across the wire to the backing\ndatastore.  If specified, it represents the post-content-encoding\nbyte count\n",
              "minimum": 0,
              "type": "integer"
            },
            "transferSha256": {
              "description": "This is the sha256 of the bytes transfered across the wire to the\nbacking datastore.  If specified, it represents the\npost-content-encoding sha256 value\n",
              "pattern": "^[a-fA-F0-9]{64}$",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType",
            "contentSha256",
            "contentLength"
          ],
          "title": "Blob Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request for a signed PUT URL that will allow you to upload an artifact\nto an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, when uploading artifact to the signed\n`PUT` URL returned from this request this must given with the\n `ContentType` header. Please, provide correct mime-type,\n this make tooling a lot easier, specifically,\n always using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted. Note, that\nthese will be collected over time, and artifacts may remain\navailable after expiration. S3 based artifacts are identified in\nazure table storage and explicitly deleted on S3 after expiration.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request for an Azure Shared Access Signature (SAS) that will allow\nyou to upload an artifact to an Azure blob storage container managed\nby the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, when uploading artifact please use the same\n`Content-Type`, consistently using the correct mime-type make\ntooling a lot easier, specifically, always using `application/json`\nfor JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted.\nNote, that these will be collected over time, and artifacts may\nremain available after expiration. Azure based artifacts are\nidentified in azure table storage and explicitly deleted in the\nazure storage container after expiration.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `azure`\n",
              "enum": [
                "azure"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType"
          ],
          "title": "Azure Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to redirect to a URL for a given artifact.\nThis allows you to reference artifacts that aren't managed by the queue.\nThe queue will still authenticate the request, so depending on the level\nof secrecy required, secret URLs **might** work. Note, this is mainly\nuseful for public artifacts, for example temporary files directly\nstored on the worker host and only available there for a specific\namount of time.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type for the resource to which the queue should\nredirect. Please use the same `Content-Type`, consistently using\nthe correct mime-type make tooling a lot easier, specifically,\nalways using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the queue should no longer redirect to this URL.\nNote, that the queue will and cannot delete the resource your URL\nreferences, you are responsible for doing that yourself.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            },
            "url": {
              "description": "URL to which the queue should redirect using a `303` (See other)\nredirect.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "url",
            "contentType"
          ],
          "title": "Redirect Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to reply `424` (Failed Dependency) with `reason` and \n`message` to any `GET` request for this artifact. This is mainly useful\nas a way for a task to declare that it failed to provide an artifact it\nwanted to upload.\n",
          "properties": {
            "expires": {
              "description": "Date-time after which the queue should stop replying with the error\nand forget about the artifact.\n",
              "format": "date-time",
              "type": "string"
            },
            "message": {
              "description": "Human readable explanation of why the artifact is missing\n",
              "maxLength": 4096,
              "type": "string"
            },
            "reason": {
              "description": "Reason why the artifact doesn't exist.\n",
              "enum": [
                "file-missing-on-worker",
                "invalid-resource-on-worker",
                "too-large-file-on-worker"
              ],
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "reason",
            "message"
          ],
          "title": "Error Artifact Request",
          "type": "object"
        }
      ],
      "title": "Post Artifact Request"
    },
    "filename": "schemas/queue/v1/post-artifact-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/poll-task-urls-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to request for poll task urls.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the signed URLs provided in this response\nexpires and not longer works for authentication.\n",
          "format": "date-time",
          "title": "Signed URL Expiration",
          "type": "string"
        },
        "queues": {
          "description": "List of signed URLs for queues to poll tasks from, they must be called\nin the order they are given. As the first entry in this array **may**\nhave higher priority.\n",
          "items": {
            "additionalProperties": false,
            "description": "Object holding two signed URLs for an azure queue, one for fetching\nmessages, and another for deleting messages. Remember to `claimTask`\nbefore deleting the message, and delete message even if the `claimTask`\noperation fails with a 400 status code. Don't delete it on other status\ncodes!\n",
            "properties": {
              "signedDeleteUrl": {
                "description": "Signed URL to delete messages that have been received using the\n`signedPollUrl`. You **must** do this to avoid receiving the same\nmessage again.\nTo use this URL you must substitute `{{messageId}}` and\n`{{popReceipt}}` with `MessageId` and `PopReceipt` from the XML\nresponse the `signedPollUrl` gave you. It is important that you\n`encodeURIComponent` both `MessageId` and `PopReceipt` prior to\nsubstitution, otherwise you will experience intermittent failures!\nNote this URL only works with `DELETE` request.\n",
                "pattern": "^https://",
                "title": "Signed Delete Message URL",
                "type": "string"
              },
              "signedPollUrl": {
                "description": "Signed URL to get message from the Azure Queue Storage queue,\nthat holds messages for the given `provisionerId` and `workerType`.\nNote that this URL returns XML, see documentation for the Azure\nQueue Storage\n[REST API](http://msdn.microsoft.com/en-us/library/azure/dd179474.aspx)\nfor details.\nWhen you have a message you can use `claimTask` to claim the task.\nYou will need to parse the XML response and base64 decode and\nJSON parse the `MessageText`.\nAfter you have called `claimTask` you **must** us the\n`signedDeleteUrl` to delete the message.\n**Remark**, you are allowed to append `&numofmessages=N`,\nwhere N < 32, to the URLs if you wish to obtain more than one\nmessage at the time.\n",
                "format": "uri",
                "title": "Signed Get Message URL",
                "type": "string"
              }
            },
            "required": [
              "signedPollUrl",
              "signedDeleteUrl"
            ],
            "title": "Signed URLs for a queue",
            "type": "object"
          },
          "title": "Queues To Poll From",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "queues",
        "expires"
      ],
      "title": "Poll Task Urls Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/poll-task-urls-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/pending-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for the number of pending tasks for a given\n`provisionerId` and `workerType`.\n",
      "properties": {
        "pendingTasks": {
          "description": "An approximate number of pending tasks for the given `provisionerId` and\n`workerType`. This is based on Azure Queue Storage metadata API, thus,\nnumber of reported here may be higher than actual number of pending tasks.\nBut there cannot be more pending tasks reported here. Ie. this is an\n**upper-bound** on the number of pending tasks.\n",
          "minimum": 0,
          "title": "Number of Pending Tasks",
          "type": "integer"
        },
        "provisionerId": {
          "description": "Unique identifier for the provisioner\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provisioner Id",
          "type": "string"
        },
        "workerType": {
          "description": "Identifier for worker type within the specified provisioner\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Type",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "pendingTasks"
      ],
      "title": "Count Pending Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/pending-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workertypes-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkerTypes` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the provisioner.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerTypes": {
          "description": "List of worker-types in this provisioner.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description of the worker-type.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Worker-type Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the worker-type was last seen active\n",
                "format": "date-time",
                "title": "Worker-type Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Provisioner ID",
                "type": "string"
              },
              "stability": {
                "description": "This is the stability of the worker-type. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              },
              "workerType": {
                "description": "WorkerType name.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "WorkerType name",
                "type": "string"
              }
            },
            "required": [
              "workerType",
              "provisionerId",
              "stability",
              "description",
              "expires",
              "lastDateActive"
            ],
            "title": "Worker Type",
            "type": "object"
          },
          "title": "WorkerTypes from the Provisioner",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerTypes"
      ],
      "title": "List Worker-Types Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workertypes-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workers-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkers` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-type.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of workers in this worker-type.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "firstClaim": {
                "description": "Date of the first time this worker claimed a task.\n",
                "format": "date-time",
                "title": "First task claimed",
                "type": "string"
              },
              "latestTask": {
                "$ref": "task-run.json#",
                "description": "The most recent claimed task\n",
                "title": "Most Recent Task"
              },
              "quarantineUntil": {
                "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
                "format": "date-time",
                "title": "Worker Quarantine",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for the worker group containing this worker.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for this worker (unique within this worker group).\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "workerGroup",
              "workerId",
              "firstClaim"
            ],
            "title": "Worker",
            "type": "object"
          },
          "title": "Workers from a WorkerType",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "List Workers Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workers-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-task-group-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listTaskGroup` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tasks in the task-group.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listTaskGroup` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks in this task-group.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks from the Task-Group",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskGroupId",
        "tasks"
      ],
      "title": "List Task-Group Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-task-group-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-provisioners-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "provisioners": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "actions": {
                "$ref": "actions.json#"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the provisioner created will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Provisioner Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the provisioner was last seen active\n",
                "format": "date-time",
                "title": "Provisioner Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Provisioner ID",
                "type": "string"
              },
              "stability": {
                "description": "This is the stability of the provisioner. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              }
            },
            "required": [
              "provisionerId",
              "description",
              "stability",
              "expires",
              "lastDateActive",
              "actions"
            ],
            "title": "Provisioner Information",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "provisioners"
      ],
      "title": "List Provisioners Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-provisioners-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-dependent-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listDependentTasks` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of dependent tasks.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listDependentTasks` with\n`continuationToken` until you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskId": {
          "description": "Identifier for the task whose dependents are being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks that have `taskId` in the `task.dependencies` property.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks that depend on `taskId`",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskId",
        "tasks"
      ],
      "title": "List Dependent Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-dependent-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-artifacts-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of artifacts for a given `taskId` and `runId`.\n",
      "properties": {
        "artifacts": {
          "description": "List of artifacts for given `taskId` and `runId`.\n",
          "items": {
            "additionalProperties": false,
            "description": "Information about an artifact for the given `taskId` and `runId`.\n",
            "properties": {
              "contentType": {
                "description": "Mimetype for the artifact that was created.\n",
                "maxLength": 255,
                "title": "Content-Type",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Artifact Expiration",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact.\n",
                "maxLength": 1024,
                "title": "Artifact Name",
                "type": "string"
              },
              "storageType": {
                "description": "This is the `storageType` for the request that was used to create\nthe artifact.\n",
                "enum": [
                  "blob",
                  "s3",
                  "azure",
                  "reference",
                  "error"
                ],
                "title": "Artifact Storage-Type",
                "type": "string"
              }
            },
            "required": [
              "storageType",
              "name",
              "expires",
              "contentType"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifact List",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of artifacts.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "artifacts"
      ],
      "title": "List Artifacts Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-artifacts-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/create-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "$ref": "task.json#/properties/dependencies",
          "default": [
          ]
        },
        "expires": {
          "$ref": "task.json#/properties/expires"
        },
        "extra": {
          "$ref": "task.json#/properties/extra",
          "default": {
          }
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "$ref": "task.json#/properties/payload",
          "default": [
          ]
        },
        "priority": {
          "$ref": "task.json#/properties/priority",
          "default": "lowest"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "requires": {
          "$ref": "task.json#/properties/requires",
          "default": "all-completed"
        },
        "retries": {
          "$ref": "task.json#/properties/retries",
          "default": 5
        },
        "routes": {
          "$ref": "task.json#/properties/routes",
          "default": [
          ]
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "scopes": {
          "$ref": "task.json#/properties/scopes",
          "default": [
          ]
        },
        "tags": {
          "$ref": "task.json#/properties/tags",
          "default": {
          }
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "created",
        "deadline",
        "payload",
        "metadata"
      ],
      "title": "Task Definition Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/create-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to an attempt to claim tasks for a worker to process.\n",
      "properties": {
        "tasks": {
          "description": "List of task claims, may be empty if no tasks was claimed, in which case\nthe worker should sleep a tiny bit before polling again.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "credentials": {
                "$ref": "task-credentials.json#"
              },
              "runId": {
                "description": "`run-id` assigned to this run of the task\n",
                "maximum": 1000,
                "minimum": 0,
                "type": "integer"
              },
              "status": {
                "$ref": "task-status.json#"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
                "format": "date-time",
                "type": "string"
              },
              "task": {
                "$ref": "task.json#"
              },
              "workerGroup": {
                "description": "Identifier for the worker-group within which this run started.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for the worker executing this run.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "status",
              "runId",
              "workerGroup",
              "workerId",
              "takenUntil",
              "task",
              "credentials"
            ],
            "title": "Task Claim",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "Claim Work Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim a task for a worker to process.\n",
      "properties": {
        "tasks": {
          "default": 1,
          "description": "Number of tasks to attempt to claim.\n",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId",
        "tasks"
      ],
      "title": "Claim Work Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/artifact-created-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting a new artifact has been created for a given task.\n",
      "properties": {
        "artifact": {
          "additionalProperties": false,
          "description": "Information about the artifact that was created\n",
          "properties": {
            "contentType": {
              "description": "Mimetype for the artifact that was created.\n",
              "maxLength": 255,
              "title": "Content-Type",
              "type": "string"
            },
            "expires": {
              "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
              "format": "date-time",
              "title": "Artifact Expiration",
              "type": "string"
            },
            "name": {
              "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact. But keep in mind that just because an\nartifact is created doesn't mean that it's immediately available.\n",
              "maxLength": 1024,
              "title": "Artifact Name",
              "type": "string"
            },
            "storageType": {
              "description": "This is the `storageType` for the request that was used to create the\nartifact.\n",
              "enum": [
                "blob",
                "reference",
                "error"
              ],
              "title": "Artifact Storage-Type",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "name",
            "expires",
            "contentType"
          ],
          "title": "Artifact",
          "type": "object"
        },
        "runId": {
          "description": "Id of the run on which artifact was created.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the run with the created\nartifacted is running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker within which the run with the created artifact\nis running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "artifact"
      ],
      "title": "Artifact Created Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/artifact-created-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/actions.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "See taskcluster [actions](/docs/reference/platform/taskcluster-queue/docs/actions) documentation.\n",
      "items": {
        "additionalProperties": false,
        "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
        "properties": {
          "context": {
            "description": "Actions have a \"context\" that is one of provisioner, worker-type, or worker, indicating\nwhich it applies to. `context` is used by the front-end to know where to display the action.\n\n| `context`   | Page displayed        |\n|-------------|-----------------------|\n| provisioner | Provisioner Explorer  |\n| worker-type | Workers Explorer      |\n| worker      | Worker Explorer       |\n",
            "enum": [
              "provisioner",
              "worker-type",
              "worker"
            ],
            "title": "Context",
            "type": "string"
          },
          "description": {
            "description": "Description of the provisioner.\n",
            "title": "Description",
            "type": "string"
          },
          "method": {
            "description": "Method to indicate the desired action to be performed for a given resource.\n",
            "enum": [
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "title": "Method",
            "type": "string"
          },
          "name": {
            "description": "Short names for things like logging/error messages.\n",
            "title": "Name",
            "type": "string"
          },
          "title": {
            "description": "Appropriate title for any sort of Modal prompt.\n",
            "title": "Title"
          },
          "url": {
            "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
            "title": "URL",
            "type": "string"
          }
        },
        "required": [
          "name",
          "title",
          "context",
          "url",
          "method",
          "description"
        ],
        "title": "Action",
        "type": "object"
      },
      "title": "Actions",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/queue/v1/actions.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-requests.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A list of Purge Cache requests that the Purge Cache service has previously received.\n",
      "items": {
        "additionalProperties": false,
        "description": "An entry in a list of Purge Cache Requests that the Purge Cache service has previously received.\n",
        "properties": {
          "before": {
            "description": "All caches that match this provisionerId, workerType, and cacheName must be destroyed if they were created _before_ this time.\n",
            "format": "date-time",
            "type": "string"
          },
          "cacheName": {
            "description": "Name of cache to purge.",
            "type": "string"
          },
          "provisionerId": {
            "description": "ProvisionerId associated with the workerType.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          },
          "workerType": {
            "description": "Workertype cache exists on.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          }
        },
        "required": [
          "provisionerId",
          "workerType",
          "cacheName",
          "before"
        ],
        "title": "Purge Cache Requests Entry",
        "type": "object"
      },
      "title": "Purge Cache Requests",
      "type": "array",
      "uniqueItems": false
    },
    "filename": "schemas/purge-cache/v1/purge-cache-requests.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request that a message be published to purge a specific cache.\n",
      "properties": {
        "cacheName": {
          "description": "Name of cache to purge. Notice that if a `workerType` have multiple kinds\nof caches (with independent names), it should purge all caches identified\nby `cacheName` regardless of cache type.\n",
          "type": "string"
        }
      },
      "required": [
        "cacheName"
      ],
      "title": "Purge Cache Request",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests.\n",
      "properties": {
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open Purge Request List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/all-purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests. Should not be used by workers.\n",
      "properties": {
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        },
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open All Purge Requests List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/all-purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/pulse-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to post a message on pulse.\n",
      "properties": {
        "message": {
          "description": "Pulse message to send as plain text.\n",
          "type": "object"
        },
        "routingKey": {
          "description": "Routing-key to use when posting the message.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "required": [
        "routingKey",
        "message"
      ],
      "title": "Post Pulse Message Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/pulse-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "This can be pretty much anything you want it to be.\n",
      "properties": {
        "message": {
          "description": "Arbitrary message.\n",
          "title": "Message",
          "type": "object"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "message"
      ],
      "title": "Notification Message",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-message.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Type of notification and its corresponding address.\n",
      "properties": {
        "notificationAddress": {
          "type": "string"
        },
        "notificationType": {
          "enum": [
            "email",
            "pulse",
            "irc-user",
            "irc-channel"
          ],
          "type": "string"
        }
      },
      "required": [
        "notificationType",
        "notificationAddress"
      ],
      "title": "Notification Type And Address",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of notification addresses.\n",
      "properties": {
        "addresses": {
          "items": {
            "$ref": "notification-address.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "addresses"
      ],
      "title": "List of notification adresses",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address-list.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/irc-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "message": {
          "description": "IRC message to send as plain text.\n",
          "maxLength": 510,
          "minLength": 1,
          "title": "IRC Message Text",
          "type": "string"
        }
      },
      "description": "Request to post a message on IRC.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "channel": {
              "description": "Channel to post the message in.\n",
              "minLength": 1,
              "pattern": "^[#&][^ ,\\u0007]{1,199}$",
              "title": "Channel Name",
              "type": "string"
            },
            "message": {
              "$ref": "#/definitions/message"
            }
          },
          "required": [
            "channel",
            "message"
          ],
          "title": "Channel Message",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "$ref": "#/definitions/message"
            },
            "user": {
              "description": "User to post the message to.\n",
              "maxLength": 255,
              "minLength": 1,
              "pattern": "^[A-Za-z\\[\\]\\\\~_\\^{|}][A-Za-z0-9\\-\\[\\]\\\\~_\\^{|}]{0,254}$",
              "title": "IRC Handle",
              "type": "string"
            }
          },
          "required": [
            "user",
            "message"
          ],
          "title": "Private Message",
          "type": "object"
        }
      ],
      "title": "Post IRC Message Request"
    },
    "filename": "schemas/notify/v1/irc-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/email-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to send an email\n",
      "properties": {
        "address": {
          "description": "E-mail address to which the message should be sent\n",
          "format": "email",
          "type": "string"
        },
        "content": {
          "description": "Content of the e-mail as **markdown**, will be rendered to HTML before\nthe email is sent. Notice that markdown allows for a few HTML tags, but\nwon't allow inclusion of script tags and other unpleasantries.\n",
          "maxLength": 102400,
          "minLength": 1,
          "type": "string"
        },
        "link": {
          "additionalProperties": false,
          "description": "Optional link that can be added as a button to the email.\n",
          "properties": {
            "href": {
              "description": "Where the link should point to.\n",
              "format": "uri",
              "maxLength": 1024,
              "minLength": 1,
              "type": "string"
            },
            "text": {
              "description": "Text to display on link.\n",
              "maxLength": 40,
              "minLength": 1,
              "type": "string"
            }
          },
          "required": [
            "text",
            "href"
          ],
          "type": "object"
        },
        "replyTo": {
          "description": "Reply-to e-mail (this property is optional)\n",
          "format": "email",
          "type": "string"
        },
        "subject": {
          "description": "Subject line of the e-mail, this is plain-text\n",
          "maxLength": 255,
          "minLength": 1,
          "type": "string"
        },
        "template": {
          "default": "simple",
          "description": "E-mail html template used to format your content.\n",
          "enum": [
            "simple",
            "fullscreen"
          ],
          "type": "string"
        }
      },
      "required": [
        "address",
        "subject",
        "content"
      ],
      "title": "Send Email Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/email-request.json"
  },
  {
    "content": {
      "$id": "/schemas/login/v1/oidc-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A response containing credentials corresponding to a supplied OIDC `access_token`.\n",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "Taskcluster credentials. Note that the credentials may not contain a certificate!\n",
          "properties": {
            "accessToken": {
              "pattern": "^[a-zA-Z0-9_-]{22,66}$",
              "type": "string"
            },
            "certificate": {
              "type": "string"
            },
            "clientId": {
              "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
              "type": "string"
            }
          },
          "required": [
            "clientId",
            "accessToken"
          ],
          "title": "Taskcluster Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Time after which the credentials are no longer valid.  Callers should\ncall `oidcCredentials` again to get fresh credentials before this time.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "expires",
        "credentials"
      ],
      "title": "Credentials Response",
      "type": "object"
    },
    "filename": "schemas/login/v1/oidc-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a task.\n",
            "properties": {
              "data": {
                "description": "Data that was reported with the task. This is an arbitrary JSON\nobject.\n",
                "title": "Task Specific Data",
                "type": "object"
              },
              "expires": {
                "description": "Date at which this entry expires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "namespace": {
                "description": "Index path of the task.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              },
              "rank": {
                "description": "If multiple tasks are indexed with the same `namespace` the task\nwith the highest `rank` will be stored and returned in later\nrequests. If two tasks has the same `rank` the latest task will be\nstored.\n",
                "title": "Rank",
                "type": "number"
              },
              "taskId": {
                "description": "Unique task identifier for the task currently indexed at `namespace`.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "taskId",
              "rank",
              "data",
              "expires"
            ],
            "title": "Task",
            "type": "object"
          },
          "title": "Tasks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "List Tasks Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "namespaces": {
          "description": "List of namespaces.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a namespace that contains indexed tasks.\n",
            "properties": {
              "expires": {
                "description": "Date at which this entry, and by implication all entries below it,\nexpires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "name": {
                "description": "Name of namespace within it's parent namespace.\n",
                "title": "Name",
                "type": "string"
              },
              "namespace": {
                "description": "Fully qualified name of the namespace, you can use this to list\nnamespaces or tasks under this namespace.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "name",
              "expires"
            ],
            "title": "Namespace",
            "type": "object"
          },
          "title": "Namespaces",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "namespaces"
      ],
      "title": "List Namespaces Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token previously returned in a response to this list\nrequest. This property is optional and should not be provided for first\nrequests.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "limit": {
          "default": 1000,
          "description": "Maximum number of results per page. If there are more results than this\na continuation token will be return.\n",
          "maximum": 1000,
          "minimum": 1,
          "title": "Result limit",
          "type": "integer"
        }
      },
      "required": [
      ],
      "title": "List Namespaces Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/insert-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of the index entry to insert.\n",
      "properties": {
        "data": {
          "description": "This is an arbitrary JSON object. Feel free to put whatever data you want\nhere, but do limit it, you'll get errors if you store more than 32KB.\nSo stay well, below that limit.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Insert Task Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/insert-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/indexed-task-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "data": {
          "description": "Data that was reported with the task. This is an arbitrary JSON object.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the indexed task, used to find the indexed task in the index.\n",
          "maxLength": 255,
          "title": "Namespace",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "namespace",
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Indexed Task Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/indexed-task-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Secret token for a trigger\n",
      "properties": {
        "token": {
          "title": "Token",
          "type": "string"
        }
      },
      "required": [
        "token"
      ],
      "title": "trigger token response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A request to trigger a hook.  The payload must be a JSON object, and is used as the context\nfor a JSON-e rendering of the hook's task template, as described in \"Firing Hooks\".\n",
      "title": "Trigger Hook Request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-hook.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "anyOf": [
        {
          "$ref": "task-status.json#"
        },
        {
          "additionalProperties": false,
          "description": "Empty response indicating no task was created",
          "properties": {
          },
          "required": [
          ],
          "type": "object"
        }
      ],
      "description": "Response to a `triggerHook` or `triggerHookWithToken` call.\n\nIn most cases, this is a task status, but in cases where the hook template\ndoes not generate a task, it is an empty object with no `status` property.\n",
      "title": "Trigger Hook Response"
    },
    "filename": "schemas/hooks/v1/trigger-hook-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/task-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A representation of **task status** as known by the queue\n",
      "properties": {
        "status": {
          "additionalProperties": false,
          "properties": {
            "deadline": {
              "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
              "format": "date-time",
              "title": "Deadline",
              "type": "string"
            },
            "expires": {
              "description": "Task expiration, time at which task definition and\nstatus is deleted. Notice that all artifacts for the task\nmust have an expiration that is no later than this.\n",
              "format": "date-time",
              "title": "Expiration",
              "type": "string"
            },
            "provisionerId": {
              "description": "Unique identifier for the provisioner that this task must be scheduled on\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Provisioner Id",
              "type": "string"
            },
            "retriesLeft": {
              "description": "Number of retries left for the task in case of infrastructure issues\n",
              "maximum": 999,
              "minimum": 0,
              "title": "Retries Left",
              "type": "integer"
            },
            "runs": {
              "description": "List of runs, ordered so that index `i` has `runId == i`\n",
              "items": {
                "additionalProperties": false,
                "description": "JSON object with information about a run\n",
                "properties": {
                  "reasonCreated": {
                    "description": "Reason for the creation of this run,\n**more reasons may be added in the future**.\n",
                    "enum": [
                      "scheduled",
                      "retry",
                      "task-retry",
                      "rerun",
                      "exception"
                    ],
                    "title": "Reason Created",
                    "type": "string"
                  },
                  "reasonResolved": {
                    "description": "Reason that run was resolved, this is mainly\nuseful for runs resolved as `exception`.\nNote, **more reasons may be added in the future**, also this\nproperty is only available after the run is resolved.\n",
                    "enum": [
                      "completed",
                      "failed",
                      "deadline-exceeded",
                      "canceled",
                      "superseded",
                      "claim-expired",
                      "worker-shutdown",
                      "malformed-payload",
                      "resource-unavailable",
                      "internal-error",
                      "intermittent-task"
                    ],
                    "title": "Reason Resolved",
                    "type": "string"
                  },
                  "resolved": {
                    "description": "Date-time at which this run was resolved, ie. when the run changed\nstate from `running` to either `completed`, `failed` or `exception`.\nThis property is only present after the run as been resolved.\n",
                    "format": "date-time",
                    "title": "Resolved",
                    "type": "string"
                  },
                  "runId": {
                    "description": "Id of this task run, `run-id`s always starts from `0`\n",
                    "maximum": 1000,
                    "minimum": 0,
                    "title": "Run Identifier",
                    "type": "integer"
                  },
                  "scheduled": {
                    "description": "Date-time at which this run was scheduled, ie. when the run was\ncreated in state `pending`.\n",
                    "format": "date-time",
                    "title": "Scheduled",
                    "type": "string"
                  },
                  "started": {
                    "description": "Date-time at which this run was claimed, ie. when the run changed\nstate from `pending` to `running`. This property is only present\nafter the run has been claimed.\n",
                    "format": "date-time",
                    "title": "Started",
                    "type": "string"
                  },
                  "state": {
                    "description": "State of this run\n",
                    "enum": [
                      "pending",
                      "running",
                      "completed",
                      "failed",
                      "exception"
                    ],
                    "title": "Run State",
                    "type": "string"
                  },
                  "takenUntil": {
                    "description": "Time at which the run expires and is resolved as `failed`, if the\nrun isn't reclaimed. Note, only present after the run has been\nclaimed.\n",
                    "format": "date-time",
                    "title": "Taken Until",
                    "type": "string"
                  },
                  "workerGroup": {
                    "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\nNote, this property is only present after the run is claimed.\n",
                    "maxLength": 38,
                    "minLength": 1,
                    "pattern": "^([a-zA-Z0-9-_]*)$",
                    "title": "Worker Group",
                    "type": "string"
                  },
                  "workerId": {
                    "description": "Identifier for worker evaluating this run within given\n`workerGroup`. Note, this property is only available after the run\nhas been claimed.\n",
                    "maxLength": 38,
                    "minLength": 1,
                    "pattern": "^([a-zA-Z0-9-_]*)$",
                    "title": "Worker Identifier",
                    "type": "string"
                  }
                },
                "required": [
                  "runId",
                  "state",
                  "reasonCreated",
                  "scheduled"
                ],
                "title": "Run Information",
                "type": "object"
              },
              "title": "List of Runs",
              "type": "array",
              "uniqueItems": false
            },
            "schedulerId": {
              "description": "Identifier for the scheduler that _defined_ this task.\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Scheduler Identifier",
              "type": "string"
            },
            "state": {
              "description": "State of this task. This is just an auxiliary property derived from state\nof latests run, or `unscheduled` if none.\n",
              "enum": [
                "unscheduled",
                "pending",
                "running",
                "completed",
                "failed",
                "exception"
              ],
              "title": "State",
              "type": "string"
            },
            "taskGroupId": {
              "description": "Identifier for a group of tasks scheduled together with this task, by\nscheduler identified by `schedulerId`. For tasks scheduled by the\ntask-graph scheduler, this is the `taskGraphId`.\n",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Task-Group Identifier",
              "type": "string"
            },
            "taskId": {
              "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Task Identifier",
              "type": "string"
            },
            "workerType": {
              "description": "Identifier for worker type within the specified provisioner\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Worker Type",
              "type": "string"
            }
          },
          "required": [
            "taskId",
            "provisionerId",
            "workerType",
            "schedulerId",
            "taskGroupId",
            "deadline",
            "expires",
            "retriesLeft",
            "state",
            "runs"
          ],
          "type": "object"
        }
      },
      "required": [
        "status"
      ],
      "title": "Task Status Structure",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/task-status.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/schedule.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "default": [
      ],
      "description": "A list of cron-style definitions to represent a set of moments in (UTC) time.\nIf several patterns are specified, a given moment in time represented by\nmore than one pattern is considered only to be counted once, in other words\nit is allowed for the cron patterns to overlap; duplicates are redundant.\n",
      "items": {
        "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\n",
        "title": "Cron Pattern",
        "type": "string"
      },
      "title": "Schedule",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/schedule.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/pulse-hook-changed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "Message reporting that a hook has changed\n",
      "properties": {
        "hookGroupId": {
          "description": "`hookGroupId` of the hook that was changed\n",
          "type": "string"
        },
        "hookId": {
          "description": "`hookId` of the hook that was changed\n",
          "type": "string"
        }
      },
      "required": [
        "hookId",
        "hookGroupId"
      ],
      "title": "Hook Changed Message",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/pulse-hook-changed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-lastFires-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of lastFires\n",
      "properties": {
        "lastFires": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "error": {
                "description": "The error that occurred when firing the task. This is typically,\nbut not always, an API error message.\n",
                "type": "string"
              },
              "firedBy": {
                "enum": [
                  "schedule",
                  "triggerHook",
                  "triggerHookWithToken",
                  "pulseMessage"
                ],
                "type": "string"
              },
              "hookGroupId": {
                "maxLength": 64,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "hookId": {
                "maxLength": 64,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_/]*)$",
                "type": "string"
              },
              "result": {
                "description": "Information about success or failure of firing of the hook",
                "enum": [
                  "success",
                  "error"
                ],
                "type": "string"
              },
              "taskCreateTime": {
                "description": "Time when the task was created",
                "format": "date-time",
                "type": "string"
              },
              "taskId": {
                "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "hookGroupId",
              "hookId",
              "taskId",
              "firedBy",
              "taskCreateTime",
              "result",
              "error"
            ],
            "type": "object"
          },
          "title": "LastFires",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "lastFires"
      ],
      "title": "LastFires list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-lastFires-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hooks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of hooks\n",
      "properties": {
        "hooks": {
          "items": {
            "$ref": "hook-definition.json#"
          },
          "title": "Hooks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "hooks"
      ],
      "title": "Hook list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hooks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hook-groups-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of `hookGroupIds`.\n",
      "properties": {
        "groups": {
          "items": {
            "type": "string"
          },
          "title": "Groups",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "groups"
      ],
      "title": "Hook groups",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hook-groups-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A snapshot of the current status of a hook.\n",
      "properties": {
        "lastFire": {
          "description": "Information about the last time this hook fired.  This property is only present\nif the hook has fired at least once.\n",
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Information about a successful firing of the hook",
              "properties": {
                "result": {
                  "enum": [
                    "success"
                  ],
                  "type": "string"
                },
                "taskId": {
                  "description": "The task created",
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "taskId",
                "time"
              ],
              "title": "Successful Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about an unsuccessful firing of the hook",
              "properties": {
                "error": {
                  "description": "The error that occurred when firing the task.  This is typically,\nbut not always, an API error message.\n",
                  "type": "object"
                },
                "result": {
                  "enum": [
                    "error"
                  ],
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "error",
                "time"
              ],
              "title": "Failed Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about no firing of the hook (e.g., a new hook)",
              "properties": {
                "result": {
                  "enum": [
                    "no-fire"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "result"
              ],
              "title": "No Fire",
              "type": "object"
            }
          ]
        },
        "nextScheduledDate": {
          "description": "The next time this hook's task is scheduled to be created. This property\nis only present if there is a scheduled next time. Some hooks don't have\nany schedules.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "lastFire"
      ],
      "title": "Hook status response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-status.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "description": {
          "description": "Long-form of the hook's purpose and behavior",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "emailOnError": {
          "default": true,
          "description": "Whether to email the owner on an error creating the task.",
          "title": "Email on error",
          "type": "boolean"
        },
        "name": {
          "description": "Human readable name of the hook",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "Email of the person or group responsible for this hook.",
          "format": "email",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner"
      ],
      "title": "Hook Metadata",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-definition.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that will create tasks when defined events occur.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "$ref": "schedule.json#"
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://taskcluster.github.io/json-e/)\nas described in [firing hooks](/docs/reference/core/taskcluster-hooks/docs/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "type": "object"
        }
      },
      "required": [
        "hookGroupId",
        "hookId",
        "metadata",
        "task",
        "schedule",
        "triggerSchema"
      ],
      "title": "Hook definition",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-definition.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/create-hook-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that can create tasks at defined times.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "default": [
          ],
          "description": "Definition of the times at which a hook will result in creation of a task.\nIf several patterns are specified, tasks will be created at any time\nspecified by one or more patterns.\n",
          "items": {
            "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\nNote that tasks may not be created at exactly the time specified.\n",
            "title": "Cron Pattern",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://taskcluster.github.io/json-e/)\nas described in [firing hooks](/docs/reference/core/taskcluster-hooks/docs/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "default": {
            "additionalProperties": false,
            "type": "object"
          },
          "type": "object"
        }
      },
      "required": [
        "metadata",
        "task"
      ],
      "title": "Hook creation request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/create-hook-request.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/bindings.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "items": {
        "additionalProperties": false,
        "description": "Exchange and RoutingKeyPattern for each binding\n",
        "properties": {
          "exchange": {
            "minLength": 1,
            "type": "string"
          },
          "routingKeyPattern": {
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "exchange",
          "routingKeyPattern"
        ],
        "title": "Binding",
        "type": "object"
      },
      "title": "List of Bindings",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/bindings.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.v1.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v1, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "policy": {
          "pullRequests": {
            "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
            "enum": [
              "public",
              "collaborators"
            ],
            "type": "string"
          }
        },
        "reporting": {
          "description": "Policy for reporting status of PR or a commit. If absent, Github Statuses API is used",
          "enum": [
            "checks-v1"
          ],
          "type": "string"
        },
        "tasks": {
          "default": [
          ],
          "description": "Definitions of tasks that can be scheduled. Rendered with JSON-e\n",
          "oneOf": [
            {
              "description": "Each element of this should evaluate to a task definition via json-e",
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "type": "array",
              "uniqueItems": false
            },
            {
              "additionalProperties": true,
              "description": "This must evaluate to an array via json-e i.e. `$flatten`",
              "type": "object"
            }
          ],
          "title": "Task definition template\""
        },
        "version": {
          "description": "Version of the format of this file; must be 1",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.v1.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v0, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "allowPullRequests": {
          "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
          "enum": [
            "public",
            "collaborators"
          ],
          "type": "string"
        },
        "metadata": {
          "additionalProperties": false,
          "description": "Required task graph metadata",
          "properties": {
            "description": {
              "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
              "maxLength": 32768,
              "title": "Description",
              "type": "string"
            },
            "name": {
              "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
              "maxLength": 255,
              "title": "Name",
              "type": "string"
            },
            "owner": {
              "description": "E-mail of person who caused this task, e.g. the person who did\n`hg push`. The person we should contact to ask why this task is here.\n",
              "maxLength": 255,
              "title": "Owner",
              "type": "string"
            },
            "source": {
              "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
              "maxLength": 4096,
              "title": "Source",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description",
            "owner",
            "source"
          ],
          "type": "object"
        },
        "tasks": {
          "default": [
          ],
          "items": {
            "additionalProperties": true,
            "description": "Definition of a task that can be scheduled\n",
            "properties": {
              "created": {
                "default": "{{ $fromNow }}",
                "description": "Creation time of task",
                "title": "Created",
                "type": "string"
              },
              "deadline": {
                "default": "{{ '1 day' | $fromNow }}",
                "description": "Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline",
                "title": "Deadline",
                "type": "string"
              }
            },
            "required": [
            ],
            "title": "Task Definition",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "version": {
          "description": ".taskcluster.yml version",
          "enum": [
            0
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/task-group-creation-requested.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Indicates that this service has created a new task group in response to a GitHub event.\nThis message is for internal use only and should not be relied on for other purposes.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "taskGroupId": {
          "description": "The id of the taskGroup that had been created.",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "taskGroupId",
        "organization",
        "repository",
        "version"
      ],
      "title": "Task Group Defined - Create Status",
      "type": "object"
    },
    "filename": "schemas/github/v1/task-group-creation-requested.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/repository.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Any Taskcluster-specific Github repository information.\n",
      "properties": {
        "installed": {
          "description": "True if integration is installed, False otherwise.\n",
          "type": "boolean"
        }
      },
      "required": [
        "installed"
      ],
      "title": "Repository Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/repository.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-release-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub release has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the release (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Release Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-release-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-push-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub push has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the push (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maxLength": 10000000000,
          "minLength": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Push Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-push-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-pull-request-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub pull request has occurred\n",
      "properties": {
        "action": {
          "description": "The GitHub `action` which triggered an event.\n",
          "enum": [
            "assigned",
            "unassigned",
            "labeled",
            "unlabeled",
            "opened",
            "edited",
            "closed",
            "reopened",
            "synchronize",
            "review_requested",
            "review_request_removed"
          ]
        },
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the pull request (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "action",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Pull Request Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-pull-request-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Create a commit status on GitHub.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "context": {
          "description": "A string label to differentiate this status from the status of other systems.",
          "type": "string"
        },
        "description": {
          "description": "A short description of the status.",
          "type": "string"
        },
        "state": {
          "description": "The state of the status.",
          "enum": [
            "pending",
            "success",
            "error",
            "failure"
          ],
          "type": "string"
        },
        "target_url": {
          "description": "The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the 'source' of the Status.",
          "type": "string"
        }
      },
      "required": [
        "state"
      ],
      "title": "Create Status Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-status.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-comment.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Write a new comment on a GitHub Issue or Pull Request.\nFull specification on [GitHub docs](https://developer.github.com/v3/issues/comments/#create-a-comment)\n",
      "properties": {
        "body": {
          "description": "The contents of the comment.",
          "type": "string"
        }
      },
      "required": [
        "body"
      ],
      "title": "Create Comment Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-comment.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/build-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A paginated list of builds\n",
      "properties": {
        "builds": {
          "description": "A simple list of builds.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "created": {
                "description": "The initial creation time of the build. This is when it became pending.\n",
                "format": "date-time",
                "type": "string"
              },
              "eventId": {
                "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
                "oneOf": [
                  {
                    "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
                    "title": "Github GUID",
                    "type": "string"
                  },
                  {
                    "enum": [
                      "Unknown"
                    ],
                    "title": "Unknown Github GUID",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "eventType": {
                "description": "Type of Github event that triggered the build (i.e. push, pull_request.opened).",
                "type": "string"
              },
              "organization": {
                "description": "Github organization associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "repository": {
                "description": "Github repository associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "sha": {
                "description": "Github revision associated with the build.",
                "maxLength": 40,
                "minLength": 40,
                "type": "string"
              },
              "state": {
                "description": "Github status associated with the build.",
                "enum": [
                  "pending",
                  "success",
                  "error",
                  "failure"
                ],
                "type": "string"
              },
              "taskGroupId": {
                "description": "Taskcluster task-group associated with the build.",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "type": "string"
              },
              "updated": {
                "description": "The last updated of the build. If it is done, this is when it finished.\n",
                "format": "date-time",
                "type": "string"
              }
            },
            "required": [
              "organization",
              "repository",
              "sha",
              "state",
              "taskGroupId",
              "eventType",
              "eventId",
              "created",
              "updated"
            ],
            "title": "Build",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        }
      },
      "required": [
        "builds"
      ],
      "title": "Builds Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/build-list.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metaschema.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "allOf": [
        {
          "$ref": "http://json-schema.org/draft-06/schema#"
        },
        {
          "$ref": "#/definitions/schema"
        }
      ],
      "definitions": {
        "recurse": {
          "properties": {
            "additionalItems": {
              "$ref": "#/definitions/schema"
            },
            "additionalProperties": {
              "$ref": "#/definitions/schema"
            },
            "allOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "anyOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "contains": {
              "$ref": "#/definitions/schema"
            },
            "definitions": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "dependencies": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/schema"
                  },
                  {
                    "$ref": "http://json-schema.org/draft-06/schema#/definitions/stringArray"
                  }
                ]
              }
            },
            "items": {
              "anyOf": [
                {
                  "$ref": "#/definitions/schema"
                },
                {
                  "$ref": "#/definitions/schemaArray"
                }
              ]
            },
            "not": {
              "$ref": "#/definitions/schema"
            },
            "oneOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "patternProperties": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "properties": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "propertyNames": {
              "$ref": "#/definitions/schema"
            }
          }
        },
        "requiredProperties": {
          "dependencies": {
            "items": [
              "type",
              "uniqueItems"
            ],
            "properties": [
              "type",
              "additionalProperties",
              "required"
            ]
          }
        },
        "schema": {
          "allOf": [
            {
              "$ref": "#/definitions/recurse"
            },
            {
              "$ref": "#/definitions/requiredProperties"
            }
          ]
        },
        "schemaArray": {
          "items": {
            "$ref": "#/definitions/schema"
          },
          "type": "array",
          "uniqueItems": false
        }
      },
      "description": "This is a refinement of JSON-schema, with the following changes:\n\n  * if `properties` is present, `type` and `additionalProperties` must be present, too\n  * if `entries` is present, `type` and `uniqueItems` must be present, too\n\nNote that any schema that validates against this metaschema will also\nvalidate against the upstream draft-06 metaschema, and is usable by any\nJSON-schema tool.\n",
      "title": "Taskcluster JSON-Schema Meta-Schema, with some stricter validation"
    },
    "filename": "schemas/common/metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metadata-metaschema.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "allOf": [
        {
          "$ref": "./metaschema.json#"
        },
        {
          "$ref": "#/definitions/topLevelMetadata"
        }
      ],
      "definitions": {
        "topLevelMetadata": {
          "additionalProperties": true,
          "properties": {
            "metadata": {
              "additionalProperties": false,
              "description": "Metadata identifying the documents that the schema document describes,\ngiving both a name (a category of document) and a version (to allow\nseveral versions of the same category).  Consumers of the documents can\nconsult the schema metadata to determine how to process the document.\n\nAny changes to a schema that require changes to consumers of the described\ndocuments should be accompanied by a version increase.\n",
              "properties": {
                "name": {
                  "description": "This is used to identify the category of document for later consumption.\nIt is also used to determine schema id's.  Common values for Taskcluster\nreferences are `manifest`, `exchanges`, and `api`.\n",
                  "title": "Name of the document category",
                  "type": "string"
                },
                "version": {
                  "title": "Version of the document format",
                  "type": "integer"
                }
              },
              "required": [
                "version",
                "name"
              ],
              "title": "Metadata for this schema",
              "type": "object"
            }
          },
          "required": [
            "metadata"
          ],
          "type": "object"
        }
      },
      "description": "This is a refinement of the Taskcluster metaschema, with the following changes:\n\n  * top level must be an object (no trivial true or false schemas)\n  * `{metadata: {name, version}}` must be present at the top level\n\nNote that any schema that validates against this metaschema will also\nvalidate against the upstream draft-06 metaschema, and is usable by any\nJSON-schema tool.\n",
      "title": "JSON-Schema Meta-Schema, with the addition of a `metadata` property"
    },
    "filename": "schemas/common/metadata-metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v3.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "metadata": {
        "name": "manifest",
        "version": 3
      },
      "properties": {
        "references": {
          "description": "Array of URLs of reference documents",
          "items": {
            "formt": "uri",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "references"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v3.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v2.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "properties": {
        "services": {
          "default": [
          ],
          "description": "List of services that comprise a taskcluster build.",
          "items": {
            "additionalProperties": false,
            "description": "A taskcluster microservice's APIs",
            "properties": {
              "apis": {
                "default": [
                ],
                "description": "HTTP API exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "HTTP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/api-reference-v1.json#` describing the API exposed by service.",
                      "title": "HTTP API reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "HTTP API Reference",
                  "type": "object"
                },
                "title": "HTTP APIs",
                "type": "array",
                "uniqueItems": true
              },
              "pulse": {
                "default": [
                ],
                "description": "Pulse exchanges exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "AMQP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/exchanges-reference-v1.json#` describing the API exposed by service.",
                      "title": "Pulse exchanges reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "Pulse reference",
                  "type": "object"
                },
                "title": "Pulse references",
                "type": "array",
                "uniqueItems": true
              },
              "serviceName": {
                "description": "A short name for the service, such as `queue` / `purge-cache` / `ec2-manager`.\nThis matches the `serviceName` field in any references linked from here.\n",
                "pattern": "^[a-z][a-z0-9_-]*$",
                "title": "Service Name",
                "type": "string"
              }
            },
            "required": [
              "serviceName"
            ],
            "title": "Service",
            "type": "object"
          },
          "title": "List of taskcluster services",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "services"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v2.json"
  },
  {
    "content": {
      "$id": "/schemas/common/logs-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of messages output by structured logging",
      "metadata": {
        "name": "logs",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Log Message Reference",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of the taskcluster service",
          "pattern": "^[a-z][a-z0-9_-]*$",
          "title": "Service Name",
          "type": "string"
        },
        "types": {
          "description": "Array of log message types",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "A description of this message type",
                "type": "string"
              },
              "fields": {
                "additionalProperties": true,
                "description": "The set of fields that will be in every instance of this message type. Mapping field name to description.",
                "type": "object"
              },
              "level": {
                "description": "Either \"any\" or the syslog level that this log will write at.",
                "enum": [
                  "emerg",
                  "alert",
                  "crit",
                  "err",
                  "warning",
                  "notice",
                  "info",
                  "debug",
                  "any"
                ]
              },
              "name": {
                "description": "The service-specific name of this message type.",
                "pattern": "^[a-z][a-zA-Z0-9_]*",
                "type": "string"
              },
              "title": {
                "description": "A human-readable name for the message type.",
                "type": "string"
              },
              "type": {
                "description": "The \"type\" of the message will be in the top-level keys of a message under the name \"Type\".",
                "pattern": "^[a-z][a-z0-9.-_]*",
                "type": "string"
              },
              "version": {
                "description": "The version of the fields for this log type. Will increment for breaking changes.",
                "minimum": 1,
                "type": "integer"
              }
            },
            "required": [
              "type",
              "title",
              "name",
              "level",
              "version",
              "description",
              "fields"
            ],
            "title": "Message Type",
            "type": "object"
          },
          "title": "Types",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "serviceName",
        "$schema",
        "types"
      ],
      "title": "Log Messages Reference File",
      "type": "object"
    },
    "filename": "schemas/common/logs-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/exchanges-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of exchanges published",
      "metadata": {
        "name": "exchanges",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "Description of set of exchanges in markdown",
          "type": "string"
        },
        "entries": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description (ie. documentation) for the exchange",
                "type": "string"
              },
              "exchange": {
                "description": "Exchange name on AMQP server, must be prefixed with `exchangePrefix` from this document.",
                "type": "string"
              },
              "name": {
                "description": "Name of exchange, this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "routingKey": {
                "items": {
                  "additionalProperties": false,
                  "properties": {
                    "constant": {
                      "description": "Constant to be used for this field, cannot be overwritten, only present if applicable.",
                      "type": "string"
                    },
                    "multipleWords": {
                      "description": "True, if key may contain dots, which AMQP will consider as words. This determines if `#` or `*` should be used in client libraries",
                      "type": "boolean"
                    },
                    "name": {
                      "description": "Identifier usable in client libraries",
                      "type": "string"
                    },
                    "required": {
                      "description": "True, if the key is always present, if `false` the value `_` will be used in place when no appropriate value is available for the key.",
                      "type": "boolean"
                    },
                    "summary": {
                      "description": "Short description of key in markdown",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "summary",
                    "multipleWords",
                    "required"
                  ],
                  "type": "object"
                },
                "type": "array",
                "uniqueItems": true
              },
              "schema": {
                "description": "JSON schema for messages on this exchange. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName>`.",
                "type": "string"
              },
              "title": {
                "description": "Title of exchange entry",
                "type": "string"
              },
              "type": {
                "const": "topic-exchange",
                "description": "Type of entry, currently only `topic-exchange`.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "exchange",
              "name",
              "title",
              "description",
              "routingKey",
              "schema"
            ],
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "exchangePrefix": {
          "description": "Prefix for all exchanges described in this document",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "Title for set of exchanges in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "serviceName",
        "title",
        "description",
        "exchangePrefix",
        "entries"
      ],
      "title": "Exchange Reference File",
      "type": "object"
    },
    "filename": "schemas/common/exchanges-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/api-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "scopeExpressionTemplate": {
          "oneOf": [
            {
              "$ref": "#/definitions/scopeExpressionTemplateString"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAllOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateIf"
            },
            {
              "additionalProperties": false,
              "description": "for/each/in objects will replace themselves with an array of basic scopes. They will be flattened into the array this object is a part of.",
              "properties": {
                "each": {
                  "pattern": "^[\\x20-\\x7e]*$",
                  "type": "string"
                },
                "for": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                },
                "in": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                }
              },
              "required": [
                "for",
                "each",
                "in"
              ],
              "title": "For-All",
              "type": "object"
            }
          ]
        },
        "scopeExpressionTemplateAllOf": {
          "additionalProperties": false,
          "description": "AllOf objects will evaluate to true if all subexpressions are true",
          "properties": {
            "AllOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AllOf"
          ],
          "title": "Conjunction",
          "type": "object"
        },
        "scopeExpressionTemplateAnyOf": {
          "additionalProperties": false,
          "description": "AnyOf objects will evaluate to true if any subexpressions are true",
          "properties": {
            "AnyOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AnyOf"
          ],
          "title": "Disjunction",
          "type": "object"
        },
        "scopeExpressionTemplateIf": {
          "additionalProperties": false,
          "description": "if/then objects will replace themselves with the contents of then if the `if` is true",
          "properties": {
            "else": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            },
            "if": {
              "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
              "type": "string"
            },
            "then": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            }
          },
          "required": [
            "if",
            "then"
          ],
          "title": "Conditional",
          "type": "object"
        },
        "scopeExpressionTemplateString": {
          "description": "The most basic element of a scope expression",
          "pattern": "^[\\x20-\\x7e]*$",
          "title": "Required-Scope",
          "type": "string"
        }
      },
      "description": "Reference of methods implemented by API",
      "metadata": {
        "name": "api",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "API description in markdown",
          "type": "string"
        },
        "entries": {
          "description": "Array of methods in this reference",
          "items": {
            "additionalProperties": false,
            "properties": {
              "args": {
                "description": "Arguments from `route` that must be replaced, they'll appear wrapped in brackets inside `route`.",
                "items": {
                  "description": "Argument that appears in `route` warpped in angle brackets. It must be replaced to call the function.",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "description": {
                "description": "Description (ie. documentation) for the API entry",
                "type": "string"
              },
              "input": {
                "description": "JSON schema for input, if input is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                "type": "string"
              },
              "method": {
                "description": "HTTP method (verb) used to access the function",
                "enum": [
                  "get",
                  "post",
                  "put",
                  "head",
                  "delete",
                  "options",
                  "trace",
                  "copy",
                  "lock",
                  "mkcol",
                  "move",
                  "purge",
                  "propfind",
                  "proppatch",
                  "unlock",
                  "report",
                  "mkactivity",
                  "checkout",
                  "merge",
                  "m-search",
                  "notify",
                  "subscribe",
                  "unsubscribe",
                  "patch",
                  "search"
                ],
                "type": "string"
              },
              "name": {
                "description": "Name of the `function` this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "output": {
                "oneOf": [
                  {
                    "description": "JSON schema for output, if output is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                    "title": "Output Schema",
                    "type": "string"
                  },
                  {
                    "description": "Output kind if not JSON matching a specific schema.",
                    "enum": [
                      "blob"
                    ],
                    "title": "Blob",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "query": {
                "description": "List of accepted query-string parameters, these are always optional.",
                "items": {
                  "description": "Optional query-string parameter",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "route": {
                "description": "Route for the call, note that arguments wrapped with brackets, like `/user/<userId>/` must be replaced.",
                "type": "string"
              },
              "scopes": {
                "description": "Scope expression template specifying required scopes for a method. Not provided if authentication isn't required.",
                "oneOf": [
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateString"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAllOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateIf"
                  }
                ]
              },
              "stability": {
                "description": "Stability level of the API",
                "enum": [
                  "deprecated",
                  "experimental",
                  "stable"
                ],
                "title": "Stability-Level",
                "type": "string"
              },
              "title": {
                "description": "Title of API entry",
                "type": "string"
              },
              "type": {
                "description": "Type of entry, currently only `function`.",
                "enum": [
                  "function"
                ],
                "type": "string"
              }
            },
            "required": [
              "type",
              "method",
              "route",
              "args",
              "name",
              "stability",
              "title",
              "description"
            ],
            "title": "API Entry",
            "type": "object"
          },
          "title": "Entries",
          "type": "array",
          "uniqueItems": true
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "API title in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "title",
        "description",
        "serviceName",
        "entries"
      ],
      "title": "API Reference File",
      "type": "object"
    },
    "filename": "schemas/common/api-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/action-schema-v1.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "definitions": {
        "context": {
          "default": [
          ],
          "description": "The `context` property determines in what context the action is\nrelevant. Thus, what context the action should be presented to the\nend-user.\n",
          "items": {
            "additionalProperties": {
              "maxLength": 4096,
              "type": "string"
            },
            "description": "A set of key-value pairs specifying a _tag-set_.\n",
            "title": "tag-set",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "description": {
          "description": "Human readable description of the action in markdown. This\ncan be displayed in a tooltip, popup and/or dialog when triggering\nthe action.\n",
          "maxLength": 4096,
          "type": "string"
        },
        "extra": {
          "description": "Extra data that the decision task wishes to include for use by other\nservices interpreting `actions.json`.  Consumers of this file are free to\nignore any and all data in this field.\n",
          "type": "object"
        },
        "name": {
          "description": "The name of this action.  This is used by user interfaces to\nidentify the action.\n",
          "maxLength": 255,
          "type": "string"
        },
        "schema": {
          "$ref": "http://json-schema.org/schema",
          "description": "JSON schema for user input to the action.  If this property is omitted,\nthen the input is `null`.\n"
        },
        "title": {
          "description": "Title text to be displayed on the button or link triggering the action.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "description": "This document specifies the schema for the `public/actions.json` used by\n_decision tasks_ to expose actions that can be triggered by end-users.\n\nFor the purpose of this document the _consumer_ is the user-interface that\ndisplays task results to the end-user and allows end-users to trigger actions\ndefined by `public/actions.json`. A _consumer_ might be Treeherder.\nThe _end-user_ is a developer who is inspecting the results, and wishes to\ntrigger actions.\n",
      "properties": {
        "actions": {
          "description": "List of actions that can be triggered.\n",
          "items": {
            "anyOf": [
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "kind": {
                    "enum": [
                      "task"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "task": {
                    "description": "Task template for triggering the action.\n\nWhen an action have been selected in the appropriate context and\ninput satisfying the `schema` (if any) has been collected. The\naction is triggered by parameterizing the task template given in\nthis property, and creating the resulting task.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the context\ndescribed in the documentation.\n",
                    "title": "Task Template",
                    "type": "object"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "task"
                ],
                "type": "object"
              },
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "hookGroupId": {
                    "description": "The `hookGroupId` of the hook to trigger to run this action",
                    "title": "Hook Group ID",
                    "type": "string"
                  },
                  "hookId": {
                    "description": "The `hookId` of the hook to trigger to run this action",
                    "title": "Hook ID",
                    "type": "string"
                  },
                  "hookPayload": {
                    "description": "JSON-e template that renders to the payload for `hooks.triggerHook`.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the\ncontext described in the documentation. The output of this\nrendering is provided as the payload to `hooks.triggerHook`\n(where it becomes the context for another JSON-e rendering\nstep - don't get the two confused!)\n",
                    "title": "Hook Payload Template",
                    "type": "object"
                  },
                  "kind": {
                    "enum": [
                      "hook"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "hookGroupId",
                  "hookId",
                  "hookPayload"
                ],
                "type": "object"
              }
            ]
          },
          "type": "array",
          "uniqueItems": true
        },
        "variables": {
          "additionalProperties": true,
          "description": "Additional variables included in JSON-e context.\n",
          "type": "object"
        },
        "version": {
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "actions",
        "variables"
      ],
      "title": "Schema for Exposing Actions",
      "type": "object"
    },
    "filename": "schemas/common/action-schema-v1.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/websocktunnel-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Token for connecting a worker to websocktunnel proxy\n",
      "properties": {
        "expires": {
          "description": "The time at which the JWT will expire.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "token": {
          "description": "The JWT to be used as `Bearer <token>` when connecting to the service.\n",
          "title": "Token",
          "type": "string"
        },
        "wstAudience": {
          "description": "Audience identifying the websocktunnel servers that will honor this token; this will be the\nsame as the requested `wstAudience`.\n",
          "pattern": "^[a-zA-Z0-9_-]{1,38}$",
          "title": "Websocktunnel Audience",
          "type": "string"
        },
        "wstClient": {
          "description": "Id for the websocktunnel client connection; this will be the same as the requested `wstClient`.\n",
          "pattern": "^[a-zA-Z0-9_~.%-]+$",
          "title": "Websocktunnel Client",
          "type": "string"
        }
      },
      "required": [
        "wstClient",
        "wstAudience",
        "token",
        "expires"
      ],
      "title": "Websocktunnel Token Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/websocktunnel-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request was authenticated.\n",
      "properties": {
        "clientId": {
          "description": "ClientId from the request as it will be logged\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the request was authorized.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "scopes"
      ],
      "title": "Test Authenticate Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request should be authenticated.\n",
      "properties": {
        "clientScopes": {
          "default": [
          ],
          "description": "List of scopes that should be client used should be given.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "requiredScopes": {
          "default": [
          ],
          "description": "List of scopes the request should require.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientScopes",
        "requiredScopes"
      ],
      "title": "Test Authenticate Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/statsum-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Token for submitting statistics to statsum.\n",
      "properties": {
        "baseUrl": {
          "description": "Base URL for the statsum server this project is allocated on.\n",
          "format": "uri",
          "title": "BaseUrl",
          "type": "string"
        },
        "expires": {
          "description": "Time at which the token expires and should not be used anymore.\n",
          "format": "date-time",
          "title": "Token Expiration",
          "type": "string"
        },
        "project": {
          "description": "Project name that the token grants access to.\n",
          "title": "Project",
          "type": "string"
        },
        "token": {
          "description": "JWT token to be used as `Bearer <token>` when submitting data to statsum.\n",
          "title": "Access Token",
          "type": "string"
        }
      },
      "required": [
        "project",
        "token",
        "expires",
        "baseUrl"
      ],
      "title": "Statsum Token Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/statsum-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/sentry-dsn-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Sentry DSN for submitting errors.\n",
      "properties": {
        "dsn": {
          "additionalProperties": false,
          "description": "Access credentials and urls for the Sentry project.\nCredentials will expire in 24-48 hours, you should refresh them within\n24 hours.\n",
          "properties": {
            "public": {
              "description": "Access credential and URL for public error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in client-side applications only.\n",
              "format": "uri",
              "type": "string"
            },
            "secret": {
              "description": "Access credential and URL for private error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in serser-side applications and should **not** be\nleaked.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "secret",
            "public"
          ],
          "type": "object"
        },
        "expires": {
          "description": "Expiration time for the credentials. The credentials should not be used\nafter this time. They might not be revoked immediately, but will be at\nsome arbitrary point after this date-time.\n",
          "format": "date-time",
          "type": "string"
        },
        "project": {
          "description": "Project name that the DSN grants access to.\n",
          "title": "Project",
          "type": "string"
        }
      },
      "required": [
        "project",
        "dsn",
        "expires"
      ],
      "title": "Sentry DSN Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/sentry-dsn-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/scopeset.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A set of scopes\n",
      "properties": {
        "scopes": {
          "description": "List of scopes.  Scopes must be composed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes"
      ],
      "title": "Set of scopes",
      "type": "object"
    },
    "filename": "schemas/auth/v1/scopeset.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/role-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a role has changed\n",
      "properties": {
        "roleId": {
          "description": "`roleId` of the role that was changed\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "roleId"
      ],
      "title": "Role Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/role-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles2-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roles": {
          "description": "A list of requested roles\n",
          "items": {
            "$ref": "get-role-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roles"
      ],
      "title": "Get All Roles Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-roles2-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "List of roles\n",
      "items": {
        "$ref": "get-role-response.json#"
      },
      "title": "Get All Roles (no pagination)",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/auth/v1/list-roles-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-role-ids-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roleIds": {
          "description": "A list of requested roleIds\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roleIds"
      ],
      "title": "Get Role Ids Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-role-ids-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-clients-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of clients\n",
      "properties": {
        "clients": {
          "items": {
            "$ref": "get-client-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "clients"
      ],
      "title": "List Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-clients-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-role-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a role\n",
      "properties": {
        "created": {
          "description": "Date and time when this role was created\n",
          "format": "date-time",
          "type": "string"
        },
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expandedScopes": {
          "description": "List of scopes granted anyone who assumes this role, including anything\ngranted by roles that can be assumed when you have this role.\nHence, this includes any scopes in-directly granted as well.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "roleId": {
          "description": "roleId of the role requested\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "roleId",
        "scopes",
        "description",
        "created",
        "lastModified",
        "expandedScopes"
      ],
      "title": "Get Role Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-role-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a client, useful for tools modifying a client\n",
      "properties": {
        "clientId": {
          "description": "ClientId of the client scopes is requested about\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope that client is granted by a role\n",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Get Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-role-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Data to create or update a role.\n",
      "properties": {
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes",
        "description"
      ],
      "title": "Create Role Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-role-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "All details about a client including the `accessToken`\n",
      "properties": {
        "accessToken": {
          "description": "AccessToken used for authenticating requests, you should store this\nyou won't be able to retrive it again!\n",
          "pattern": "^[a-zA-Z0-9_-]{22,66}$",
          "type": "string"
        },
        "clientId": {
          "description": "ClientId of the client\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles, including the\nclient's scopes and the implicit role `client-id:<clientId>`.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Create Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Properties to create a client.\n",
      "properties": {
        "deleteOnExpiration": {
          "default": false,
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false` (the default), the client will remain after expiration, although\nit cannot be used for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "expires",
        "description"
      ],
      "title": "Create Client Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/client-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a client has changed\n",
      "properties": {
        "clientId": {
          "description": "`clientId` of the client that was changed\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "clientId"
      ],
      "title": "Client Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/client-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure tables in an account\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tables.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `azureAccountTables` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tables": {
          "description": "A list of tables that are in an account. These are\nthe tables that can have SAS credentials fetched for them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Tables",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tables"
      ],
      "title": "Azure List Table Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-access-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access and Azure\nTable Storage table.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Table Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-access-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access an Azure\nBlob Storage container.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Blob Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure containers in an account\n",
      "properties": {
        "containers": {
          "description": "A list of containers that are in an account.  Credentials are available for\nthese containers from the `azureBlobSAS` method.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Containers",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of containers.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called this method with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "containers"
      ],
      "title": "Azure List Containers Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-account-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure accounts managed by taskcluster-auth\n",
      "properties": {
        "accounts": {
          "description": "A list of accountIds that are managed by auth. These are\nthe accounts that can have SAS credentials fetched for tables\nwithin them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Accounts",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "accounts"
      ],
      "title": "Azure List Account Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-account-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/aws-s3-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for a request to get access to an S3 bucket.\n",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "Temporary STS credentials for use when operating on S3\n",
          "properties": {
            "accessKeyId": {
              "description": "Access key identifier that identifies the temporary security\ncredentials.\n",
              "title": "AccessKeyId",
              "type": "string"
            },
            "secretAccessKey": {
              "description": "Secret access key used to sign requests\n",
              "title": "SecretAccessKey",
              "type": "string"
            },
            "sessionToken": {
              "description": "A token that must passed with request to use the temporary\nsecurity credentials.\n",
              "title": "SessionToken",
              "type": "string"
            }
          },
          "required": [
            "accessKeyId",
            "secretAccessKey",
            "sessionToken"
          ],
          "title": "Temporary Security Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Date and time of when the temporary credentials expires.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "credentials",
        "expires"
      ],
      "title": "AWS S3 Credentials Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/aws-s3-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response from a request to authenticate a hawk request.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "clientId": {
              "description": "The `clientId` that made this request.  This may be the `id` supplied in\nthe Authorization header, or in the case of a named temporary credential\nmay be embedded in the payload.  In any case, this clientId can be used\nfor logging, auditing, and identifying the credential but **must** not be\nused for access control.  That's what scopes are for.\n",
              "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
              "type": "string"
            },
            "expires": {
              "description": "The expiration time for the credentials used to make this request.\nThis should be treated as the latest time at which the authorization\nis valid.  For most cases, where the access being authorized occurs\nimmediately, this field can be ignored, as the value will always be\nin the future if the status is `auth-success`.\n",
              "format": "date-time",
              "type": "string"
            },
            "hash": {
              "description": "Payload as extracted from `Authentication` header. This property is\nonly present if a hash is available. You are not required to validate\nthis hash, but if you do, please check `scheme` to ensure that it's\non a scheme you support.\n"
            },
            "scheme": {
              "description": "Authentication scheme the client used. Generally, you don't need to\nread this property unless `hash` is provided and you want to validate\nthe payload hash. Additional values may be added in the future.\n",
              "enum": [
                "hawk"
              ],
              "type": "string"
            },
            "scopes": {
              "description": "List of scopes the client is authorized to access.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
              "items": {
                "pattern": "^[ -~]*$",
                "type": "string"
              },
              "type": "array",
              "uniqueItems": true
            },
            "status": {
              "description": "The kind of response, `auth-failed` or `auth-success`.\n",
              "enum": [
                "auth-success"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "scopes",
            "scheme",
            "clientId",
            "expires"
          ],
          "title": "Authentication Successful Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "description": "Message saying why the authentication failed.\n",
              "type": "string"
            },
            "status": {
              "description": "The kind of response, `auth-failed` or `auth-success`.\n",
              "enum": [
                "auth-failed"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "message"
          ],
          "title": "Authentication Failed Response",
          "type": "object"
        }
      ],
      "title": "Hawk Signature Authentication Response"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to authenticate a hawk request.\n",
      "properties": {
        "authorization": {
          "description": "Authorization header, **must** only be specified if request being\nauthenticated has a `Authorization` header.\n",
          "type": "string"
        },
        "host": {
          "description": "Host for which the request came in, this is typically the `Host` header\nexcluding the port if any.\n",
          "format": "hostname",
          "title": "Hostname or IPv4",
          "type": "string"
        },
        "method": {
          "description": "HTTP method of the request being authenticated.\n",
          "enum": [
            "get",
            "post",
            "put",
            "head",
            "delete",
            "options",
            "trace",
            "copy",
            "lock",
            "mkcol",
            "move",
            "purge",
            "propfind",
            "proppatch",
            "unlock",
            "report",
            "mkactivity",
            "checkout",
            "merge",
            "m-search",
            "notify",
            "subscribe",
            "unsubscribe",
            "patch",
            "search",
            "connect"
          ],
          "type": "string"
        },
        "port": {
          "description": "Port on which the request came in, this is typically `80` or `443`.\nIf you are running behind a reverse proxy look for the `x-forwarded-port`\nheader.\n",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "resource": {
          "description": "Resource the request operates on including querystring. This is the\nstring that follows the HTTP method.\n**Note,** order of querystring elements is important.\n",
          "type": "string"
        },
        "sourceIp": {
          "description": "Source IP of the authentication request or request that requires\nauthentication. This is only used for audit logging.\n",
          "oneOf": [
            {
              "format": "ipv6"
            },
            {
              "format": "ipv4"
            }
          ],
          "title": "Source IP",
          "type": "string"
        }
      },
      "required": [
        "method",
        "resource",
        "host",
        "port"
      ],
      "title": "Hawk Signature Authentication Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-request.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "worker-manager",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A workerType's provisioning run has completed",
          "fields": {
            "provider": "The name of the provider that did the work for this workertype.",
            "workerType": "The name of the workertype."
          },
          "level": "info",
          "name": "workertypeProvisioned",
          "title": "Workertype Provisioned",
          "type": "workertype-provisioned",
          "version": 1
        },
        {
          "description": "The simple estimator has decided that we need some number of instances.",
          "fields": {
            "capacityPerInstance": "Amount of capacity a single instance provides",
            "desiredSize": "Number that this estimator thinks we should have",
            "maxCapacity": "The maximum amount of capacity that should be running",
            "minCapacity": "The minimum amount of capacity that should be running",
            "pendingTasks": "The number of tasks the queue reports are pending for this workerType",
            "running": "Number of currently requested and running instances",
            "workerType": "The name of the workertype."
          },
          "level": "notice",
          "name": "simpleEstimate",
          "title": "Simple Estimate Provided",
          "type": "simple-estimate",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/worker-manager/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "These exchanges provide notifications when a workerType is created, updatedor deleted. This is so that the listener running in a differentprocess at the other end can direct another listener specified by`provider` and `workerType` to synchronize its bindings. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create aworkerType, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "workertype-created",
          "name": "workerTypeCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-workertype-message.json#",
          "title": "WorkerType Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update aworkerType, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "workertype-updated",
          "name": "workerTypeUpdated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-workertype-message.json#",
          "title": "WorkerType Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to delete aworkerType, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "workertype-deleted",
          "name": "workerTypeDeleted",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-workertype-message.json#",
          "title": "WorkerType Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-worker-manager/v1/",
      "serviceName": "worker-manager",
      "title": "Worker Manager Exchanges"
    },
    "filename": "references/worker-manager/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This service manages workers, including provisioning for dynamic workertypes.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Create a new workertype. If the workertype already exists, this will throw an error.",
          "input": "v1/create-workertype-request.json#",
          "method": "put",
          "name": "createWorkerType",
          "output": "v1/workertype-full.json#",
          "query": [
          ],
          "route": "/workertype/<name>",
          "scopes": {
            "AllOf": [
              "worker-manager:create-worker-type:<name>",
              "worker-manager:provider:<provider>"
            ]
          },
          "stability": "experimental",
          "title": "Create WorkerType",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Given an existing workertype definition, this will modify it and return the new definition.",
          "input": "v1/create-workertype-request.json#",
          "method": "post",
          "name": "updateWorkerType",
          "output": "v1/workertype-full.json#",
          "query": [
          ],
          "route": "/workertype/<name>",
          "scopes": {
            "AllOf": [
              "worker-manager:update-worker-type:<name>",
              "worker-manager:provider:<provider>"
            ]
          },
          "stability": "experimental",
          "title": "Update WorkerType",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Given an existing workertype defition, this will fetch it.",
          "method": "get",
          "name": "workerType",
          "output": "v1/workertype-full.json#",
          "query": [
          ],
          "route": "/workertype/<name>",
          "stability": "experimental",
          "title": "Get WorkerType",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Delete an existing workertype definition.",
          "method": "delete",
          "name": "deleteWorkerType",
          "query": [
          ],
          "route": "/workertype/<name>",
          "scopes": "worker-manager:delete-worker-type:<name>",
          "stability": "experimental",
          "title": "Delete WorkerType",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Get the list of all the existing workertypes",
          "method": "get",
          "name": "listWorkerTypes",
          "output": "v1/workertype-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/workertypes",
          "stability": "experimental",
          "title": "List All WorkerTypes",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Get Taskcluster credentials for a worker given an Instance Identity Token",
          "input": "v1/credentials-google-request.json#",
          "method": "post",
          "name": "credentialsGoogle",
          "output": "v1/temp-creds-response.json#",
          "query": [
          ],
          "route": "/credentials/google/<name>",
          "stability": "experimental",
          "title": "Google Credentials",
          "type": "function"
        }
      ],
      "serviceName": "worker-manager",
      "title": "Taskcluster Worker Manager"
    },
    "filename": "references/worker-manager/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "treeherder",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/treeherder/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The taskcluster-treeherder service is responsible for processing\ntask events published by Taskcluster Queue and producing job messages\nthat are consumable by Treeherder.\n\nThis exchange provides that job messages to be consumed by any queue that\nattached to the exchange.  This could be a production Treeheder instance,\na local development environment, or a custom dashboard.",
      "entries": [
        {
          "description": "When a task run is scheduled or resolved, a message is posted to\nthis exchange in a Treeherder consumable format.",
          "exchange": "jobs",
          "name": "jobs",
          "routingKey": [
            {
              "multipleWords": false,
              "name": "destination",
              "required": true,
              "summary": "destination"
            },
            {
              "multipleWords": false,
              "name": "project",
              "required": true,
              "summary": "project"
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-job.json#",
          "title": "Job Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-treeherder/v1/",
      "serviceName": "treeherder",
      "title": "Taskcluster-treeherder Pulse Exchange"
    },
    "filename": "references/treeherder/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "secrets",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/secrets/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
          "input": "v1/secret.json#",
          "method": "put",
          "name": "set",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Set Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Delete the secret associated with some key.",
          "method": "delete",
          "name": "remove",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Delete Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "description": "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
          "method": "get",
          "name": "get",
          "output": "v1/secret.json#",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:get:<name>",
          "stability": "stable",
          "title": "Read Secret",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "List the names of all secrets.\n\nBy default this end-point will try to return up to 1000 secret names in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "list",
          "output": "v1/secret-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/secrets",
          "stability": "stable",
          "title": "List Secrets",
          "type": "function"
        }
      ],
      "serviceName": "secrets",
      "title": "Taskcluster Secrets API Documentation"
    },
    "filename": "references/secrets/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "queue",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Report result of polling messages from an azure queue.",
          "fields": {
            "failed": "Number of these messages that failed to be handled.",
            "messages": "Number of messages fetched.",
            "resolver": "The name of the queue being polled."
          },
          "level": "info",
          "name": "azureQueuePoll",
          "title": "Azure Queue Poll",
          "type": "azure-queue-poll",
          "version": 1
        },
        {
          "description": "A task has been created (via defineTask or createTask).  This is logged when the task-defined\npulse message is sent.",
          "fields": {
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskDefined",
          "title": "Task Defined",
          "type": "task-defined",
          "version": 1
        },
        {
          "description": "A task is now pending and ready to be executed.  This is logged when the task-pending pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that is now pending.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskPending",
          "title": "Task Pending",
          "type": "task-pending",
          "version": 1
        },
        {
          "description": "A task is now being executed.  This is logged when the task-running pulse message is sent.",
          "fields": {
            "runId": "The runId that is now running.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskRunning",
          "title": "Task Running",
          "type": "task-running",
          "version": 1
        },
        {
          "description": "A task run has been resolved as completed.  This is logged when the task-completed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskCompleted",
          "title": "Task Completed",
          "type": "task-completed",
          "version": 1
        },
        {
          "description": "A task run has been resolved as failed.  This is logged when the task-failed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskFailed",
          "title": "Task Failed",
          "type": "task-failed",
          "version": 1
        },
        {
          "description": "A task run has been resolved as an exception.  This is logged when the task-exception pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskException",
          "title": "Task Exception",
          "type": "task-exception",
          "version": 1
        },
        {
          "description": "A worker has claimed a task.  In cases where multple tasks were claimed,\none log message will be produced for each task.",
          "fields": {
            "provisionerId": "Provisioner that provisioned the worker claiming work.",
            "runId": "The run of this task assigned to the worker.",
            "taskId": "The task given to the worker.",
            "workerGroup": "Group of worker claiming work.",
            "workerId": "The id of the claiming worker.",
            "workerType": "Type of worker claiming work."
          },
          "level": "notice",
          "name": "taskClaimed",
          "title": "Task Claimed",
          "type": "task-claimed",
          "version": 1
        },
        {
          "description": "A worker has reclaimed a task it had previously claimed, extending its takenUntil\ntimestamp.",
          "fields": {
            "runId": "The run of this task being reclaimed.",
            "taskId": "The task being reclaimed.",
            "workerGroup": "Group of the reclaiming worker.",
            "workerId": "Id of the reclaiming worker."
          },
          "level": "notice",
          "name": "taskReclaimed",
          "title": "Task Reclaimed",
          "type": "task-reclaimed",
          "version": 1
        },
        {
          "description": "Metrics of an iteration of the hint poller.",
          "fields": {
            "claimed": "Number of hints claimed on an iteration.",
            "released": "Number of hints released on an iteration. Should usually be 0.",
            "slept": "If true, there were no hints to claim and the poller slept before claiming again."
          },
          "level": "info",
          "name": "hintPoller",
          "title": "Hint Poller Report",
          "type": "hint-poller",
          "version": 1
        }
      ]
    },
    "filename": "references/queue/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes AMQP exchanges offered by the queue, which allows\nthird-party listeners to monitor tasks as they progress to resolution.\nThese exchanges targets the following audience:\n * Schedulers, who takes action after tasks are completed,\n * Workers, who wants to listen for new or canceled tasks (optional),\n * Tools, that wants to update their view as task progress.\n\nYou'll notice that all the exchanges in the document shares the same\nrouting key pattern. This makes it very easy to bind to all messages\nabout a certain kind tasks.\n\n**Task specific routes**, a task can define a task specific route using\nthe `task.routes` property. See task creation documentation for details\non permissions required to provide task specific routes. If a task has\nthe entry `'notify.by-email'` in as task specific route defined in\n`task.routes` all messages about this task will be CC'ed with the\nrouting-key `'route.notify.by-email'`.\n\nThese routes will always be prefixed `route.`, so that cannot interfere\nwith the _primary_ routing key as documented here. Notice that the\n_primary_ routing key is always prefixed `primary.`. This is ensured\nin the routing key reference, so API clients will do this automatically.\n\nPlease, note that the way RabbitMQ works, the message will only arrive\nin your queue once, even though you may have bound to the exchange with\nmultiple routing key patterns that matches more of the CC'ed routing\nrouting keys.\n\n**Delivery guarantees**, most operations on the queue are idempotent,\nwhich means that if repeated with the same arguments then the requests\nwill ensure completion of the operation and return the same response.\nThis is useful if the server crashes or the TCP connection breaks, but\nwhen re-executing an idempotent operation, the queue will also resend\nany related AMQP messages. Hence, messages may be repeated.\n\nThis shouldn't be much of a problem, as the best you can achieve using\nconfirm messages with AMQP is at-least-once delivery semantics. Hence,\nthis only prevents you from obtaining at-most-once delivery semantics.\n\n**Remark**, some message generated by timeouts maybe dropped if the\nserver crashes at wrong time. Ideally, we'll address this in the\nfuture. For now we suggest you ignore this corner case, and notify us\nif this corner case is of concern to you.",
      "entries": [
        {
          "description": "When a task is created or just defined a message is posted to this\nexchange.\n\nThis message exchange is mainly useful when tasks are scheduled by a\nscheduler that uses `defineTask` as this does not make the task\n`pending`. Thus, no `taskPending` message is published.\nPlease, note that messages are also published on this exchange if defined\nusing `createTask`.",
          "exchange": "task-defined",
          "name": "taskDefined",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-defined-message.json#",
          "title": "Task Defined Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task becomes `pending` a message is posted to this exchange.\n\nThis is useful for workers who doesn't want to constantly poll the queue\nfor new tasks. The queue will also be authority for task states and\nclaims. But using this exchange workers should be able to distribute work\nefficiently and they would be able to reduce their polling interval\nsignificantly without affecting general responsiveness.",
          "exchange": "task-pending",
          "name": "taskPending",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-pending-message.json#",
          "title": "Task Pending Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever a task is claimed by a worker, a run is started on the worker,\nand a message is posted on this exchange.",
          "exchange": "task-running",
          "name": "taskRunning",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-running-message.json#",
          "title": "Task Running Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the `createArtifact` end-point is called, the queue will create\na record of the artifact and post a message on this exchange. All of this\nhappens before the queue returns a signed URL for the caller to upload\nthe actual artifact with (pending on `storageType`).\n\nThis means that the actual artifact is rarely available when this message\nis posted. But it is not unreasonable to assume that the artifact will\nwill become available at some point later. Most signatures will expire in\n30 minutes or so, forcing the uploader to call `createArtifact` with\nthe same payload again in-order to continue uploading the artifact.\n\nHowever, in most cases (especially for small artifacts) it's very\nreasonable assume the artifact will be available within a few minutes.\nThis property means that this exchange is mostly useful for tools\nmonitoring task evaluation. One could also use it count number of\nartifacts per task, or _index_ artifacts though in most cases it'll be\nsmarter to index artifacts after the task in question have completed\nsuccessfully.",
          "exchange": "artifact-created",
          "name": "artifactCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/artifact-created-message.json#",
          "title": "Artifact Creation Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task is successfully completed by a worker a message is posted\nthis exchange.\nThis message is routed using the `runId`, `workerGroup` and `workerId`\nthat completed the task. But information about additional runs is also\navailable from the task status structure.",
          "exchange": "task-completed",
          "name": "taskCompleted",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-completed-message.json#",
          "title": "Task Completed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task ran, but failed to complete successfully a message is posted\nto this exchange. This is same as worker ran task-specific code, but the\ntask specific code exited non-zero.",
          "exchange": "task-failed",
          "name": "taskFailed",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-failed-message.json#",
          "title": "Task Failed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever Taskcluster fails to run a message is posted to this exchange.\nThis happens if the task isn't completed before its `deadlne`,\nall retries failed (i.e. workers stopped responding), the task was\ncanceled by another entity, or the task carried a malformed payload.\n\nThe specific _reason_ is evident from that task status structure, refer\nto the `reasonResolved` property for the last run.",
          "exchange": "task-exception",
          "name": "taskException",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-exception-message.json#",
          "title": "Task Exception Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message is published on task-group-resolved whenever all submitted\ntasks (whether scheduled or unscheduled) for a given task group have\nbeen resolved, regardless of whether they resolved as successful or\nnot. A task group may be resolved multiple times, since new tasks may\nbe submitted against an already resolved task group.",
          "exchange": "task-group-resolved",
          "name": "taskGroupResolved",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` for the task-group this message concerns"
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` for the task-group this message concerns"
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-group-resolved.json#",
          "title": "Task Group Resolved Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-queue/v1/",
      "serviceName": "queue",
      "title": "Queue AMQP Exchanges"
    },
    "filename": "references/queue/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes the API end-points offered by the queue. These \nend-points targets the following audience:\n * Schedulers, who create tasks to be executed,\n * Workers, who execute tasks, and\n * Tools, that wants to inspect the state of a task.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
          "method": "get",
          "name": "task",
          "output": "v1/task.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "stability": "stable",
          "title": "Get Task Definition",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "Get task status structure from `taskId`",
          "method": "get",
          "name": "status",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/status",
          "stability": "stable",
          "title": "Get task status",
          "type": "function"
        },
        {
          "args": [
            "taskGroupId"
          ],
          "description": "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listTaskGroup",
          "output": "v1/list-task-group-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task-group/<taskGroupId>/list",
          "stability": "stable",
          "title": "List Task Group",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDependentTasks",
          "output": "v1/list-dependent-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/dependents",
          "stability": "stable",
          "title": "List Dependent Tasks",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline`**: the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**: the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice, that artifacts created by task must expire before the task.\n\n**Task specific routing-keys**: using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific \nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key: \n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**: any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Scopes**: Note that the scopes required to complete this API call depend\non the content of the `scopes`, `routes`, `schedulerId`, `priority`,\n`provisionerId`, and `workerType` properties of the task definition.\n\n**Legacy Scopes**: The `queue:create-task:..` scope without a priority and\nthe `queue:define-task:..` and `queue:task-group-id:..` scopes are considered\nlegacy and should not be used. Note that the new, non-legacy scopes require\na `queue:scheduler-id:..` scope as well as scopes for the proper priority.",
          "input": "v1/create-task-request.json#",
          "method": "put",
          "name": "createTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "scopes": {
            "AllOf": [
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              },
              {
                "each": "queue:route:<route>",
                "for": "route",
                "in": "routes"
              },
              {
                "AnyOf": [
                  {
                    "AllOf": [
                      "queue:scheduler-id:<schedulerId>",
                      {
                        "AnyOf": [
                          {
                            "each": "queue:create-task:<priority>:<provisionerId>/<workerType>",
                            "for": "priority",
                            "in": "priorities"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "if": "legacyScopes",
                    "then": {
                      "AnyOf": [
                        "queue:create-task:<provisionerId>/<workerType>",
                        {
                          "AllOf": [
                            "queue:define-task:<provisionerId>/<workerType>",
                            "queue:task-group-id:<schedulerId>/<taskGroupId>",
                            "queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>"
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Create New Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "**Deprecated**, this is the same as `createTask` with a **self-dependency**.\nThis is only present for legacy.",
          "input": "v1/create-task-request.json#",
          "method": "post",
          "name": "defineTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/define",
          "scopes": {
            "AllOf": [
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              },
              {
                "each": "queue:route:<route>",
                "for": "route",
                "in": "routes"
              },
              {
                "AnyOf": [
                  {
                    "AllOf": [
                      "queue:scheduler-id:<schedulerId>",
                      {
                        "AnyOf": [
                          {
                            "each": "queue:create-task:<priority>:<provisionerId>/<workerType>",
                            "for": "priority",
                            "in": "priorities"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "if": "legacyScopes",
                    "then": {
                      "AnyOf": [
                        "queue:define-task:<provisionerId>/<workerType>",
                        "queue:create-task:<provisionerId>/<workerType>",
                        {
                          "AllOf": [
                            "queue:define-task:<provisionerId>/<workerType>",
                            "queue:task-group-id:<schedulerId>/<taskGroupId>"
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Define Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
          "method": "post",
          "name": "scheduleTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/schedule",
          "scopes": {
            "AnyOf": [
              "queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:schedule-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Schedule Defined Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed.\n\nThis method is deprecated in favour of creating a new task with the same\ntask definition (but with a new taskId).\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent, if you try to rerun a task that\nis not either `failed` or `completed`, this operation will just return\nthe current task status.",
          "method": "post",
          "name": "rerunTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/rerun",
          "scopes": {
            "AnyOf": [
              "queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:rerun-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Rerun a Resolved Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
          "method": "post",
          "name": "cancelTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/cancel",
          "scopes": {
            "AnyOf": [
              "queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:cancel-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Cancel Task",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Claim pending task(s) for the given `provisionerId`/`workerType` queue.\n\nIf any work is available (even if fewer than the requested number of\ntasks, this will return immediately. Otherwise, it will block for tens of\nseconds waiting for work.  If no work appears, it will return an emtpy\nlist of tasks.  Callers should sleep a short while (to avoid denial of\nservice in an error condition) and call the endpoint again.  This is a\nsimple implementation of \"long polling\".",
          "input": "v1/claim-work-request.json#",
          "method": "post",
          "name": "claimWork",
          "output": "v1/claim-work-response.json#",
          "query": [
          ],
          "route": "/claim-work/<provisionerId>/<workerType>",
          "scopes": {
            "AllOf": [
              "queue:claim-work:<provisionerId>/<workerType>",
              "queue:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "stable",
          "title": "Claim Work",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "claim a task - never documented",
          "input": "v1/task-claim-request.json#",
          "method": "post",
          "name": "claimTask",
          "output": "v1/task-claim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/claim",
          "scopes": {
            "AnyOf": [
              {
                "AllOf": [
                  "queue:claim-task:<provisionerId>/<workerType>",
                  "queue:worker-id:<workerGroup>/<workerId>"
                ]
              },
              {
                "AllOf": [
                  "queue:claim-task",
                  "assume:worker-type:<provisionerId>/<workerType>",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Claim Task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "Refresh the claim for a specific `runId` for given `taskId`. This updates\nthe `takenUntil` property and returns a new set of temporary credentials\nfor performing requests on behalf of the task. These credentials should\nbe used in-place of the credentials returned by `claimWork`.\n\nThe `reclaimTask` requests serves to:\n * Postpone `takenUntil` preventing the queue from resolving\n   `claim-expired`,\n * Refresh temporary credentials used for processing the task, and\n * Abort execution if the task/run have been resolved.\n\nIf the `takenUntil` timestamp is exceeded the queue will resolve the run\nas _exception_ with reason `claim-expired`, and proceeded to retry to the\ntask. This ensures that tasks are retried, even if workers disappear\nwithout warning.\n\nIf the task is resolved, this end-point will return `409` reporting\n`RequestConflict`. This typically happens if the task have been canceled\nor the `task.deadline` have been exceeded. If reclaiming fails, workers\nshould abort the task and forget about the given `runId`. There is no\nneed to resolve the run or upload artifacts.",
          "method": "post",
          "name": "reclaimTask",
          "output": "v1/task-reclaim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/reclaim",
          "scopes": {
            "AnyOf": [
              "queue:reclaim-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:claim-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Reclaim task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "Report a task completed, resolving the run as `completed`.",
          "method": "post",
          "name": "reportCompleted",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/completed",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Run Completed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
          "method": "post",
          "name": "reportFailed",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/failed",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Run Failed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
          "input": "v1/task-exception-request.json#",
          "method": "post",
          "name": "reportException",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/exception",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Task Exception",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "description": "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they `expires`, the queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This features makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.\n\nWe currently support 3 different `storageType`s, each storage type have\nslightly different features and in some cases difference semantics.\nWe also have 2 deprecated `storageType`s which are only maintained for\nbackwards compatiability and should not be used in new implementations\n\n**Blob artifacts**, are useful for storing large files.  Currently, these\nare all stored in S3 but there are facilities for adding support for other\nbackends in futre.  A call for this type of artifact must provide information\nabout the file which will be uploaded.  This includes sha256 sums and sizes.\nThis method will return a list of general form HTTP requests which are signed\nby AWS S3 credentials managed by the Queue.  Once these requests are completed\nthe list of `ETag` values returned by the requests must be passed to the\nqueue `completeArtifact` method\n\n**S3 artifacts**, DEPRECATED is useful for static files which will be\nstored on S3. When creating an S3 artifact the queue will return a\npre-signed URL to which you can do a `PUT` request to upload your\nartifact. Note that `PUT` request **must** specify the `content-length`\nheader and **must** give the `content-type` header the same value as in\nthe request to `createArtifact`.\n\n**Azure artifacts**, DEPRECATED are stored in _Azure Blob Storage_ service\nwhich given the consistency guarantees and API interface offered by Azure\nis more suitable for artifacts that will be modified during the execution\nof the task. For example docker-worker has a feature that persists the\ntask log to Azure Blob Storage every few seconds creating a somewhat\nlive log. A request to create an Azure artifact will return a URL\nfeaturing a [Shared-Access-Signature](http://msdn.microsoft.com/en-us/library/azure/dn140256.aspx),\nrefer to MSDN for further information on how to use these.\n**Warning: azure artifact is currently an experimental feature subject\nto changes and data-drops.**\n\n**Reference artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts really only have a `url` property and\nwhen the artifact is requested the client will be redirect the URL\nprovided with a `303` (See Other) redirect. Please note that we cannot\ndelete artifacts you upload to other service, we can only delete the\nreference to the artifact, when it expires.\n\n**Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `424` (Failed Dependency) response. This is mainly designed to\nensure that dependent tasks can distinguish between artifacts that were\nsuppose to be generated and artifacts for which the name is misspelled.\n\n**Artifact immutability**, generally speaking you cannot overwrite an\nartifact when created. But if you repeat the request with the same\nproperties the request will succeed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nAs a special case the `url` property on _reference artifacts_ can be\nupdated. You should only use this to update the `url` property for\nreference artifacts your process has created.",
          "input": "v1/post-artifact-request.json#",
          "method": "post",
          "name": "createArtifact",
          "output": "v1/post-artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "AnyOf": [
              "queue:create-artifact:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:create-artifact:<name>",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Create Artifact",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "description": "This endpoint finalises an upload done through the blob `storageType`.\nThe queue will ensure that the task/run is still allowing artifacts\nto be uploaded.  For single-part S3 blob artifacts, this endpoint\nwill simply ensure the artifact is present in S3.  For multipart S3\nartifacts, the endpoint will perform the commit step of the multipart\nupload flow.  As the final step for both multi and single part artifacts,\nthe `present` entity field will be set to `true` to reflect that the\nartifact is now present and a message published to pulse.  NOTE: This\nendpoint *must* be called for all artifacts of storageType 'blob'",
          "input": "v1/put-artifact-request.json#",
          "method": "put",
          "name": "completeArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "AnyOf": [
              "queue:create-artifact:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:create-artifact:<name>",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "experimental",
          "title": "Complete Artifact",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "description": "Get artifact by `<name>` from a specific run.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with an HTTP client that can handle responses correctly.\n\n**Downloading artifacts**\nThere are some special considerations for those http clients which download\nartifacts.  This api endpoint is designed to be compatible with an HTTP 1.1\ncompliant client, but has extra features to ensure the download is valid.\nIt is strongly recommend that consumers use either taskcluster-lib-artifact (JS),\ntaskcluster-lib-artifact-go (Go) or the CLI written in Go to interact with\nartifacts.\n\nIn order to download an artifact the following must be done:\n\n1. Obtain queue url.  Building a signed url with a taskcluster client is\nrecommended\n1. Make a GET request which does not follow redirects\n1. In all cases, if specified, the\nx-taskcluster-location-{content,transfer}-{sha256,length} values must be\nvalidated to be equal to the Content-Length and Sha256 checksum of the\nfinal artifact downloaded. as well as any intermediate redirects\n1. If this response is a 500-series error, retry using an exponential\nbackoff.  No more than 5 retries should be attempted\n1. If this response is a 400-series error, treat it appropriately for\nyour context.  This might be an error in responding to this request or\nan Error storage type body.  This request should not be retried.\n1. If this response is a 200-series response, the response body is the artifact.\nIf the x-taskcluster-location-{content,transfer}-{sha256,length} and\nx-taskcluster-location-content-encoding are specified, they should match\nthis response body\n1. If the response type is a 300-series redirect, the artifact will be at the\nlocation specified by the `Location` header.  There are multiple artifact storage\ntypes which use a 300-series redirect.\n1. For all redirects followed, the user must verify that the content-sha256, content-length,\ntransfer-sha256, transfer-length and content-encoding match every further request.  The final\nartifact must also be validated against the values specified in the original queue response\n1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`\nmust not occur\n1. A request which has x-taskcluster-artifact-storage-type value of `blob` and does not\nhave x-taskcluster-location-content-sha256 or x-taskcluster-location-content-length\nmust be treated as an error\n\n**Headers**\nThe following important headers are set on the response to this method:\n\n* location: the url of the artifact if a redirect is to be performed\n* x-taskcluster-artifact-storage-type: the storage type.  Example: blob, s3, error\n\nThe following important headers are set on responses to this method for Blob artifacts\n\n* x-taskcluster-location-content-sha256: the SHA256 of the artifact\n*after* any content-encoding is undone.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-content-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-transfer-sha256: the SHA256 of the artifact\n*before* any content-encoding is undone.  This is the SHA256 of what is sent over\nthe wire.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-transfer-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-content-encoding: the content-encoding used.  It will either\nbe `gzip` or `identity` right now.  This is hardcoded to a value set when the artifact\nwas created and no content-negotiation occurs\n* x-taskcluster-location-content-type: the content-type of the artifact\n\n**Caching**, artifacts may be cached in data centers closer to the\nworkers in-order to reduce bandwidth costs. This can lead to longer\nresponse times. Caching can be skipped by setting the header\n`x-taskcluster-skip-cache: true`, this should only be used for resources\nwhere request volume is known to be low, and caching not useful.\n(This feature may be disabled in the future, use is sparingly!)",
          "method": "get",
          "name": "getArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": {
              "AllOf": [
                "queue:get-artifact:<name>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Artifact from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "name"
          ],
          "description": "Get artifact by `<name>` from the last run of a task.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
          "method": "get",
          "name": "getLatestArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": {
              "AllOf": [
                "queue:get-artifact:<name>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Artifact from Latest Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "description": "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts",
          "stability": "experimental",
          "title": "Get Artifacts from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "description": "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listLatestArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/artifacts",
          "stability": "experimental",
          "title": "Get Artifacts from Latest Run",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Get all active provisioners.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 provisioners in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listProvisioners",
          "output": "v1/list-provisioners-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners",
          "stability": "experimental",
          "title": "Get a list of all active provisioners",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "description": "Get an active provisioner.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "method": "get",
          "name": "getProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "stability": "experimental",
          "title": "Get an active provisioner",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "description": "Declare a provisioner, supplying some details about it.\n\n`declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are\npossessed. For example, a request to update the `aws-provisioner-v1`\nprovisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope\n`queue:declare-provisioner:aws-provisioner-v1#description`.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "input": "v1/update-provisioner-request.json#",
          "method": "put",
          "name": "declareProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-provisioner:<provisionerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Update a provisioner",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Get an approximate number of pending tasks for the given `provisionerId`\nand `workerType`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
          "method": "get",
          "name": "pendingTasks",
          "output": "v1/pending-tasks-response.json#",
          "query": [
          ],
          "route": "/pending/<provisionerId>/<workerType>",
          "stability": "stable",
          "title": "Get Number of Pending Tasks",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "description": "Get all active worker-types for the given provisioner.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 worker-types in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkerTypes",
          "output": "v1/list-workertypes-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners/<provisionerId>/worker-types",
          "stability": "experimental",
          "title": "Get a list of all active worker-types",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Get a worker-type from a provisioner.",
          "method": "get",
          "name": "getWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "stability": "experimental",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Declare a workerType, supplying some details about it.\n\n`declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are\npossessed. For example, a request to update the `gecko-b-1-w2008` worker-type within the `aws-provisioner-v1`\nprovisioner with a body `{description: 'This worker type is great'}` would require you to have the scope\n`queue:declare-worker-type:aws-provisioner-v1/gecko-b-1-w2008#description`.",
          "input": "v1/update-workertype-request.json#",
          "method": "put",
          "name": "declareWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker-type:<provisionerId>/<workerType>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Update a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers.\nTo filter the query, you should call the end-point with `quarantined` as a query-string option with a\ntrue or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkers",
          "output": "v1/list-workers-response.json#",
          "query": [
            "continuationToken",
            "limit",
            "quarantined"
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
          "stability": "experimental",
          "title": "Get a list of all active workers of a workerType",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "description": "Get a worker from a worker-type.",
          "method": "get",
          "name": "getWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "stability": "experimental",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "description": "Quarantine a worker",
          "input": "v1/quarantine-worker-request.json#",
          "method": "put",
          "name": "quarantineWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              "queue:quarantine-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>"
            ]
          },
          "stability": "experimental",
          "title": "Quarantine a worker",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "description": "Declare a worker, supplying some details about it.\n\n`declareWorker` allows updating one or more properties of a worker as long as the required scopes are\npossessed.",
          "input": "v1/update-worker-request.json#",
          "method": "put",
          "name": "declareWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Declare a worker",
          "type": "function"
        }
      ],
      "serviceName": "queue",
      "title": "Queue API Documentation"
    },
    "filename": "references/queue/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "purge-cache",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/purge-cache/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The purge-cache service is responsible for tracking cache-purge requests.\n\nUser create purge requests for specific caches on specific workers, and\nthese requests are timestamped.  Workers consult the service before\nstarting a new task, and purge any caches older than the timestamp.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "Publish a request to purge caches named `cacheName` with\non `provisionerId`/`workerType` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
          "input": "v1/purge-cache-request.json#",
          "method": "post",
          "name": "purgeCache",
          "query": [
          ],
          "route": "/purge-cache/<provisionerId>/<workerType>",
          "scopes": "purge-cache:<provisionerId>/<workerType>:<cacheName>",
          "stability": "stable",
          "title": "Purge Worker Cache",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
          "method": "get",
          "name": "allPurgeRequests",
          "output": "v1/all-purge-cache-request-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/purge-cache/list",
          "stability": "stable",
          "title": "All Open Purge Requests",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "description": "List the caches for this `provisionerId`/`workerType` that should to be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
          "method": "get",
          "name": "purgeRequests",
          "output": "v1/purge-cache-request-list.json#",
          "query": [
            "since"
          ],
          "route": "/purge-cache/<provisionerId>/<workerType>",
          "stability": "stable",
          "title": "Open Purge Requests for a provisionerId/workerType pair",
          "type": "function"
        }
      ],
      "serviceName": "purge-cache",
      "title": "Purge Cache API"
    },
    "filename": "references/purge-cache/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "notify",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Email has been sent.",
          "fields": {
            "address": "The requested recepient of the email."
          },
          "level": "info",
          "name": "email",
          "title": "Email Sent",
          "type": "email",
          "version": 1
        },
        {
          "description": "A pulse event has been published.",
          "fields": {
            "routingKey": "The requested routingKey of the message."
          },
          "level": "info",
          "name": "pulse",
          "title": "Pulse Event Published",
          "type": "pulse",
          "version": 1
        },
        {
          "description": "An irc message has been sent.",
          "fields": {
            "dest": "A user or channel. Will begin with \"#\" if a channel."
          },
          "level": "info",
          "name": "irc",
          "title": "IRC Message Sent",
          "type": "irc",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/notify/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This pretty much only contains the simple free-form\nmessage that can be published from this service from a request\nby anybody with the proper scopes.",
      "entries": [
        {
          "description": "An arbitrary message that a taskcluster user\ncan trigger if they like.\n\nThe standard one that is published by us watching\nfor the completion of tasks is just the task status\ndata that we pull from the queue `status()` endpoint\nwhen we notice a task is complete.",
          "exchange": "notification",
          "name": "notify",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/notification-message.json#",
          "title": "Notification Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message which is to be sent to an irc channel or\nuser is published to this exchange",
          "exchange": "irc-request",
          "name": "ircRequest",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/irc-request.json#",
          "title": "Request for irc notification",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-notify/v1/",
      "serviceName": "notify",
      "title": "Notify AMQP Exchanges"
    },
    "filename": "references/notify/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The notification service listens for tasks with associated notifications\nand handles requests to send emails and post pulse messages.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
          "input": "v1/email-request.json#",
          "method": "post",
          "name": "email",
          "query": [
          ],
          "route": "/email",
          "scopes": "notify:email:<address>",
          "stability": "experimental",
          "title": "Send an Email",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Publish a message on pulse with the given `routingKey`.",
          "input": "v1/pulse-request.json#",
          "method": "post",
          "name": "pulse",
          "query": [
          ],
          "route": "/pulse",
          "scopes": "notify:pulse:<routingKey>",
          "stability": "experimental",
          "title": "Publish a Pulse Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Post a message on IRC to a specific channel or user, or a specific user\non a specific channel.\n\nSuccess of this API method does not imply the message was successfully\nposted. This API method merely inserts the IRC message into a queue\nthat will be processed by a background process.\nThis allows us to re-send the message in face of connection issues.\n\nHowever, if the user isn't online the message will be dropped without\nerror. We maybe improve this behavior in the future. For now just keep\nin mind that IRC is a best-effort service.",
          "input": "v1/irc-request.json#",
          "method": "post",
          "name": "irc",
          "query": [
          ],
          "route": "/irc",
          "scopes": {
            "else": "notify:irc-user:<user>",
            "if": "channelRequest",
            "then": "notify:irc-channel:<channel>"
          },
          "stability": "experimental",
          "title": "Post IRC Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Add the given address to the notification denylist. The address\ncan be of either of the three supported address type namely pulse, email\nor IRC(user or channel). Addresses in the denylist will be ignored\nby the notification service.",
          "input": "v1/notification-address.json#",
          "method": "post",
          "name": "addDenylistAddress",
          "query": [
          ],
          "route": "/denylist/add",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Denylist Given Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Delete the specified address from the notification denylist.",
          "input": "v1/notification-address.json#",
          "method": "delete",
          "name": "deleteDenylistAddress",
          "query": [
          ],
          "route": "/denylist/delete",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Delete Denylisted Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Lists all the denylisted addresses.\n\nBy default this end-point will try to return up to 1000 addresses in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `list` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDenylist",
          "output": "v1/notification-address-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/denylist/list",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "List Denylisted Notifications",
          "type": "function"
        }
      ],
      "serviceName": "notify",
      "title": "Notification Service"
    },
    "filename": "references/notify/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/manifest-v3.json#",
      "references": [
        "/references/auth/v1/api.json",
        "/references/auth/v1/exchanges.json",
        "/references/auth/v1/logs.json",
        "/references/built-in-workers/v1/logs.json",
        "/references/github/v1/api.json",
        "/references/github/v1/exchanges.json",
        "/references/github/v1/logs.json",
        "/references/hooks/v1/api.json",
        "/references/hooks/v1/exchanges.json",
        "/references/hooks/v1/logs.json",
        "/references/index/v1/api.json",
        "/references/index/v1/logs.json",
        "/references/login/v1/api.json",
        "/references/login/v1/logs.json",
        "/references/notify/v1/api.json",
        "/references/notify/v1/exchanges.json",
        "/references/notify/v1/logs.json",
        "/references/purge-cache/v1/api.json",
        "/references/purge-cache/v1/logs.json",
        "/references/queue/v1/api.json",
        "/references/queue/v1/exchanges.json",
        "/references/queue/v1/logs.json",
        "/references/secrets/v1/api.json",
        "/references/secrets/v1/logs.json",
        "/references/treeherder/v1/exchanges.json",
        "/references/treeherder/v1/logs.json",
        "/references/worker-manager/v1/api.json",
        "/references/worker-manager/v1/exchanges.json",
        "/references/worker-manager/v1/logs.json"
      ]
    },
    "filename": "references/manifest.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "login",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/login/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The Login service serves as the interface between external authentication\nsystems and Taskcluster credentials.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "provider"
          ],
          "description": "Given an OIDC `access_token` from a trusted OpenID provider, return a\nset of Taskcluster credentials for use on behalf of the identified\nuser.\n\nThis method is typically not called with a Taskcluster client library\nand does not accept Hawk credentials. The `access_token` should be\ngiven in an `Authorization` header:\n```\nAuthorization: Bearer abc.xyz\n```\n\nThe `access_token` is first verified against the named\n:provider, then passed to the provider's APIBuilder to retrieve a user\nprofile. That profile is then used to generate Taskcluster credentials\nappropriate to the user. Note that the resulting credentials may or may\nnot include a `certificate` property. Callers should be prepared for either\nalternative.\n\nThe given credentials will expire in a relatively short time. Callers should\nmonitor this expiration and refresh the credentials if necessary, by calling\nthis endpoint again, if they have expired.",
          "method": "get",
          "name": "oidcCredentials",
          "output": "v1/oidc-credentials-response.json#",
          "query": [
          ],
          "route": "/oidc-credentials/<provider>",
          "stability": "experimental",
          "title": "Get Taskcluster credentials given a suitable `access_token`",
          "type": "function"
        }
      ],
      "serviceName": "login",
      "title": "Login API"
    },
    "filename": "references/login/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "index",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/index/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The index service is responsible for indexing tasks. The service ensures that\ntasks can be located by user-defined names.\n\nAs described in the service documentation, tasks are typically indexed via Pulse\nmessages, so the most common use of API methods is to read from the index.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "indexPath"
          ],
          "description": "Find a task by index path, returning the highest-rank task with that path. If no\ntask exists for the given path, this API end-point will respond with a 404 status.",
          "method": "get",
          "name": "findTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<indexPath>",
          "stability": "stable",
          "title": "Find Indexed Task",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "description": "List the namespaces immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 namespaces. If more namespaces are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.",
          "method": "get",
          "name": "listNamespaces",
          "output": "v1/list-namespaces-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/namespaces/<namespace>",
          "stability": "stable",
          "title": "List Namespaces",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "description": "List the tasks immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 tasks. If more tasks are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
          "method": "get",
          "name": "listTasks",
          "output": "v1/list-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/tasks/<namespace>",
          "stability": "stable",
          "title": "List Tasks",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "description": "Insert a task into the index.  If the new rank is less than the existing rank\nat the given index path, the task is not indexed but the response is still 200 OK.\n\nPlease see the introduction above for information\nabout indexing successfully completed tasks automatically using custom routes.",
          "input": "v1/insert-task-request.json#",
          "method": "put",
          "name": "insertTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<namespace>",
          "scopes": "index:insert-task:<namespace>",
          "stability": "stable",
          "title": "Insert Task into Index",
          "type": "function"
        },
        {
          "args": [
            "indexPath",
            "name"
          ],
          "description": "Find a task by index path and redirect to the artifact on the most recent\nrun with the given `name`.\n\nNote that multiple calls to this endpoint may return artifacts from differen tasks\nif a new task is inserted into the index between calls. Avoid using this method as\na stable link to multiple, connected files if the index path does not contain a\nunique identifier.  For example, the following two links may return unrelated files:\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/installer.exe`\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/debug-symbols.zip`\n\nThis problem be remedied by including the revision in the index path or by bundling both\ninstaller and debug symbols into a single artifact.\n\nIf no task exists for the given index path, this API end-point responds with 404.",
          "method": "get",
          "name": "findArtifactFromTask",
          "query": [
          ],
          "route": "/task/<indexPath>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": "queue:get-artifact:<name>"
          },
          "stability": "stable",
          "title": "Get Artifact From Indexed Task",
          "type": "function"
        }
      ],
      "serviceName": "index",
      "title": "Task Index API Documentation"
    },
    "filename": "references/index/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "hooks",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/hooks/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service is responsible for creating tasks at specific times orin .  response to webhooks and API calls.Using this exchange allows us tomake hooks which repsond to particular pulse messagesThese exchanges provide notifications when a hook is created, updatedor deleted. This is so that the listener running in a different hooks process at the other end can direct another listener specified by`hookGroupId` and `hookId` to synchronize its bindings. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create apulse based hook, a message is posted to this exchange andthe receiver creates a listener with the bindings, to create a task",
          "exchange": "hook-created",
          "name": "hookCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update apulse based hook, a message is posted to this exchange andthe receiver updates the listener associated with that hook.",
          "exchange": "hook-updated",
          "name": "hookUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to delete apulse based hook, a message is posted to this exchange andthe receiver deletes the listener associated with that hook.",
          "exchange": "hook-deleted",
          "name": "hookDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-hooks/v1/",
      "serviceName": "hooks",
      "title": "Exchanges to manage hooks"
    },
    "filename": "references/hooks/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service provides a mechanism for creating tasks in response to events.\n",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "This endpoint will return a list of all hook groups with at least one hook.",
          "method": "get",
          "name": "listHookGroups",
          "output": "v1/list-hook-groups-response.json#",
          "query": [
          ],
          "route": "/hooks",
          "stability": "stable",
          "title": "List hook groups",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId"
          ],
          "description": "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
          "method": "get",
          "name": "listHooks",
          "output": "v1/list-hooks-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>",
          "stability": "stable",
          "title": "List hooks in a given group",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
          "method": "get",
          "name": "hook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get hook definition",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.\n\nThis method is deprecated in favor of listLastFires.",
          "method": "get",
          "name": "getHookStatus",
          "output": "v1/hook-status.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/status",
          "stability": "deprecated",
          "title": "Get hook status",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.",
          "input": "v1/create-hook-request.json#",
          "method": "put",
          "name": "createHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Create a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
          "input": "v1/create-hook-request.json#",
          "method": "post",
          "name": "updateHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Update a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will remove a hook definition.",
          "method": "delete",
          "name": "removeHook",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": "hooks:modify-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Delete a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will trigger the creation of a task from a hook definition.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHook",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger",
          "scopes": "hooks:trigger-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Trigger a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
          "method": "get",
          "name": "getTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:get-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
          "method": "post",
          "name": "resetTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:reset-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Reset a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId",
            "token"
          ],
          "description": "This endpoint triggers a defined hook with a valid token.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHookWithToken",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
          "stability": "stable",
          "title": "Trigger a hook with a token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "description": "This endpoint will return information about the the last few times this hook has been\nfired, including whether the hook was fired successfully or not",
          "method": "get",
          "name": "listLastFires",
          "output": "v1/list-lastFires-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/last-fires",
          "stability": "experimental",
          "title": "Get information about recent hook fires",
          "type": "function"
        }
      ],
      "serviceName": "hooks",
      "title": "Hooks API Documentation"
    },
    "filename": "references/hooks/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "github",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/github/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service publishes a pulse\nmessage for supported github events, translating Github webhook\nevents into pulse messages.\n\nThis document describes the exchange offered by the taskcluster\ngithub service",
      "entries": [
        {
          "description": "When a GitHub pull request event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "pull-request",
          "name": "pullRequest",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "action",
              "required": true,
              "summary": "The GitHub `action` which triggered an event. See for possible values see the payload actions property."
            }
          ],
          "schema": "v1/github-pull-request-message.json#",
          "title": "GitHub Pull Request Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub push event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "push",
          "name": "push",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-push-message.json#",
          "title": "GitHub push Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub release event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "release",
          "name": "release",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-release-message.json#",
          "title": "GitHub release Event",
          "type": "topic-exchange"
        },
        {
          "description": "supposed to signal that taskCreate API has been called for every task in the task group\nfor this particular repo and this particular organization\ncurrently used for creating initial status indicators in GitHub UI using Statuses API.\nThis particular exchange can also be bound to RabbitMQ queues by custom routes - for that,\nPass in the array of routes as a second argument to the publish method. Currently, we do\nuse the statuses routes to bind the handler that creates the initial status.",
          "exchange": "task-group-creation-requested",
          "name": "taskGroupCreationRequested",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/task-group-creation-requested.json#",
          "title": "tc-gh requested the Queue service to create all the tasks in a group",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-github/v1/",
      "serviceName": "github",
      "title": "Taskcluster-Github Exchanges"
    },
    "filename": "references/github/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service is responsible for creating tasks in reposnse\nto GitHub events, and posting results to the GitHub UI.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks, as well as some useful consumer APIs.\n\nWhen Github forbids an action, this service returns an HTTP 403\nwith code ForbiddenByGithub.",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease or pull request.",
          "method": "post",
          "name": "githubWebHookConsumer",
          "query": [
          ],
          "route": "/github",
          "stability": "experimental",
          "title": "Consume GitHub WebHook",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
          "method": "get",
          "name": "builds",
          "output": "v1/build-list.json#",
          "query": [
            "continuationToken",
            "limit",
            "organization",
            "repository",
            "sha"
          ],
          "route": "/builds",
          "stability": "experimental",
          "title": "List of Builds",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "description": "Checks the status of the latest build of a given branch\nand returns corresponding badge svg.",
          "method": "get",
          "name": "badge",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/badge.svg",
          "stability": "experimental",
          "title": "Latest Build Status Badge",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo"
          ],
          "description": "Returns any repository metadata that is\nuseful within Taskcluster related services.",
          "method": "get",
          "name": "repository",
          "output": "v1/repository.json#",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>",
          "stability": "experimental",
          "title": "Get Repository Info",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "description": "For a given branch of a repository, this will always point\nto a status page for the most recent task triggered by that\nbranch.\n\nNote: This is a redirect rather than a direct link.",
          "method": "get",
          "name": "latest",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/latest",
          "stability": "experimental",
          "title": "Latest Status for Branch",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "sha"
          ],
          "description": "For a given changeset (SHA) of a repository, this will attach a \"commit status\"\non github. These statuses are links displayed next to each revision.\nThe status is either OK (green check) or FAILURE (red cross), \nmade of a custom title and link.",
          "input": "v1/create-status.json#",
          "method": "post",
          "name": "createStatus",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/statuses/<sha>",
          "scopes": "github:create-status:<owner>/<repo>",
          "stability": "experimental",
          "title": "Post a status against a given changeset",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "number"
          ],
          "description": "For a given Issue or Pull Request of a repository, this will write a new message.",
          "input": "v1/create-comment.json#",
          "method": "post",
          "name": "createComment",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/issues/<number>/comments",
          "scopes": "github:create-comment:<owner>/<repo>",
          "stability": "experimental",
          "title": "Post a comment on a given GitHub Issue or Pull Request",
          "type": "function"
        }
      ],
      "serviceName": "github",
      "title": "Taskcluster GitHub API Documentation"
    },
    "filename": "references/github/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "built-in-workers",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        }
      ]
    },
    "filename": "references/built-in-workers/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "auth",
      "types": [
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/auth/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The auth service is responsible for storing credentials, managing\nassignment of scopes, and validation of request signatures from other\nservices.\n\nThese exchanges provides notifications when credentials or roles are\nupdated. This is mostly so that multiple instances of the auth service\ncan purge their caches and synchronize state. But you are of course\nwelcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Message that a new client has been created.",
          "exchange": "client-created",
          "name": "clientCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been updated.",
          "exchange": "client-updated",
          "name": "clientUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been deleted.",
          "exchange": "client-deleted",
          "name": "clientDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Deleted Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been created.",
          "exchange": "role-created",
          "name": "roleCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been updated.",
          "exchange": "role-updated",
          "name": "roleUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been deleted.",
          "exchange": "role-deleted",
          "name": "roleDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-auth/v1/",
      "serviceName": "auth",
      "title": "Auth Pulse Exchanges"
    },
    "filename": "references/auth/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "Authentication related API end-points for Taskcluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authorize a request signed with Taskcluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n",
      "entries": [
        {
          "args": [
          ],
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.\n\nBy default this end-point will try to return up to 1000 clients in one\nrequest. But it **may return less, even none**.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listClients` with the last `continuationToken` until you\nget a result without a `continuationToken`.",
          "method": "get",
          "name": "listClients",
          "output": "v1/list-clients-response.json#",
          "query": [
            "prefix",
            "continuationToken",
            "limit"
          ],
          "route": "/clients/",
          "stability": "stable",
          "title": "List Clients",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Get information about a single client.",
          "method": "get",
          "name": "client",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "stability": "stable",
          "title": "Get Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
          "input": "v1/create-client-request.json#",
          "method": "put",
          "name": "createClient",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:create-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
          "method": "post",
          "name": "resetAccessToken",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/reset",
          "scopes": "auth:reset-access-token:<clientId>",
          "stability": "stable",
          "title": "Reset `accessToken`",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
          "input": "v1/create-client-request.json#",
          "method": "post",
          "name": "updateClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:update-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
          "method": "post",
          "name": "enableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/enable",
          "scopes": "auth:enable-client:<clientId>",
          "stability": "stable",
          "title": "Enable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
          "method": "post",
          "name": "disableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/disable",
          "scopes": "auth:disable-client:<clientId>",
          "stability": "stable",
          "title": "Disable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "description": "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
          "method": "delete",
          "name": "deleteClient",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": "auth:delete-client:<clientId>",
          "stability": "stable",
          "title": "Delete Client",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Get a list of all roles, each role object also includes the list of\nscopes it expands to.",
          "method": "get",
          "name": "listRoles",
          "output": "v1/list-roles-response.json#",
          "query": [
          ],
          "route": "/roles/",
          "stability": "stable",
          "title": "List Roles",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "If no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoleIds",
          "output": "v1/list-role-ids-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roleids/",
          "stability": "stable",
          "title": "List Role IDs",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "If no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoles2",
          "output": "v1/list-roles2-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roles2/",
          "stability": "stable",
          "title": "List Roles",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "description": "Get information about a single role, including the set of scopes that the\nrole expands to.",
          "method": "get",
          "name": "role",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "stability": "stable",
          "title": "Get Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "description": "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.\n\nCreation of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "put",
          "name": "createRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:create-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "description": "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the role's existing scopes.\n\nAn update of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "post",
          "name": "updateRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:update-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "description": "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
          "method": "delete",
          "name": "deleteRole",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": "auth:delete-role:<roleId>",
          "stability": "stable",
          "title": "Delete Role",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.\n\nThis call uses the GET method with an HTTP body.  It remains only for\nbackward compatibility.",
          "input": "v1/scopeset.json#",
          "method": "get",
          "name": "expandScopesGet",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/expand",
          "stability": "deprecated",
          "title": "Expand Scopes",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
          "input": "v1/scopeset.json#",
          "method": "post",
          "name": "expandScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/expand",
          "stability": "stable",
          "title": "Expand Scopes",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
          "method": "get",
          "name": "currentScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/current",
          "stability": "stable",
          "title": "Get Current Scopes",
          "type": "function"
        },
        {
          "args": [
            "level",
            "bucket",
            "prefix"
          ],
          "description": "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets.  To add\na bucket to that whitelist, contact the Taskcluster team, who will add it to\nthe appropriate IAM policy.  If the bucket is in a different AWS account, you\nwill also need to add a bucket policy allowing access from the Taskcluster\naccount.  That policy should look like this:\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"allow-taskcluster-auth-to-delegate-access\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::692406183521:root\"\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\",\n        \"s3:GetBucketLocation\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::<bucket>\",\n        \"arn:aws:s3:::<bucket>/*\"\n      ]\n    }\n  ]\n}\n```\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
          "method": "get",
          "name": "awsS3Credentials",
          "output": "v1/aws-s3-credentials-response.json#",
          "query": [
            "format"
          ],
          "route": "/aws/s3/<level>/<bucket>/<prefix>",
          "scopes": {
            "else": "auth:aws-s3:read-write:<bucket>/<prefix>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:aws-s3:read-only:<bucket>/<prefix>",
                "auth:aws-s3:read-write:<bucket>/<prefix>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Temporary Read/Write Credentials S3",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Retrieve a list of all Azure accounts managed by Taskcluster Auth.",
          "method": "get",
          "name": "azureAccounts",
          "output": "v1/azure-account-list-response.json#",
          "query": [
          ],
          "route": "/azure/accounts",
          "scopes": "auth:azure-table:list-accounts",
          "stability": "stable",
          "title": "List Accounts Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "description": "Retrieve a list of all tables in an account.",
          "method": "get",
          "name": "azureTables",
          "output": "v1/azure-table-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/tables",
          "scopes": "auth:azure-table:list-tables:<account>",
          "stability": "stable",
          "title": "List Tables in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "table",
            "level"
          ],
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ntable if it doesn't already exist.",
          "method": "get",
          "name": "azureTableSAS",
          "output": "v1/azure-table-access-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/table/<table>/<level>",
          "scopes": {
            "else": "auth:azure-table:read-write:<account>/<table>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-table:read-only:<account>/<table>",
                "auth:azure-table:read-write:<account>/<table>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Shared-Access-Signature for Azure Table",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "description": "Retrieve a list of all containers in an account.",
          "method": "get",
          "name": "azureContainers",
          "output": "v1/azure-container-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/containers",
          "scopes": "auth:azure-container:list-containers:<account>",
          "stability": "stable",
          "title": "List containers in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "container",
            "level"
          ],
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nBlob Storage container.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ncontainer if it doesn't already exist.",
          "method": "get",
          "name": "azureContainerSAS",
          "output": "v1/azure-container-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/containers/<container>/<level>",
          "scopes": {
            "else": "auth:azure-container:read-write:<account>/<container>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-container:read-only:<account>/<container>",
                "auth:azure-container:read-write:<account>/<container>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Shared-Access-Signature for Azure Container",
          "type": "function"
        },
        {
          "args": [
            "project"
          ],
          "description": "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
          "method": "get",
          "name": "sentryDSN",
          "output": "v1/sentry-dsn-response.json#",
          "query": [
          ],
          "route": "/sentry/<project>/dsn",
          "scopes": "auth:sentry:<project>",
          "stability": "stable",
          "title": "Get DSN for Sentry Project",
          "type": "function"
        },
        {
          "args": [
            "project"
          ],
          "description": "Get temporary `token` and `baseUrl` for sending metrics to statsum.\n\nThe token is valid for 24 hours, clients should refresh after expiration.",
          "method": "get",
          "name": "statsumToken",
          "output": "v1/statsum-token-response.json#",
          "query": [
          ],
          "route": "/statsum/<project>/token",
          "scopes": "auth:statsum:<project>",
          "stability": "stable",
          "title": "Get Token for Statsum Project",
          "type": "function"
        },
        {
          "args": [
            "wstAudience",
            "wstClient"
          ],
          "description": "Get a temporary token suitable for use connecting to a\n[websocktunnel](https://github.com/taskcluster/websocktunnel) server.\n\nThe resulting token will only be accepted by servers with a matching audience\nvalue.  Reaching such a server is the callers responsibility.  In general,\na server URL or set of URLs should be provided to the caller as configuration\nalong with the audience value.\n\nThe token is valid for a limited time (on the scale of hours). Callers should\nrefresh it before expiration.",
          "method": "get",
          "name": "websocktunnelToken",
          "output": "v1/websocktunnel-token-response.json#",
          "query": [
          ],
          "route": "/websocktunnel/<wstAudience>/<wstClient>",
          "scopes": "auth:websocktunnel-token:<wstAudience>/<wstClient>",
          "stability": "stable",
          "title": "Get a client token for the Websocktunnel service",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on Taskcluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
          "input": "v1/authenticate-hawk-request.json#",
          "method": "post",
          "name": "authenticateHawk",
          "output": "v1/authenticate-hawk-response.json#",
          "query": [
          ],
          "route": "/authenticate-hawk",
          "stability": "stable",
          "title": "Authenticate Hawk Request",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Utility method to test client implementations of Taskcluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
          "input": "v1/test-authenticate-request.json#",
          "method": "post",
          "name": "testAuthenticate",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate",
          "stability": "stable",
          "title": "Test Authentication",
          "type": "function"
        },
        {
          "args": [
          ],
          "description": "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the \n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
          "method": "get",
          "name": "testAuthenticateGet",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate-get/",
          "stability": "stable",
          "title": "Test Authentication (GET)",
          "type": "function"
        }
      ],
      "serviceName": "auth",
      "title": "Authentication API"
    },
    "filename": "references/auth/v1/api.json"
  }
]