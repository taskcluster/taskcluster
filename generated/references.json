[
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of worker pools",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerPools": {
          "description": "List of all worker pools",
          "items": {
            "$ref": "worker-pool-full.json#"
          },
          "title": "Worker Pools",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerPools"
      ],
      "title": "Worker Pool List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-full.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker pool definition.\n",
      "properties": {
        "config": {
          "additionalProperties": true,
          "type": "object"
        },
        "created": {
          "description": "Date and time when this worker pool was created\n",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "description": {
          "description": "A description of this worker pool.\n",
          "maxLength": 10240,
          "title": "Description",
          "type": "string"
        },
        "emailOnError": {
          "description": "If true, the owner should be emailed on provisioning errors",
          "title": "Wants Email",
          "type": "boolean"
        },
        "lastModified": {
          "description": "Date and time when this worker pool was last updated\n",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "owner": {
          "description": "An email address to notify when there are provisioning errors for this\nworker pool.\n",
          "format": "email",
          "title": "Owner Email",
          "type": "string"
        },
        "providerId": {
          "description": "The provider responsible for managing this worker pool.\n\nIf this value is `\"null-provider\"`, then the worker pool is pending deletion\nonce all existing workers have terminated.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "workerPoolId": {
          "description": "The ID of this worker pool (of the form `providerId/workerType` for compatibility)\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Pool ID",
          "type": "string"
        }
      },
      "required": [
        "providerId",
        "description",
        "created",
        "lastModified",
        "config",
        "owner",
        "emailOnError"
      ],
      "title": "Worker Pool Full Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-full.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-error.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker pool error definition.\n",
      "properties": {
        "description": {
          "description": "A longer description of what occured in the error.",
          "maxLength": 10240,
          "title": "Description",
          "type": "string"
        },
        "errorId": {
          "description": "An arbitary unique identifier for this error",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Error ID",
          "type": "string"
        },
        "extra": {
          "additionalProperties": true,
          "description": "Any extra structured information about this error",
          "title": "Extra",
          "type": "object"
        },
        "kind": {
          "description": "A general machine-readable way to identify this sort of error.",
          "maxLength": 128,
          "pattern": "[-a-z0-9]+",
          "title": "Kind",
          "type": "string"
        },
        "reported": {
          "description": "Date and time when this error was reported",
          "format": "date-time",
          "title": "Reported",
          "type": "string"
        },
        "title": {
          "description": "A human-readable version of `kind`.",
          "maxLength": 128,
          "title": "Title",
          "type": "string"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "errorId",
        "reported",
        "kind",
        "title",
        "description",
        "extra"
      ],
      "title": "Worker Pool Error",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-error.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-pool-error-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of worker pool errors",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerPoolErrors": {
          "description": "List of worker pool errors",
          "items": {
            "$ref": "worker-pool-error.json#"
          },
          "title": "Worker Pool Errors",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerPoolErrors"
      ],
      "title": "Worker Pool Error List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-pool-error-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of workers in a given worker pool",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of all workers in a given worker pool",
          "items": {
            "$ref": "worker-full.json#"
          },
          "title": "Workers",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "Worker List in a Given Worker Pool",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/worker-full.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A complete worker definition.",
      "properties": {
        "created": {
          "description": "Date and time when this worker was created",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "expires": {
          "description": "Date and time when this worker will be deleted from the DB",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "providerId": {
          "description": "The provider that had started the worker and responsible for managing it.\nCan be different from the provider that's currently in the worker pool config.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Provider",
          "type": "string"
        },
        "state": {
          "description": "A string specifying the state this worker is in so far as worker-manager knows.\n",
          "enum": [
            "requested",
            "running",
            "stopped"
          ],
          "title": "State",
          "type": "string"
        },
        "workerGroup": {
          "description": "Worker group to which this worker belongs",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker group",
          "type": "string"
        },
        "workerId": {
          "description": "Worker ID",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker ID",
          "type": "string"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "workerGroup",
        "workerId",
        "providerId",
        "created",
        "expires",
        "state"
      ],
      "title": "Worker Full Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/worker-full.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/update-worker-pool-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Fields that are defined by a user for a worker pool.\nUsed to modify worker-pool definitions.\n\nThe `workerPoolId`, `created`, and `lastModified` fields are optional and\nallowed only to ease the common practice of getting a worker pool definition\nwith `workerPool(..)`, modifying it, and writing it back with\n`updateWorkerPool(..).  `workerPoolId` must be correct if\nsupplied, and the values of `created` and `lastModified` are ignored.\n",
      "properties": {
        "config": {
          "$ref": "worker-pool-full.json#/properties/config"
        },
        "created": {
          "description": "Ignored on update",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "description": {
          "$ref": "worker-pool-full.json#/properties/description"
        },
        "emailOnError": {
          "$ref": "worker-pool-full.json#/properties/emailOnError"
        },
        "lastModified": {
          "description": "Ignored on update",
          "format": "date-time",
          "title": "Last Modified",
          "type": "string"
        },
        "owner": {
          "$ref": "worker-pool-full.json#/properties/owner"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        },
        "workerPoolId": {
          "pattern": "^[a-zA-Z0-9-_]{1,38}/[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Pool ID",
          "type": "string"
        }
      },
      "required": [
        "providerId",
        "description",
        "config",
        "owner",
        "emailOnError"
      ],
      "title": "Worker Pool Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/update-worker-pool-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/report-worker-error-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A report of an error from a worker.  This will be recorded with kind\n`worker-error`.\n\nThe worker's `workerGroup` and `workerId` will be added to `extra`.\n",
      "properties": {
        "description": {
          "$ref": "worker-pool-error.json#/properties/description"
        },
        "extra": {
          "$ref": "worker-pool-error.json#/properties/extra"
        },
        "kind": {
          "$ref": "worker-pool-error.json#/properties/kind"
        },
        "title": {
          "$ref": "worker-pool-error.json#/properties/title"
        },
        "workerGroup": {
          "$ref": "worker-full.json#/properties/workerGroup"
        },
        "workerId": {
          "$ref": "worker-full.json#/properties/workerId"
        }
      },
      "required": [
        "workerGroup",
        "workerId",
        "kind",
        "title",
        "description",
        "extra"
      ],
      "title": "Worker Error Report",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/report-worker-error-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/register-worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response body to `registerWorker`.",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "The credentials the worker\nwill need to perform its work.  Specifically, credentials with scopes\n* `assume:worker-pool:<workerPoolId>`\n* `assume:worker-id:<workerGroup>/<workerId>`\n* `queue:worker-id:<workerGroup>/<workerId>`\n* `secrets:get:worker-pool:<workerPoolId>`\n* `queue:claim-work:<workerPoolId>`\n",
          "properties": {
            "accessToken": {
              "type": "string"
            },
            "certificate": {
              "description": "Note that a certificate may not be provided, if the credentials are not temporary.\n",
              "type": "string"
            },
            "clientId": {
              "type": "string"
            }
          },
          "required": [
            "accessToken",
            "clientId"
          ],
          "title": "Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Time at which the included credentials will expire.  Workers must either\nre-register (for static workers) or terminate (for dynamically\nprovisioned workers) before this time.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        }
      },
      "required": [
        "expires",
        "credentials"
      ],
      "title": "Register Worker Response",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/register-worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/register-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request body to `registerWorker`.",
      "properties": {
        "providerId": {
          "$ref": "worker-full.json#/properties/providerId"
        },
        "workerGroup": {
          "$ref": "worker-full.json#/properties/workerGroup"
        },
        "workerId": {
          "$ref": "worker-full.json#/properties/workerId"
        },
        "workerIdentityProof": {
          "description": "Proof that this call is coming from the worker identified by the other fields.\nThe form of this proof varies depending on the provider type.\n",
          "oneOf": [
            {
              "additionalProperties": false,
              "properties": {
                "token": {
                  "description": "A JWT token as defined in [this google documentation](https://cloud.google.com/compute/docs/instances/verifying-instance-identity)\n",
                  "title": "Token",
                  "type": "string"
                }
              },
              "required": [
                "token"
              ],
              "title": "google provider type",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "staticSecret": {
                  "description": "The secret value that was configured when the worker was created (in `createWorker`).\n",
                  "pattern": "^[a-zA-Z0-9_-]{44}$",
                  "title": "Secret",
                  "type": "string"
                }
              },
              "required": [
                "staticSecret"
              ],
              "title": "static provider type",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "properties": {
                "document": {
                  "description": "Instance identity document that is obtained by\ncurl http://169.254.169.254/latest/dynamic/instance-identity/document on the instance\n",
                  "title": "Document"
                },
                "signature": {
                  "description": "The signature for instance identity document. Can be obtained by\ncurl http://169.254.169.254/latest/dynamic/instance-identity/signature on the instance\n",
                  "title": "Signature",
                  "type": "string"
                }
              },
              "required": [
                "document",
                "signature"
              ],
              "title": "aws provider type",
              "type": "object"
            }
          ],
          "title": "Worker Identity Proof"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "providerId",
        "workerGroup",
        "workerId",
        "workerIdentityProof"
      ],
      "title": "Register Worker Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/register-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/pulse-worker-pool-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "The message that is emitted when worker pools are created/changed/deleted.",
      "properties": {
        "previousProviderId": {
          "description": "If this is defined, it was the provider that handled this worker pool in the \nconfiguration before the current one. This will be used by providers to clean\nup any resources created for this workerType when they are no longer responsible\nfor it.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Previous Provider",
          "type": "string"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        },
        "workerPoolId": {
          "$ref": "worker-pool-full.json#/properties/workerPoolId"
        }
      },
      "required": [
        "workerPoolId",
        "providerId"
      ],
      "title": "WorkerType Pulse Message",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/pulse-worker-pool-message.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/provider-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of providers",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-manager.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerPools` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "providers": {
          "description": "List of all providers",
          "items": {
            "additionalProperties": false,
            "properties": {
              "providerId": {
                "description": "The id of this provider",
                "title": "Provider ID",
                "type": "string"
              },
              "providerType": {
                "description": "The provider implementation underlying this provider",
                "title": "Provider Type",
                "type": "string"
              }
            },
            "required": [
              "providerId",
              "providerType"
            ],
            "type": "object"
          },
          "title": "Providers",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "providers"
      ],
      "title": "Provider List",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/provider-list.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/create-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to create a worker",
      "properties": {
        "expires": {
          "description": "Date and time when this worker will be deleted from the DB",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "providerInfo": {
          "description": "Provider-specific information",
          "oneOf": [
            {
              "additionalProperties": false,
              "properties": {
                "staticSecret": {
                  "description": "A secret value shared with the worker.  This value must be passed in the `workerIdentityProof` of the `registerWorker` method.\nThe ideal way to generate a secret of this form is `slugid() + slugid()`.\n\nSecrets are traded for Taskcluster credentials, and should be treated with similar care.\nEach worker should have a distinct secret.\n",
                  "pattern": "^[a-zA-Z0-9_-]{44}$",
                  "title": "Secret",
                  "type": "string"
                }
              },
              "required": [
                "staticSecret"
              ],
              "title": "static provider type",
              "type": "object"
            }
          ],
          "title": "Provider Data"
        }
      },
      "required": [
        "expires"
      ],
      "title": "Worker Creation Request",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/create-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/create-worker-pool-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Fields that are defined by a user for a worker pool.\nUsed to create worker-pool definitions. There is a larger\nset of fields for viewing since some parts are generated\nby the service.\n",
      "properties": {
        "config": {
          "$ref": "worker-pool-full.json#/properties/config"
        },
        "description": {
          "$ref": "worker-pool-full.json#/properties/description"
        },
        "emailOnError": {
          "$ref": "worker-pool-full.json#/properties/emailOnError"
        },
        "owner": {
          "$ref": "worker-pool-full.json#/properties/owner"
        },
        "providerId": {
          "$ref": "worker-pool-full.json#/properties/providerId"
        }
      },
      "required": [
        "providerId",
        "description",
        "config",
        "owner",
        "emailOnError"
      ],
      "title": "Worker Pool Definition",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/create-worker-pool-request.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-testing.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A provider used for testing",
      "title": "Testing Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-testing.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-static.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A configuration for static workertypes",
      "title": "Static Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-static.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-null.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "A special provider indicating that no provisioning takes place.\n\nNote that this provider allows any configuration, but ignores it. This saves\nthe trouble of removing the config from a worker-pool when deleting it.\n",
      "title": "Null Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-null.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-google.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "'The config section of a workertype is using a provider with implementation google must match this.\nMuch of these fields are documented [here](https://cloud.google.com/compute/docs/reference/rest/v1/instanceTemplates)'\n",
      "properties": {
        "launchConfigs": {
          "description": "An array of possible variations of workers for this pool. Allows to vary across regions/zones/machineType/etc\nEach choice must include at least the required properties but can also include anything in\nthe request body of [the instance creation](https://cloud.google.com/compute/docs/reference/rest/beta/instances/insert)\napi method from gcloud. That said, worker-manager sets `instanceName` and `serviceAccounts` directly and you\ncannot override these. It also fills in some basic labels, will generate a default description, and sets the `taskcluster`\nmetadata key directly. You are free to set other metadata items though. A subset of these fields we require you to set such as `machineType`.\n",
          "items": {
            "additionalProperties": true,
            "properties": {
              "capacityPerInstance": {
                "description": "The number of tasks a single worker of this type can run at any given time.",
                "minimum": 1,
                "title": "Capacity Per Instance",
                "type": "integer"
              },
              "disks": {
                "description": "Defined in detail in the google doc above.",
                "title": "Disks",
                "type": "array",
                "uniqueItems": false
              },
              "machineType": {
                "description": "Full or partial URL of the machine type resource to use. Defined in detail in the google doc above",
                "title": "Machine Type",
                "type": "string"
              },
              "networkInterfaces": {
                "description": "Defined in detail in the google doc above.",
                "title": "Network Interfaces",
                "type": "array",
                "uniqueItems": false
              },
              "region": {
                "description": "The gcloud region this worker should be spawned in",
                "title": "Region",
                "type": "string"
              },
              "scheduling": {
                "additionalProperties": true,
                "description": "Defined in detail in the google doc above. Worker manager harcodes values for `automaticRestart` but\nyou can set all other fields.\n",
                "title": "Scheduling",
                "type": "object"
              },
              "workerConfig": {
                "additionalProperties": true,
                "description": "This value is supplied unchanged as the `workerConfig` property of the `taskcluster` instance metadata attribute.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [taskcluster-worker-runner](https://github.com/taskcluster/taskcluster-worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://github.com/taskcluster/taskcluster-worker-runner#secrets).\n",
                "title": "Worker Config",
                "type": "object"
              },
              "zone": {
                "description": "The gcloud az this worker should be spawned in. This az must be included because many resources (such as\nmachine types and disk types) are az-specific.\n",
                "title": "Availability Zone",
                "type": "string"
              }
            },
            "required": [
              "capacityPerInstance",
              "workerConfig",
              "region",
              "zone",
              "machineType",
              "disks",
              "networkInterfaces",
              "scheduling"
            ],
            "type": "object"
          },
          "title": "Choices",
          "type": "array",
          "uniqueItems": false
        },
        "maxCapacity": {
          "description": "The maximum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "The minimum amount of capacity that worker-manager should make\navailable at any given time.\n",
          "minimum": 0,
          "title": "Minimum Capacity",
          "type": "integer"
        }
      },
      "required": [
        "minCapacity",
        "maxCapacity",
        "launchConfigs"
      ],
      "title": "Google Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-google.json"
  },
  {
    "content": {
      "$id": "/schemas/worker-manager/v1/config-aws.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Object with an array of possible options for different regions",
      "properties": {
        "launchConfigs": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "additionalUserData": {
                "additionalProperties": true,
                "properties": {
                  "providerId": {
                    "not": {
                    }
                  },
                  "rootUrl": {
                    "not": {
                    }
                  },
                  "workerConfig": {
                    "not": {
                    }
                  },
                  "workerGroup": {
                    "not": {
                    }
                  },
                  "workerPoolId": {
                    "not": {
                    }
                  }
                },
                "required": [
                ],
                "type": "object"
              },
              "capacityPerInstance": {
                "description": "The number of tasks a single worker of this type can run at any given time.",
                "minimum": 1,
                "title": "Capacity Per Instance",
                "type": "integer"
              },
              "launchConfig": {
                "additionalProperties": true,
                "description": "An object to be passed in to AWS runInstances method.\nSee the documentation [here](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/EC2.html#runInstances-property)\nYou can configure any properties you need. Note, however, that we disallow passing in arbitrary IAM instance profiles.\n",
                "not": {
                  "required": [
                    "IamInstanceProfile",
                    "UserData",
                    "MinCount",
                    "MaxCount"
                  ]
                },
                "properties": {
                  "ImageId": {
                    "description": "The ID of the AMI to launch an instance from.",
                    "type": "string"
                  }
                },
                "required": [
                  "ImageId"
                ],
                "title": "Launch Configuration",
                "type": "object"
              },
              "region": {
                "description": "AWS region (not to be confused with AZ) to launch the instances in",
                "title": "Region",
                "type": "string"
              },
              "workerConfig": {
                "additionalProperties": true,
                "description": "This value is supplied unchanged as the `workerConfig` property of the `taskcluster` instance metadata attribute.\nThe expectation is that the worker will merge this information with configuration from other sources,\nand this is precisely what [taskcluster-worker-runner](https://github.com/taskcluster/taskcluster-worker-runner) does.\nThis property must not be used for secret configuration, as it is visible both in the worker pool configuration and in the worker instance's metadata.\nInstead, put secret configuration in the [secrets service](https://github.com/taskcluster/taskcluster-worker-runner#secrets).\n",
                "title": "Worker Config",
                "type": "object"
              }
            },
            "required": [
              "region",
              "launchConfig",
              "capacityPerInstance"
            ],
            "type": "object"
          },
          "title": "Launch Configurations",
          "type": "array",
          "uniqueItems": true
        },
        "maxCapacity": {
          "description": "Maximum capacity that should not be exceeded at any given time for the entire workerpool",
          "title": "Maximum Capacity",
          "type": "integer"
        },
        "minCapacity": {
          "description": "Minimum capacity necessary to maintain at any given time for the entire workerpool",
          "title": "Minimum Capacity",
          "type": "integer"
        }
      },
      "required": [
        "launchConfigs",
        "minCapacity",
        "maxCapacity"
      ],
      "title": "AWS Provider Config",
      "type": "object"
    },
    "filename": "schemas/worker-manager/v1/config-aws.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a Taskcluster Secret\n",
      "properties": {
        "expires": {
          "description": "An expiration date for this secret.\n",
          "format": "date-time",
          "type": "string"
        },
        "secret": {
          "description": "The secret value to be encrypted.\n",
          "type": "object"
        }
      },
      "required": [
        "secret",
        "expires"
      ],
      "title": "Secret",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret.json"
  },
  {
    "content": {
      "$id": "/schemas/secrets/v1/secret-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message containing a list of secret names\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "secrets": {
          "description": "Secret names",
          "items": {
            "description": "Secret name",
            "title": "Secret",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "secrets"
      ],
      "title": "Secrets List",
      "type": "object"
    },
    "filename": "schemas/secrets/v1/secret-list.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/workertype-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a worker-type request from a provisioner.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker-type` are included.\n",
                "enum": [
                  "worker-type"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker-type Action",
            "type": "object"
          },
          "title": "Worker-type Actions",
          "type": "array",
          "uniqueItems": false
        },
        "description": {
          "description": "Description of the worker-type.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this worker-type was seen active. `lastDateActive` is updated every 6 hours\nbut may be off by up-to 6 hours. Nonetheless, `lastDateActive` is a good indicator\nof when the worker-type was last seen active.\n",
          "format": "date-time",
          "title": "Worker-type Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "stability": {
          "description": "This is the stability of the worker-type. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "workerType",
        "provisionerId",
        "description",
        "stability",
        "expires",
        "lastDateActive",
        "actions"
      ],
      "title": "Worker-type Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/workertype-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/worker-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a worker.\n",
      "properties": {
        "actions": {
          "items": {
            "additionalProperties": false,
            "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
            "properties": {
              "context": {
                "description": "Only actions with the context `worker` are included.\n",
                "enum": [
                  "worker"
                ],
                "title": "Context",
                "type": "string"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "method": {
                "description": "Method to indicate the desired action to be performed for a given resource.\n",
                "enum": [
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ],
                "title": "Method",
                "type": "string"
              },
              "name": {
                "description": "Short names for things like logging/error messages.\n",
                "title": "Name",
                "type": "string"
              },
              "title": {
                "description": "Appropriate title for any sort of Modal prompt.\n",
                "title": "Title"
              },
              "url": {
                "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
                "title": "URL",
                "type": "string"
              }
            },
            "required": [
              "name",
              "title",
              "context",
              "url",
              "method",
              "description"
            ],
            "title": "Worker Action",
            "type": "object"
          },
          "title": "Worker Actions",
          "type": "array",
          "uniqueItems": false
        },
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        },
        "firstClaim": {
          "description": "Date of the first time this worker claimed a task.\n",
          "format": "date-time",
          "title": "First task claimed",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        },
        "recentTasks": {
          "description": "List of 20 most recent tasks claimed by the worker.\n",
          "items": {
            "$ref": "task-run.json#"
          },
          "title": "Most Recent Tasks",
          "type": "array",
          "uniqueItems": false
        },
        "workerGroup": {
          "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Group",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker evaluating this run within given\n`workerGroup`.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Worker Identifier",
          "type": "string"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "workerGroup",
        "workerId",
        "recentTasks",
        "expires",
        "firstClaim",
        "actions"
      ],
      "title": "Worker Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/worker-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-workertype-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker-type.\n",
      "properties": {
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker-type Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker-type Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-workertype-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the worker will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Worker Expiration",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/update-provisioner-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
      ],
      "title": "Provisioner Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/update-provisioner-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "default": [
          ],
          "description": "List of dependent tasks. These must either be _completed_ or _resolved_\nbefore this task is scheduled. See `requires` for semantics.\n",
          "items": {
            "description": "The `taskId` of a task that must be resolved before this task is\nscheduled.\n",
            "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
            "title": "Task Dependency",
            "type": "string"
          },
          "maxItems": 100,
          "title": "Task Dependencies",
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Task expiration, time at which task definition and status is deleted.\nNotice that all artifacts for the task must have an expiration that is no\nlater than this. If this property isn't it will be set to `deadline`\nplus one year (this default may change).\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "extra": {
          "default": {
          },
          "description": "Object with properties that can hold any kind of extra data that should be\nassociated with the task. This can be data for the task which doesn't\nfit into `payload`, or it can supplementary data for use in services\nlistening for events from this task. For example this could be details to\ndisplay on dashboard, or information for indexing the task. Please, try\nto put all related information under one property, so `extra` data keys\ndon't conflict.  **Warning**, do not stuff large data-sets in here --\ntask definitions should not take-up multiple MiBs.\n",
          "title": "Extra Data",
          "type": "object"
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "description": "Task-specific payload following worker-specific format.\nRefer to the documentation for the worker implementing\n`<provisionerId>/<workerType>` for details.\n",
          "title": "Task Payload",
          "type": "object"
        },
        "priority": {
          "default": "lowest",
          "description": "Priority of task. This defaults to `lowest` and the scope\n`queue:create-task:<priority>/<provisionerId>/<workerType>` is required\nto define a task with `<priority>`. The `normal` priority is treated as\n`lowest`.\n",
          "enum": [
            "highest",
            "very-high",
            "high",
            "medium",
            "low",
            "very-low",
            "lowest",
            "normal"
          ],
          "title": "Task Priority",
          "type": "string"
        },
        "provisionerId": {
          "description": "Unique identifier for a provisioner, that can supply specified\n`workerType`\n",
          "pattern": "^[a-zA-Z0-9-_]{1,38}$",
          "title": "Provisioner Id",
          "type": "string"
        },
        "requires": {
          "default": "all-completed",
          "description": "The tasks relation to its dependencies. This property specifies the\nsemantics of the `task.dependencies` property.\nIf `all-completed` is given the task will be scheduled when all\ndependencies are resolved _completed_ (successful resolution).\nIf `all-resolved` is given the task will be scheduled when all dependencies\nhave been resolved, regardless of what their resolution is.\n",
          "enum": [
            "all-completed",
            "all-resolved"
          ],
          "title": "Dependency Requirement Semantics",
          "type": "string"
        },
        "retries": {
          "default": 5,
          "description": "Number of times to retry the task in case of infrastructure issues.\nAn _infrastructure issue_ is a worker node that crashes or is shutdown,\nthese events are to be expected.\n",
          "maximum": 49,
          "minimum": 0,
          "title": "Retries",
          "type": "integer"
        },
        "routes": {
          "default": [
          ],
          "description": "List of task-specific routes. Pulse messages about the task will be CC'ed to\n`route.<value>` for each `<value>` in this array.\n\nThis array has a maximum size due to a limitation of the AMQP protocol,\nover which Pulse runs.  All routes must fit in the same \"frame\" of this\nprotocol, and the frames have a fixed maximum size (typically 128k).\n",
          "items": {
            "description": "A task specific route.\n",
            "maxLength": 249,
            "minLength": 1,
            "title": "Task Specific Route",
            "type": "string"
          },
          "maxItems": 64,
          "title": "Task Specific Routes",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "default": "-",
          "description": "All tasks in a task group must have the same `schedulerId`. This is used for several purposes:\n\n* it can represent the entity that created the task;\n* it can limit addition of new tasks to a task group: the caller of\n    `createTask` must have a scope related to the `schedulerId` of the task\n    group;\n* it controls who can manipulate tasks, again by requiring\n    `schedulerId`-related scopes; and\n* it appears in the routing key for Pulse messages about the task.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes that the task is authorized to use during its execution.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "title": "Scopes",
          "type": "array",
          "uniqueItems": false
        },
        "tags": {
          "additionalProperties": {
            "maxLength": 4096,
            "type": "string"
          },
          "default": {
          },
          "description": "Arbitrary key-value tags (only strings limited to 4k). These can be used\nto attach informal metadata to a task. Use this for informal tags that\ntasks can be classified by. You can also think of strings here as\ncandidates for formal metadata. Something like\n`purpose: 'build' || 'test'` is a good example.\n",
          "title": "Tags",
          "type": "object"
        },
        "taskGroupId": {
          "description": "Identifier for a group of tasks scheduled together with this task.\nGenerally, all tasks related to a single event such as a version-control\npush or a nightly build have the same `taskGroupId`.  This property\ndefaults to `taskId` if it isn't specified.  Tasks with `taskId` equal to\nthe `taskGroupId` are, [by convention](/docs/manual/using/task-graph),\ndecision tasks.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "workerType": {
          "description": "Unique identifier for a worker-type within a specific provisioner\n",
          "pattern": "^[a-z]([-a-z0-9]{0,36}[a-z0-9])?$",
          "title": "Worker Type",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "schedulerId",
        "taskGroupId",
        "dependencies",
        "requires",
        "routes",
        "priority",
        "retries",
        "created",
        "deadline",
        "scopes",
        "payload",
        "metadata",
        "tags",
        "extra"
      ],
      "title": "Task Definition Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A representation of **task status** as known by the queue\n",
      "properties": {
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "expires": {
          "description": "Task expiration, time at which task definition and\nstatus is deleted. Notice that all artifacts for the task\nmust have an expiration that is no later than this.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "retriesLeft": {
          "description": "Number of retries left for the task in case of infrastructure issues\n",
          "maximum": 999,
          "minimum": 0,
          "title": "Retries Left",
          "type": "integer"
        },
        "runs": {
          "description": "List of runs, ordered so that index `i` has `runId == i`\n",
          "items": {
            "additionalProperties": false,
            "description": "JSON object with information about a run\n",
            "properties": {
              "reasonCreated": {
                "description": "Reason for the creation of this run,\n**more reasons may be added in the future**.\n",
                "enum": [
                  "scheduled",
                  "retry",
                  "task-retry",
                  "rerun",
                  "exception"
                ],
                "title": "Reason Created",
                "type": "string"
              },
              "reasonResolved": {
                "description": "Reason that run was resolved, this is mainly\nuseful for runs resolved as `exception`.\nNote, **more reasons may be added in the future**, also this\nproperty is only available after the run is resolved. Some of these\nreasons, notably `intermittent-task`, `worker-shutdown`, and\n`claim-expired`, will trigger an automatic retry of the task.\n",
                "enum": [
                  "completed",
                  "failed",
                  "deadline-exceeded",
                  "canceled",
                  "superseded",
                  "claim-expired",
                  "worker-shutdown",
                  "malformed-payload",
                  "resource-unavailable",
                  "internal-error",
                  "intermittent-task"
                ],
                "title": "Reason Resolved",
                "type": "string"
              },
              "resolved": {
                "description": "Date-time at which this run was resolved, ie. when the run changed\nstate from `running` to either `completed`, `failed` or `exception`.\nThis property is only present after the run as been resolved.\n",
                "format": "date-time",
                "title": "Resolved",
                "type": "string"
              },
              "runId": {
                "description": "Id of this task run, `run-id`s always starts from `0`\n",
                "maximum": 1000,
                "minimum": 0,
                "title": "Run Identifier",
                "type": "integer"
              },
              "scheduled": {
                "description": "Date-time at which this run was scheduled, ie. when the run was\ncreated in state `pending`.\n",
                "format": "date-time",
                "title": "Scheduled",
                "type": "string"
              },
              "started": {
                "description": "Date-time at which this run was claimed, ie. when the run changed\nstate from `pending` to `running`. This property is only present\nafter the run has been claimed.\n",
                "format": "date-time",
                "title": "Started",
                "type": "string"
              },
              "state": {
                "description": "State of this run\n",
                "enum": [
                  "pending",
                  "running",
                  "completed",
                  "failed",
                  "exception"
                ],
                "title": "Run State",
                "type": "string"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `failed`, if the\nrun isn't reclaimed. Note, only present after the run has been\nclaimed.\n",
                "format": "date-time",
                "title": "Taken Until",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\nNote, this property is only present after the run is claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Group",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for worker evaluating this run within given\n`workerGroup`. Note, this property is only available after the run\nhas been claimed.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "title": "Worker Identifier",
                "type": "string"
              }
            },
            "required": [
              "runId",
              "state",
              "reasonCreated",
              "scheduled"
            ],
            "title": "Run Information",
            "type": "object"
          },
          "title": "List of Runs",
          "type": "array",
          "uniqueItems": true
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "state": {
          "description": "State of this task. This is just an auxiliary property derived from state\nof latests run, or `unscheduled` if none.\n",
          "enum": [
            "unscheduled",
            "pending",
            "running",
            "completed",
            "failed",
            "exception"
          ],
          "title": "State",
          "type": "string"
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "taskId",
        "provisionerId",
        "workerType",
        "schedulerId",
        "taskGroupId",
        "deadline",
        "expires",
        "retriesLeft",
        "state",
        "runs"
      ],
      "title": "Task Status Structure",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-status-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a task status request\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        }
      },
      "required": [
        "status"
      ],
      "title": "Task Status Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-status-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-running-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a given run of a task have started\n",
      "properties": {
        "runId": {
          "description": "Id of the run that just started, always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `failed`, if the run\nisn't reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil"
      ],
      "title": "Task Running Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-running-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-run.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A run of a task.\n",
      "properties": {
        "runId": {
          "description": "Id of this task run, `run-id`s always starts from `0`\n",
          "maximum": 1000,
          "minimum": 0,
          "title": "Run Identifier",
          "type": "integer"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "runId"
      ],
      "title": "Task Run",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-run.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-reclaim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "credentials"
      ],
      "title": "Task Reclaim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-reclaim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-pulse-definition.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Subset of a task definition containing values that are useful for determining\nwhether a message is interesting to the receiver. Where the full task\ndefinition is required, the receiver should call queue.task to download that\ndefinition.\n",
      "properties": {
        "tags": {
          "$ref": "task.json#/properties/tags"
        }
      },
      "required": [
        "tags"
      ],
      "title": "Task Definition Structure for Pulse Messages",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-pulse-definition.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-pending-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task is now pending\n",
      "properties": {
        "runId": {
          "description": "Id of run that became pending, `run-id`s always starts from 0\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "additionalProperties": false,
          "description": "Subset of a task definition\n",
          "properties": {
            "tags": {
              "$ref": "task.json#/properties/tags"
            }
          },
          "required": [
            "tags"
          ],
          "type": "object"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status",
        "runId"
      ],
      "title": "Task Pending Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-pending-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Required task metadata\n",
      "properties": {
        "description": {
          "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "name": {
          "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "E-mail of person who caused this task, e.g. the person who did\n`hg push`. The person we should contact to ask why this task is here.\n",
          "format": "email",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        },
        "source": {
          "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
          "format": "uri",
          "maxLength": 4096,
          "pattern": "^https?://",
          "title": "Source",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner",
        "source"
      ],
      "title": "Task Metadata",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-group-resolved.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message written once a task group has no tasks to be run. It is\npossible for a task group to later have another task added, in which\ncase this message will be sent again once it finishes.\n",
      "properties": {
        "schedulerId": {
          "description": "Identifier for the scheduler that created this task-group.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "title": "Scheduler Identifier",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "taskGroupId",
        "schedulerId"
      ],
      "title": "Task Group Resolved Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-group-resolved.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-failed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task failed to complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that failed.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Failed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-failed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request for a run of a task to be resolved with an exception\n",
      "properties": {
        "reason": {
          "description": "Reason that the task is resolved with an exception. This is a subset\nof the values for `resolvedReason` given in the task status structure.\n**Report `worker-shutdown`** if the run failed because the worker\nhad to shutdown (spot node disappearing). In case of `worker-shutdown`\nthe queue will immediately **retry** the task, by making a new run.\nThis is much faster than ignoreing the issue and letting the task _retry_\nby claim expiration. For any other _reason_ reported the queue will not\nretry the task.\n**Report `malformed-payload`** if the `task.payload` doesn't match the\nschema for the worker payload, or referenced resource doesn't exists.\nIn either case, you should still log the error to a log file for the\nspecific run.\n**Report `resource-unavailable`** if a resource/service needed or\nreferenced in `task.payload` is _temporarily_ unavailable. Do not use this\nunless you know the resource exists, if the resource doesn't exist you\nshould report `malformed-payload`. Example use-case if you contact the\nindex (a service) on behalf of the task, because of a declaration in\n`task.payload`, and the service (index) is temporarily down. Don't use\nthis if a URL returns 404, but if it returns 503 or hits a timeout when\nyou retry the request, then this _may_ be a valid exception. The queue\nassumes that workers have applied retries as needed, and will not retry\n the task.\n**Report `internal-error`** if the worker experienced an unhandled internal\nerror from which it couldn't recover. The queue will not retry runs\nresolved with this reason, but you are clearly signaling that this is a\nbug in the worker code.\n**Report `superseded`** if the task was determined to have been\nsuperseded by another task, and its results are no longer needed.  It is\nconvention in this case to create an artifact entitled\n`public/superseded-by` containing the taskId of the task that superseded\nthis one.\n**Report `intermittent-task`** if the task explicitly requested a retry\nbecause task is intermittent. Workers can choose whether or not to\nsupport this, but workers shouldn't blindly report this for every task\nthat fails.\n",
          "enum": [
            "worker-shutdown",
            "malformed-payload",
            "resource-unavailable",
            "internal-error",
            "superseded",
            "intermittent-task"
          ],
          "type": "string"
        }
      },
      "required": [
        "reason"
      ],
      "title": "Task Exception Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-exception-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that Taskcluster have failed to run a task.\n",
      "properties": {
        "runId": {
          "description": "Id of the last run for the task, not provided if `deadline`\nwas exceeded before a run was started.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the last attempt of the task\nran. Not provided, if `deadline` was exceeded before a run was started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the last worker that failed to report, causing the task\nto fail. Not provided, if `deadline` was exceeded before a run\nwas started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Exception Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-exception-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-definition-and-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Task Definition and task status structure.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task.json#"
        }
      },
      "required": [
        "task",
        "status"
      ],
      "title": "Task definition and status",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-definition-and-status.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-defined-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has been defined. The task may or may not be\n_scheduled_ too.\n",
      "properties": {
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "status"
      ],
      "title": "Task Defined Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-defined-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-credentials.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Temporary credentials granting `task.scopes` and the scope:\n`queue:claim-task:<taskId>/<runId>` which allows the worker to reclaim\nthe task, upload artifacts and report task resolution.\n\nThe temporary credentials are set to expire after `takenUntil`. They\nwon't expire exactly at `takenUntil` but shortly after, hence, requests\ncoming close `takenUntil` won't have problems even if there is a little\nclock drift.\n\nWorkers should use these credentials when making requests on behalf of\na task. This includes requests to create artifacts, reclaiming the task\nreporting the task `completed`, `failed` or `exception`.\n\nNote, a new set of temporary credentials is issued when the worker\nreclaims the task.\n",
      "properties": {
        "accessToken": {
          "description": "The `accessToken` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        },
        "certificate": {
          "description": "The `certificate` for the temporary credentials, these are required\nfor the temporary credentials to work.\n",
          "minLength": 1,
          "type": "string"
        },
        "clientId": {
          "description": "The `clientId` for the temporary credentials.\n",
          "minLength": 1,
          "type": "string"
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "certificate"
      ],
      "title": "Task Credentials",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-credentials.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-completed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a task has complete successfully.\n",
      "properties": {
        "runId": {
          "description": "Id of the run that completed the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "task": {
          "$ref": "task-pulse-definition.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run ran.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker that executed this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId"
      ],
      "title": "Task Completed Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-completed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a successful task claim\n",
      "properties": {
        "credentials": {
          "$ref": "task-credentials.json#"
        },
        "runId": {
          "description": "`run-id` assigned to this run of the task\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "takenUntil": {
          "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
          "format": "date-time",
          "type": "string"
        },
        "task": {
          "$ref": "task.json#"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which this run started.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker executing this run.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "takenUntil",
        "task",
        "credentials"
      ],
      "title": "Task Claim Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/task-claim-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim (or reclaim) a task\n",
      "properties": {
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId"
      ],
      "title": "Task Claim Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/task-claim-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/quarantine-worker-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to update a worker's quarantineUntil property.\n",
      "properties": {
        "quarantineUntil": {
          "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
          "format": "date-time",
          "title": "Worker Quarantine",
          "type": "string"
        }
      },
      "required": [
        "quarantineUntil"
      ],
      "title": "Quarantine Worker Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/quarantine-worker-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/provisioner-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response containing information about a provisioner.\n",
      "properties": {
        "actions": {
          "$ref": "actions.json#"
        },
        "description": {
          "description": "Description of the provisioner.\n",
          "title": "Description",
          "type": "string"
        },
        "expires": {
          "description": "Date and time after which the provisioner will be automatically\ndeleted by the queue.\n",
          "format": "date-time",
          "title": "Provisioner Expiration",
          "type": "string"
        },
        "lastDateActive": {
          "description": "Date of the last time this provisioner was seen active. `lastDateActive` is updated every 6 hours\nbut may be off by up-to 6 hours. Nonetheless, `lastDateActive` is a good indicator\nof when the provisioner was last seen active.\n",
          "format": "date-time",
          "title": "Provisioner Last Date Active",
          "type": "string"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "stability": {
          "description": "This is the stability of the provisioner. Accepted values:\n  * `experimental`\n  * `stable`\n  * `deprecated`\n",
          "enum": [
            "experimental",
            "stable",
            "deprecated"
          ],
          "title": "Stability",
          "type": "string"
        }
      },
      "required": [
        "provisionerId",
        "description",
        "actions",
        "stability",
        "expires",
        "lastDateActive"
      ],
      "title": "Provisioner Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/provisioner-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response to a request for posting an artifact.\nNote that the `storageType` property is referenced in the request as well.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Response to a request for a signed PUT URL that will allow you to\nupload an artifact to an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, must be specified as header when uploading with\nthe signed `putUrl`.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the signed `putUrl` no longer works\n",
              "format": "date-time",
              "type": "string"
            },
            "putUrl": {
              "description": "URL to which a `PUT` request can be made to upload the artifact\nrequested. Note, the `Content-Length` must be specified correctly,\nand the `ContentType` header must be set the value specified below.\n",
              "format": "uri",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "putUrl",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to redirect to a URL for a given\nartifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Redirect Artifact Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Response to a request for the queue to reply `424` (Failed Dependency)\nwith `reason` and `message` to any `GET` request for this artifact.\n",
          "properties": {
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType"
          ],
          "title": "Error Artifact Response",
          "type": "object"
        }
      ],
      "title": "Post Artifact Response"
    },
    "filename": "schemas/queue/v1/post-artifact-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/post-artifact-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Request a authorization to put and artifact or posting of a URL as an artifact. Note that the `storageType` property is referenced in the response as well.",
      "oneOf": [
        {
          "additionalProperties": false,
          "description": "Request for a signed PUT URL that will allow you to upload an artifact\nto an S3 bucket managed by the queue.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type, when uploading artifact to the signed\n`PUT` URL returned from this request this must given with the\n `ContentType` header. Please, provide correct mime-type,\n this make tooling a lot easier, specifically,\n always using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the artifact should be deleted. Note, that\nthese will be collected over time, and artifacts may remain\navailable after expiration. S3 based artifacts are identified in\nazure table storage and explicitly deleted on S3 after expiration.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `'s3'`\n",
              "enum": [
                "s3"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "contentType"
          ],
          "title": "S3 Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to redirect to a URL for a given artifact.\nThis allows you to reference artifacts that aren't managed by the queue.\nThe queue will still authenticate the request, so depending on the level\nof secrecy required, secret URLs **might** work. Note, this is mainly\nuseful for public artifacts, for example temporary files directly\nstored on the worker host and only available there for a specific\namount of time.\n",
          "properties": {
            "contentType": {
              "description": "Artifact mime-type for the resource to which the queue should\nredirect. Please use the same `Content-Type`, consistently using\nthe correct mime-type make tooling a lot easier, specifically,\nalways using `application/json` for JSON artifacts.\n",
              "maxLength": 255,
              "type": "string"
            },
            "expires": {
              "description": "Date-time after which the queue should no longer redirect to this URL.\nNote, that the queue will and cannot delete the resource your URL\nreferences, you are responsible for doing that yourself.\n",
              "format": "date-time",
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `reference`\n",
              "enum": [
                "reference"
              ],
              "type": "string"
            },
            "url": {
              "description": "URL to which the queue should redirect using a `303` (See other)\nredirect.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "url",
            "contentType"
          ],
          "title": "Redirect Artifact Request",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "description": "Request the queue to reply `424` (Failed Dependency) with `reason` and \n`message` to any `GET` request for this artifact. This is mainly useful\nas a way for a task to declare that it failed to provide an artifact it\nwanted to upload.\n",
          "properties": {
            "expires": {
              "description": "Date-time after which the queue should stop replying with the error\nand forget about the artifact.\n",
              "format": "date-time",
              "type": "string"
            },
            "message": {
              "description": "Human readable explanation of why the artifact is missing\n",
              "maxLength": 4096,
              "type": "string"
            },
            "reason": {
              "description": "Reason why the artifact doesn't exist.\n",
              "enum": [
                "file-missing-on-worker",
                "invalid-resource-on-worker",
                "too-large-file-on-worker"
              ],
              "type": "string"
            },
            "storageType": {
              "description": "Artifact storage type, in this case `error`\n",
              "enum": [
                "error"
              ],
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "expires",
            "reason",
            "message"
          ],
          "title": "Error Artifact Request",
          "type": "object"
        }
      ],
      "title": "Post Artifact Request"
    },
    "filename": "schemas/queue/v1/post-artifact-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/poll-task-urls-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to request for poll task urls.\n",
      "properties": {
        "expires": {
          "description": "Date and time after which the signed URLs provided in this response\nexpires and not longer works for authentication.\n",
          "format": "date-time",
          "title": "Signed URL Expiration",
          "type": "string"
        },
        "queues": {
          "description": "List of signed URLs for queues to poll tasks from, they must be called\nin the order they are given. As the first entry in this array **may**\nhave higher priority.\n",
          "items": {
            "additionalProperties": false,
            "description": "Object holding two signed URLs for an azure queue, one for fetching\nmessages, and another for deleting messages. Remember to `claimTask`\nbefore deleting the message, and delete message even if the `claimTask`\noperation fails with a 400 status code. Don't delete it on other status\ncodes!\n",
            "properties": {
              "signedDeleteUrl": {
                "description": "Signed URL to delete messages that have been received using the\n`signedPollUrl`. You **must** do this to avoid receiving the same\nmessage again.\nTo use this URL you must substitute `{{messageId}}` and\n`{{popReceipt}}` with `MessageId` and `PopReceipt` from the XML\nresponse the `signedPollUrl` gave you. It is important that you\n`encodeURIComponent` both `MessageId` and `PopReceipt` prior to\nsubstitution, otherwise you will experience intermittent failures!\nNote this URL only works with `DELETE` request.\n",
                "pattern": "^https://",
                "title": "Signed Delete Message URL",
                "type": "string"
              },
              "signedPollUrl": {
                "description": "Signed URL to get message from the Azure Queue Storage queue,\nthat holds messages for the given `provisionerId` and `workerType`.\nNote that this URL returns XML, see documentation for the Azure\nQueue Storage\n[REST API](http://msdn.microsoft.com/en-us/library/azure/dd179474.aspx)\nfor details.\nWhen you have a message you can use `claimTask` to claim the task.\nYou will need to parse the XML response and base64 decode and\nJSON parse the `MessageText`.\nAfter you have called `claimTask` you **must** us the\n`signedDeleteUrl` to delete the message.\n**Remark**, you are allowed to append `&numofmessages=N`,\nwhere N < 32, to the URLs if you wish to obtain more than one\nmessage at the time.\n",
                "format": "uri",
                "title": "Signed Get Message URL",
                "type": "string"
              }
            },
            "required": [
              "signedPollUrl",
              "signedDeleteUrl"
            ],
            "title": "Signed URLs for a queue",
            "type": "object"
          },
          "title": "Queues To Poll From",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "queues",
        "expires"
      ],
      "title": "Poll Task Urls Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/poll-task-urls-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/pending-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for the number of pending tasks for a given\n`provisionerId` and `workerType`.\n",
      "properties": {
        "pendingTasks": {
          "description": "An approximate number of pending tasks for the given `provisionerId` and\n`workerType`. This is based on Azure Queue Storage metadata API, thus,\nnumber of reported here may be higher than actual number of pending tasks.\nBut there cannot be more pending tasks reported here. Ie. this is an\n**upper-bound** on the number of pending tasks.\n",
          "minimum": 0,
          "title": "Number of Pending Tasks",
          "type": "integer"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "pendingTasks"
      ],
      "title": "Count Pending Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/pending-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workertypes-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkerTypes` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of worker-types in the provisioner.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workerTypes": {
          "description": "List of worker-types in this provisioner.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description of the worker-type.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the worker-type will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Worker-type Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the worker-type was last seen active\n",
                "format": "date-time",
                "title": "Worker-type Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "$ref": "task.json#/properties/provisionerId"
              },
              "stability": {
                "description": "This is the stability of the worker-type. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              },
              "workerType": {
                "$ref": "task.json#/properties/workerType"
              }
            },
            "required": [
              "workerType",
              "provisionerId",
              "stability",
              "description",
              "expires",
              "lastDateActive"
            ],
            "title": "Worker Type",
            "type": "object"
          },
          "title": "WorkerTypes from the Provisioner",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workerTypes"
      ],
      "title": "List Worker-Types Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workertypes-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-workers-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listWorkers` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of workers in the worker-type.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listWorkerTypes` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "workers": {
          "description": "List of workers in this worker-type.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "firstClaim": {
                "description": "Date of the first time this worker claimed a task.\n",
                "format": "date-time",
                "title": "First task claimed",
                "type": "string"
              },
              "latestTask": {
                "$ref": "task-run.json#",
                "description": "The most recent claimed task\n",
                "title": "Most Recent Task"
              },
              "quarantineUntil": {
                "description": "Quarantining a worker allows the machine to remain alive but not accept jobs.\nOnce the quarantineUntil time has elapsed, the worker resumes accepting jobs.\nNote that a quarantine can be lifted by setting `quarantineUntil` to the present time (or\nsomewhere in the past).\n",
                "format": "date-time",
                "title": "Worker Quarantine",
                "type": "string"
              },
              "workerGroup": {
                "description": "Identifier for the worker group containing this worker.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for this worker (unique within this worker group).\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "workerGroup",
              "workerId",
              "firstClaim"
            ],
            "title": "Worker",
            "type": "object"
          },
          "title": "Workers from a WorkerType",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "workers"
      ],
      "title": "List Workers Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-workers-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-task-group-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listTaskGroup` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tasks in the task-group.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listTaskGroup` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskGroupId": {
          "description": "Identifier for the task-group being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task-Group Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks in this task-group.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks from the Task-Group",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskGroupId",
        "tasks"
      ],
      "title": "List Task-Group Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-task-group-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-provisioners-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of provisioners.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "provisioners": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "actions": {
                "$ref": "actions.json#"
              },
              "description": {
                "description": "Description of the provisioner.\n",
                "title": "Description",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the provisioner created will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Provisioner Expiration",
                "type": "string"
              },
              "lastDateActive": {
                "description": "Date and time where the provisioner was last seen active\n",
                "format": "date-time",
                "title": "Provisioner Last Date Active",
                "type": "string"
              },
              "provisionerId": {
                "$ref": "task.json#/properties/provisionerId"
              },
              "stability": {
                "description": "This is the stability of the provisioner. Accepted values:\n * `experimental`\n * `stable`\n * `deprecated`\n",
                "enum": [
                  "experimental",
                  "stable",
                  "deprecated"
                ],
                "title": "Stability",
                "type": "string"
              }
            },
            "required": [
              "provisionerId",
              "description",
              "stability",
              "expires",
              "lastDateActive",
              "actions"
            ],
            "title": "Provisioner Information",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "provisioners"
      ],
      "title": "List Provisioners Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-provisioners-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-dependent-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a `listDependentTasks` request.\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of dependent tasks.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `listDependentTasks` with\n`continuationToken` until you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "taskId": {
          "description": "Identifier for the task whose dependents are being listed.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks that have `taskId` in the `task.dependencies` property.\n",
          "items": {
            "$ref": "task-definition-and-status.json#"
          },
          "title": "Tasks that depend on `taskId`",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "taskId",
        "tasks"
      ],
      "title": "List Dependent Tasks Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-dependent-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/list-artifacts-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of artifacts for a given `taskId` and `runId`.\n",
      "properties": {
        "artifacts": {
          "description": "List of artifacts for given `taskId` and `runId`.\n",
          "items": {
            "additionalProperties": false,
            "description": "Information about an artifact for the given `taskId` and `runId`.\n",
            "properties": {
              "contentType": {
                "description": "Mimetype for the artifact that was created.\n",
                "maxLength": 255,
                "title": "Content-Type",
                "type": "string"
              },
              "expires": {
                "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
                "format": "date-time",
                "title": "Artifact Expiration",
                "type": "string"
              },
              "name": {
                "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact.\n",
                "maxLength": 1024,
                "title": "Artifact Name",
                "type": "string"
              },
              "storageType": {
                "description": "This is the `storageType` for the request that was used to create\nthe artifact.\n",
                "enum": [
                  "s3",
                  "reference",
                  "error"
                ],
                "title": "Artifact Storage-Type",
                "type": "string"
              }
            },
            "required": [
              "storageType",
              "name",
              "expires",
              "contentType"
            ],
            "title": "Artifact",
            "type": "object"
          },
          "title": "Artifact List",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of artifacts.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called with `continuationToken` until you get a\nresult without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "artifacts"
      ],
      "title": "List Artifacts Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/list-artifacts-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/create-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a task that can be scheduled\n",
      "properties": {
        "created": {
          "description": "Creation time of task",
          "format": "date-time",
          "title": "Created",
          "type": "string"
        },
        "deadline": {
          "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
          "format": "date-time",
          "title": "Deadline",
          "type": "string"
        },
        "dependencies": {
          "$ref": "task.json#/properties/dependencies",
          "default": [
          ]
        },
        "expires": {
          "$ref": "task.json#/properties/expires"
        },
        "extra": {
          "$ref": "task.json#/properties/extra",
          "default": {
          }
        },
        "metadata": {
          "$ref": "task-metadata.json#"
        },
        "payload": {
          "$ref": "task.json#/properties/payload",
          "default": [
          ]
        },
        "priority": {
          "$ref": "task.json#/properties/priority",
          "default": "lowest"
        },
        "provisionerId": {
          "$ref": "task.json#/properties/provisionerId"
        },
        "requires": {
          "$ref": "task.json#/properties/requires",
          "default": "all-completed"
        },
        "retries": {
          "$ref": "task.json#/properties/retries",
          "default": 5
        },
        "routes": {
          "$ref": "task.json#/properties/routes",
          "default": [
          ]
        },
        "schedulerId": {
          "$ref": "task.json#/properties/schedulerId",
          "default": "-"
        },
        "scopes": {
          "$ref": "task.json#/properties/scopes",
          "default": [
          ]
        },
        "tags": {
          "$ref": "task.json#/properties/tags",
          "default": {
          }
        },
        "taskGroupId": {
          "$ref": "task.json#/properties/taskGroupId"
        },
        "workerType": {
          "$ref": "task.json#/properties/workerType"
        }
      },
      "required": [
        "provisionerId",
        "workerType",
        "created",
        "deadline",
        "payload",
        "metadata"
      ],
      "title": "Task Definition Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/create-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to an attempt to claim tasks for a worker to process.\n",
      "properties": {
        "tasks": {
          "description": "List of task claims, may be empty if no tasks was claimed, in which case\nthe worker should sleep a tiny bit before polling again.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "credentials": {
                "$ref": "task-credentials.json#"
              },
              "runId": {
                "description": "`run-id` assigned to this run of the task\n",
                "maximum": 1000,
                "minimum": 0,
                "type": "integer"
              },
              "status": {
                "$ref": "task-status.json#"
              },
              "takenUntil": {
                "description": "Time at which the run expires and is resolved as `exception`,\nwith reason `claim-expired` if the run haven't been reclaimed.\n",
                "format": "date-time",
                "type": "string"
              },
              "task": {
                "$ref": "task.json#"
              },
              "workerGroup": {
                "description": "Identifier for the worker-group within which this run started.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "workerId": {
                "description": "Identifier for the worker executing this run.\n",
                "maxLength": 38,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              }
            },
            "required": [
              "status",
              "runId",
              "workerGroup",
              "workerId",
              "takenUntil",
              "task",
              "credentials"
            ],
            "title": "Task Claim",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "Claim Work Response",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-response.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/claim-work-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to claim a task for a worker to process.\n",
      "properties": {
        "tasks": {
          "default": 1,
          "description": "Number of tasks to attempt to claim.\n",
          "maximum": 32,
          "minimum": 1,
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for group that worker claiming the task is a part of.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for worker within the given workerGroup\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "workerGroup",
        "workerId",
        "tasks"
      ],
      "title": "Claim Work Request",
      "type": "object"
    },
    "filename": "schemas/queue/v1/claim-work-request.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/artifact-created-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting a new artifact has been created for a given task.\n",
      "properties": {
        "artifact": {
          "additionalProperties": false,
          "description": "Information about the artifact that was created\n",
          "properties": {
            "contentType": {
              "description": "Mimetype for the artifact that was created.\n",
              "maxLength": 255,
              "title": "Content-Type",
              "type": "string"
            },
            "expires": {
              "description": "Date and time after which the artifact created will be automatically\ndeleted by the queue.\n",
              "format": "date-time",
              "title": "Artifact Expiration",
              "type": "string"
            },
            "name": {
              "description": "Name of the artifact that was created, this is useful if you want to\nattempt to fetch the artifact. But keep in mind that just because an\nartifact is created doesn't mean that it's immediately available.\n",
              "maxLength": 1024,
              "title": "Artifact Name",
              "type": "string"
            },
            "storageType": {
              "description": "This is the `storageType` for the request that was used to create the\nartifact.\n",
              "enum": [
                "reference",
                "error"
              ],
              "title": "Artifact Storage-Type",
              "type": "string"
            }
          },
          "required": [
            "storageType",
            "name",
            "expires",
            "contentType"
          ],
          "title": "Artifact",
          "type": "object"
        },
        "runId": {
          "description": "Id of the run on which artifact was created.\n",
          "maximum": 1000,
          "minimum": 0,
          "type": "integer"
        },
        "status": {
          "$ref": "task-status.json#"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        },
        "workerGroup": {
          "description": "Identifier for the worker-group within which the run with the created\nartifacted is running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "workerId": {
          "description": "Identifier for the worker within which the run with the created artifact\nis running.\n",
          "maxLength": 38,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        }
      },
      "required": [
        "version",
        "status",
        "runId",
        "workerGroup",
        "workerId",
        "artifact"
      ],
      "title": "Artifact Created Message",
      "type": "object"
    },
    "filename": "schemas/queue/v1/artifact-created-message.json"
  },
  {
    "content": {
      "$id": "/schemas/queue/v1/actions.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "See taskcluster [actions](/docs/reference/platform/taskcluster-queue/docs/actions) documentation.\n",
      "items": {
        "additionalProperties": false,
        "description": "Actions provide a generic mechanism to expose additional features of a\nprovisioner, worker type, or worker to Taskcluster clients.\n\nAn action is comprised of metadata describing the feature it exposes,\ntogether with a webhook for triggering it.\n\nThe Taskcluster tools site, for example, retrieves actions when displaying\nprovisioners, worker types and workers. It presents the provisioner/worker\ntype/worker specific actions to the user. When the user triggers an action,\nthe web client takes the registered webhook, substitutes parameters into the\nURL (see `url`), signs the requests with the Taskcluster credentials of the\nuser operating the web interface, and issues the HTTP request.\n\nThe level to which the action relates (provisioner, worker type, worker) is\ncalled the action context. All actions, regardless of the action contexts,\nare registered against the provisioner when calling\n`queue.declareProvisioner`.\n\nThe action context is used by the web client to determine where in the web\ninterface to present the action to the user as follows:\n\n| `context`   | Tool where action is displayed |\n|-------------|--------------------------------|\n| provisioner | Provisioner Explorer           |\n| worker-type | Workers Explorer               |\n| worker      | Worker Explorer                |\n\nSee [actions docs](/docs/reference/platform/taskcluster-queue/docs/actions)\nfor more information.\n",
        "properties": {
          "context": {
            "description": "Actions have a \"context\" that is one of provisioner, worker-type, or worker, indicating\nwhich it applies to. `context` is used by the front-end to know where to display the action.\n\n| `context`   | Page displayed        |\n|-------------|-----------------------|\n| provisioner | Provisioner Explorer  |\n| worker-type | Workers Explorer      |\n| worker      | Worker Explorer       |\n",
            "enum": [
              "provisioner",
              "worker-type",
              "worker"
            ],
            "title": "Context",
            "type": "string"
          },
          "description": {
            "description": "Description of the provisioner.\n",
            "title": "Description",
            "type": "string"
          },
          "method": {
            "description": "Method to indicate the desired action to be performed for a given resource.\n",
            "enum": [
              "POST",
              "PUT",
              "DELETE",
              "PATCH"
            ],
            "title": "Method",
            "type": "string"
          },
          "name": {
            "description": "Short names for things like logging/error messages.\n",
            "title": "Name",
            "type": "string"
          },
          "title": {
            "description": "Appropriate title for any sort of Modal prompt.\n",
            "title": "Title"
          },
          "url": {
            "description": "When an action is triggered, a request is made using the `url` and `method`.\nDepending on the `context`, the following parameters will be substituted in the url:\n\n| `context`   | Path parameters                                          |\n|-------------|----------------------------------------------------------|\n| provisioner | <provisionerId>                                          |\n| worker-type | <provisionerId>, <workerType>                            |\n| worker      | <provisionerId>, <workerType>, <workerGroup>, <workerId> |\n\n_Note: The request needs to be signed with the user's Taskcluster credentials._\n",
            "title": "URL",
            "type": "string"
          }
        },
        "required": [
          "name",
          "title",
          "context",
          "url",
          "method",
          "description"
        ],
        "title": "Action",
        "type": "object"
      },
      "title": "Actions",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/queue/v1/actions.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-requests.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A list of Purge Cache requests that the Purge Cache service has previously received.\n",
      "items": {
        "additionalProperties": false,
        "description": "An entry in a list of Purge Cache Requests that the Purge Cache service has previously received.\n",
        "properties": {
          "before": {
            "description": "All caches that match this provisionerId, workerType, and cacheName must be destroyed if they were created _before_ this time.\n",
            "format": "date-time",
            "type": "string"
          },
          "cacheName": {
            "description": "Name of cache to purge.",
            "type": "string"
          },
          "provisionerId": {
            "description": "ProvisionerId associated with the workerType.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          },
          "workerType": {
            "description": "Workertype cache exists on.",
            "maxLength": 38,
            "minLength": 1,
            "pattern": "^([a-zA-Z0-9-_]*)$",
            "type": "string"
          }
        },
        "required": [
          "provisionerId",
          "workerType",
          "cacheName",
          "before"
        ],
        "title": "Purge Cache Requests Entry",
        "type": "object"
      },
      "title": "Purge Cache Requests",
      "type": "array",
      "uniqueItems": false
    },
    "filename": "schemas/purge-cache/v1/purge-cache-requests.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request that a message be published to purge a specific cache.\n",
      "properties": {
        "cacheName": {
          "description": "Name of cache to purge. Notice that if a `workerType` have multiple kinds\nof caches (with independent names), it should purge all caches identified\nby `cacheName` regardless of cache type.\n",
          "type": "string"
        }
      },
      "required": [
        "cacheName"
      ],
      "title": "Purge Cache Request",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests.\n",
      "properties": {
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open Purge Request List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/purge-cache/v1/all-purge-cache-request-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of currently open purge-cache requests. Should not be used by workers.\n",
      "properties": {
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        },
        "requests": {
          "$ref": "purge-cache-requests.json#"
        }
      },
      "required": [
        "requests"
      ],
      "title": "Open All Purge Requests List",
      "type": "object"
    },
    "filename": "schemas/purge-cache/v1/all-purge-cache-request-list.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/pulse-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to post a message on pulse.\n",
      "properties": {
        "message": {
          "description": "Pulse message to send as plain text.\n",
          "type": "object"
        },
        "routingKey": {
          "description": "Routing-key to use when posting the message.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "required": [
        "routingKey",
        "message"
      ],
      "title": "Post Pulse Message Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/pulse-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "This can be pretty much anything you want it to be.\n",
      "properties": {
        "message": {
          "description": "Arbitrary message.\n",
          "title": "Message",
          "type": "object"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "message"
      ],
      "title": "Notification Message",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-message.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Type of notification and its corresponding address.\n",
      "properties": {
        "notificationAddress": {
          "type": "string"
        },
        "notificationType": {
          "enum": [
            "email",
            "pulse",
            "irc-user",
            "irc-channel"
          ],
          "type": "string"
        }
      },
      "required": [
        "notificationType",
        "notificationAddress"
      ],
      "title": "Notification Type And Address",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/notification-address-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of notification addresses.\n",
      "properties": {
        "addresses": {
          "items": {
            "$ref": "notification-address.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "addresses"
      ],
      "title": "List of notification adresses",
      "type": "object"
    },
    "filename": "schemas/notify/v1/notification-address-list.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/irc-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "definitions": {
        "message": {
          "description": "IRC message to send as plain text.\n",
          "maxLength": 510,
          "minLength": 1,
          "title": "IRC Message Text",
          "type": "string"
        }
      },
      "description": "Request to post a message on IRC.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "channel": {
              "description": "Channel to post the message in.\n",
              "minLength": 1,
              "pattern": "^[#&][^ ,\\u0007]{1,199}$",
              "title": "Channel Name",
              "type": "string"
            },
            "message": {
              "$ref": "#/definitions/message"
            }
          },
          "required": [
            "channel",
            "message"
          ],
          "title": "Channel Message",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "$ref": "#/definitions/message"
            },
            "user": {
              "description": "User to post the message to.\n",
              "maxLength": 255,
              "minLength": 1,
              "pattern": "^[A-Za-z\\[\\]\\\\~_\\^{|}][A-Za-z0-9\\-\\[\\]\\\\~_\\^{|}]{0,254}$",
              "title": "IRC Handle",
              "type": "string"
            }
          },
          "required": [
            "user",
            "message"
          ],
          "title": "Private Message",
          "type": "object"
        }
      ],
      "title": "Post IRC Message Request"
    },
    "filename": "schemas/notify/v1/irc-request.json"
  },
  {
    "content": {
      "$id": "/schemas/notify/v1/email-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to send an email\n",
      "properties": {
        "address": {
          "description": "E-mail address to which the message should be sent\n",
          "format": "email",
          "type": "string"
        },
        "content": {
          "description": "Content of the e-mail as **markdown**, will be rendered to HTML before\nthe email is sent. Notice that markdown allows for a few HTML tags, but\nwon't allow inclusion of script tags and other unpleasantries.\n",
          "maxLength": 102400,
          "minLength": 1,
          "type": "string"
        },
        "link": {
          "additionalProperties": false,
          "description": "Optional link that can be added as a button to the email.\n",
          "properties": {
            "href": {
              "description": "Where the link should point to.\n",
              "format": "uri",
              "maxLength": 1024,
              "minLength": 1,
              "type": "string"
            },
            "text": {
              "description": "Text to display on link.\n",
              "maxLength": 40,
              "minLength": 1,
              "type": "string"
            }
          },
          "required": [
            "text",
            "href"
          ],
          "type": "object"
        },
        "replyTo": {
          "description": "Reply-to e-mail (this property is optional)\n",
          "format": "email",
          "type": "string"
        },
        "subject": {
          "description": "Subject line of the e-mail, this is plain-text\n",
          "maxLength": 255,
          "minLength": 1,
          "type": "string"
        },
        "template": {
          "default": "simple",
          "description": "E-mail html template used to format your content.\n",
          "enum": [
            "simple",
            "fullscreen"
          ],
          "type": "string"
        }
      },
      "required": [
        "address",
        "subject",
        "content"
      ],
      "title": "Send Email Request",
      "type": "object"
    },
    "filename": "schemas/notify/v1/email-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-tasks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tasks": {
          "description": "List of tasks.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a task.\n",
            "properties": {
              "data": {
                "description": "Data that was reported with the task. This is an arbitrary JSON\nobject.\n",
                "title": "Task Specific Data",
                "type": "object"
              },
              "expires": {
                "description": "Date at which this entry expires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "namespace": {
                "description": "Index path of the task.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              },
              "rank": {
                "description": "If multiple tasks are indexed with the same `namespace` the task\nwith the highest `rank` will be stored and returned in later\nrequests. If two tasks has the same `rank` the latest task will be\nstored.\n",
                "title": "Rank",
                "type": "number"
              },
              "taskId": {
                "description": "Unique task identifier for the task currently indexed at `namespace`.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "taskId",
              "rank",
              "data",
              "expires"
            ],
            "title": "Task",
            "type": "object"
          },
          "title": "Tasks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tasks"
      ],
      "title": "List Tasks Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-tasks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response from a request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "namespaces": {
          "description": "List of namespaces.\n",
          "items": {
            "additionalProperties": false,
            "description": "Representation of a namespace that contains indexed tasks.\n",
            "properties": {
              "expires": {
                "description": "Date at which this entry, and by implication all entries below it,\nexpires from the task index.\n",
                "format": "date-time",
                "title": "Expiration",
                "type": "string"
              },
              "name": {
                "description": "Name of namespace within it's parent namespace.\n",
                "title": "Name",
                "type": "string"
              },
              "namespace": {
                "description": "Fully qualified name of the namespace, you can use this to list\nnamespaces or tasks under this namespace.\n",
                "maxLength": 255,
                "title": "Namespace",
                "type": "string"
              }
            },
            "required": [
              "namespace",
              "name",
              "expires"
            ],
            "title": "Namespace",
            "type": "object"
          },
          "title": "Namespaces",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "namespaces"
      ],
      "title": "List Namespaces Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-response.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/list-namespaces-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to list namespaces within a given namespace.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token previously returned in a response to this list\nrequest. This property is optional and should not be provided for first\nrequests.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "limit": {
          "default": 1000,
          "description": "Maximum number of results per page. If there are more results than this\na continuation token will be return.\n",
          "maximum": 1000,
          "minimum": 1,
          "title": "Result limit",
          "type": "integer"
        }
      },
      "required": [
      ],
      "title": "List Namespaces Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/list-namespaces-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/insert-task-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of the index entry to insert.\n",
      "properties": {
        "data": {
          "description": "This is an arbitrary JSON object. Feel free to put whatever data you want\nhere, but do limit it, you'll get errors if you store more than 32KB.\nSo stay well, below that limit.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Insert Task Request",
      "type": "object"
    },
    "filename": "schemas/index/v1/insert-task-request.json"
  },
  {
    "content": {
      "$id": "/schemas/index/v1/indexed-task-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Representation of an indexed task.\n",
      "properties": {
        "data": {
          "description": "Data that was reported with the task. This is an arbitrary JSON object.\n",
          "title": "Task Specific Data",
          "type": "object"
        },
        "expires": {
          "description": "Date at which this entry expires from the task index.\n",
          "format": "date-time",
          "title": "Expiration",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the indexed task, used to find the indexed task in the index.\n",
          "maxLength": 255,
          "title": "Namespace",
          "type": "string"
        },
        "rank": {
          "description": "If multiple tasks are indexed with the same `namespace` the task with the\nhighest `rank` will be stored and returned in later requests. If two tasks\nhas the same `rank` the latest task will be stored.\n",
          "title": "Rank",
          "type": "number"
        },
        "taskId": {
          "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
          "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
          "title": "Task Identifier",
          "type": "string"
        }
      },
      "required": [
        "namespace",
        "taskId",
        "rank",
        "data",
        "expires"
      ],
      "title": "Indexed Task Response",
      "type": "object"
    },
    "filename": "schemas/index/v1/indexed-task-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Secret token for a trigger\n",
      "properties": {
        "token": {
          "title": "Token",
          "type": "string"
        }
      },
      "required": [
        "token"
      ],
      "title": "trigger token response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "A request to trigger a hook.  The payload must be a JSON object, and is used as the context\nfor a JSON-e rendering of the hook's task template, as described in \"Firing Hooks\".\n",
      "title": "Trigger Hook Request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/trigger-hook.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/trigger-hook-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "anyOf": [
        {
          "$ref": "task-status.json#"
        },
        {
          "additionalProperties": false,
          "description": "Empty response indicating no task was created",
          "properties": {
          },
          "required": [
          ],
          "type": "object"
        }
      ],
      "description": "Response to a `triggerHook` or `triggerHookWithToken` call.\n\nIn most cases, this is a task status, but in cases where the hook template\ndoes not generate a task, it is an empty object with no `status` property.\n",
      "title": "Trigger Hook Response"
    },
    "filename": "schemas/hooks/v1/trigger-hook-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/task-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A representation of **task status** as known by the queue\n",
      "properties": {
        "status": {
          "additionalProperties": false,
          "properties": {
            "deadline": {
              "description": "Deadline of the task, `pending` and `running` runs are\nresolved as **exception** if not resolved by other means\nbefore the deadline. Note, deadline cannot be more than\n5 days into the future\n",
              "format": "date-time",
              "title": "Deadline",
              "type": "string"
            },
            "expires": {
              "description": "Task expiration, time at which task definition and\nstatus is deleted. Notice that all artifacts for the task\nmust have an expiration that is no later than this.\n",
              "format": "date-time",
              "title": "Expiration",
              "type": "string"
            },
            "provisionerId": {
              "description": "Unique identifier for the provisioner that this task must be scheduled on\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Provisioner Id",
              "type": "string"
            },
            "retriesLeft": {
              "description": "Number of retries left for the task in case of infrastructure issues\n",
              "maximum": 999,
              "minimum": 0,
              "title": "Retries Left",
              "type": "integer"
            },
            "runs": {
              "description": "List of runs, ordered so that index `i` has `runId == i`\n",
              "items": {
                "additionalProperties": false,
                "description": "JSON object with information about a run\n",
                "properties": {
                  "reasonCreated": {
                    "description": "Reason for the creation of this run,\n**more reasons may be added in the future**.\n",
                    "enum": [
                      "scheduled",
                      "retry",
                      "task-retry",
                      "rerun",
                      "exception"
                    ],
                    "title": "Reason Created",
                    "type": "string"
                  },
                  "reasonResolved": {
                    "description": "Reason that run was resolved, this is mainly\nuseful for runs resolved as `exception`.\nNote, **more reasons may be added in the future**, also this\nproperty is only available after the run is resolved.\n",
                    "enum": [
                      "completed",
                      "failed",
                      "deadline-exceeded",
                      "canceled",
                      "superseded",
                      "claim-expired",
                      "worker-shutdown",
                      "malformed-payload",
                      "resource-unavailable",
                      "internal-error",
                      "intermittent-task"
                    ],
                    "title": "Reason Resolved",
                    "type": "string"
                  },
                  "resolved": {
                    "description": "Date-time at which this run was resolved, ie. when the run changed\nstate from `running` to either `completed`, `failed` or `exception`.\nThis property is only present after the run as been resolved.\n",
                    "format": "date-time",
                    "title": "Resolved",
                    "type": "string"
                  },
                  "runId": {
                    "description": "Id of this task run, `run-id`s always starts from `0`\n",
                    "maximum": 1000,
                    "minimum": 0,
                    "title": "Run Identifier",
                    "type": "integer"
                  },
                  "scheduled": {
                    "description": "Date-time at which this run was scheduled, ie. when the run was\ncreated in state `pending`.\n",
                    "format": "date-time",
                    "title": "Scheduled",
                    "type": "string"
                  },
                  "started": {
                    "description": "Date-time at which this run was claimed, ie. when the run changed\nstate from `pending` to `running`. This property is only present\nafter the run has been claimed.\n",
                    "format": "date-time",
                    "title": "Started",
                    "type": "string"
                  },
                  "state": {
                    "description": "State of this run\n",
                    "enum": [
                      "pending",
                      "running",
                      "completed",
                      "failed",
                      "exception"
                    ],
                    "title": "Run State",
                    "type": "string"
                  },
                  "takenUntil": {
                    "description": "Time at which the run expires and is resolved as `failed`, if the\nrun isn't reclaimed. Note, only present after the run has been\nclaimed.\n",
                    "format": "date-time",
                    "title": "Taken Until",
                    "type": "string"
                  },
                  "workerGroup": {
                    "description": "Identifier for group that worker who executes this run is a part of,\nthis identifier is mainly used for efficient routing.\nNote, this property is only present after the run is claimed.\n",
                    "maxLength": 38,
                    "minLength": 1,
                    "pattern": "^([a-zA-Z0-9-_]*)$",
                    "title": "Worker Group",
                    "type": "string"
                  },
                  "workerId": {
                    "description": "Identifier for worker evaluating this run within given\n`workerGroup`. Note, this property is only available after the run\nhas been claimed.\n",
                    "maxLength": 38,
                    "minLength": 1,
                    "pattern": "^([a-zA-Z0-9-_]*)$",
                    "title": "Worker Identifier",
                    "type": "string"
                  }
                },
                "required": [
                  "runId",
                  "state",
                  "reasonCreated",
                  "scheduled"
                ],
                "title": "Run Information",
                "type": "object"
              },
              "title": "List of Runs",
              "type": "array",
              "uniqueItems": false
            },
            "schedulerId": {
              "description": "Identifier for the scheduler that _defined_ this task.\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Scheduler Identifier",
              "type": "string"
            },
            "state": {
              "description": "State of this task. This is just an auxiliary property derived from state\nof latests run, or `unscheduled` if none.\n",
              "enum": [
                "unscheduled",
                "pending",
                "running",
                "completed",
                "failed",
                "exception"
              ],
              "title": "State",
              "type": "string"
            },
            "taskGroupId": {
              "description": "Identifier for a group of tasks scheduled together with this task, by\nscheduler identified by `schedulerId`. For tasks scheduled by the\ntask-graph scheduler, this is the `taskGraphId`.\n",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Task-Group Identifier",
              "type": "string"
            },
            "taskId": {
              "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
              "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
              "title": "Task Identifier",
              "type": "string"
            },
            "workerType": {
              "description": "Identifier for worker type within the specified provisioner\n",
              "maxLength": 38,
              "minLength": 1,
              "pattern": "^([a-zA-Z0-9-_]*)$",
              "title": "Worker Type",
              "type": "string"
            }
          },
          "required": [
            "taskId",
            "provisionerId",
            "workerType",
            "schedulerId",
            "taskGroupId",
            "deadline",
            "expires",
            "retriesLeft",
            "state",
            "runs"
          ],
          "type": "object"
        }
      },
      "required": [
        "status"
      ],
      "title": "Task Status Structure",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/task-status.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/schedule.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "default": [
      ],
      "description": "A list of cron-style definitions to represent a set of moments in (UTC) time.\nIf several patterns are specified, a given moment in time represented by\nmore than one pattern is considered only to be counted once, in other words\nit is allowed for the cron patterns to overlap; duplicates are redundant.\n",
      "items": {
        "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\n",
        "title": "Cron Pattern",
        "type": "string"
      },
      "title": "Schedule",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/schedule.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/pulse-hook-changed-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": true,
      "description": "Message reporting that a hook has changed\n",
      "properties": {
        "hookGroupId": {
          "description": "`hookGroupId` of the hook that was changed\n",
          "type": "string"
        },
        "hookId": {
          "description": "`hookId` of the hook that was changed\n",
          "type": "string"
        }
      },
      "required": [
        "hookId",
        "hookGroupId"
      ],
      "title": "Hook Changed Message",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/pulse-hook-changed-message.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-lastFires-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of lastFires\n",
      "properties": {
        "lastFires": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "error": {
                "description": "The error that occurred when firing the task. This is typically,\nbut not always, an API error message.\n",
                "type": "string"
              },
              "firedBy": {
                "enum": [
                  "schedule",
                  "triggerHook",
                  "triggerHookWithToken",
                  "pulseMessage"
                ],
                "type": "string"
              },
              "hookGroupId": {
                "maxLength": 64,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_]*)$",
                "type": "string"
              },
              "hookId": {
                "maxLength": 64,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_/]*)$",
                "type": "string"
              },
              "result": {
                "description": "Information about success or failure of firing of the hook",
                "enum": [
                  "success",
                  "error"
                ],
                "type": "string"
              },
              "taskCreateTime": {
                "description": "Time when the task was created",
                "format": "date-time",
                "type": "string"
              },
              "taskId": {
                "description": "Unique task identifier, this is UUID encoded as\n[URL-safe base64](http://tools.ietf.org/html/rfc4648#section-5) and\nstripped of `=` padding.\n",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "title": "Task Identifier",
                "type": "string"
              }
            },
            "required": [
              "hookGroupId",
              "hookId",
              "taskId",
              "firedBy",
              "taskCreateTime",
              "result",
              "error"
            ],
            "type": "object"
          },
          "title": "LastFires",
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "lastFires"
      ],
      "title": "LastFires list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-lastFires-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hooks-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of hooks\n",
      "properties": {
        "hooks": {
          "items": {
            "$ref": "hook-definition.json#"
          },
          "title": "Hooks",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "hooks"
      ],
      "title": "Hook list",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hooks-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/list-hook-groups-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of `hookGroupIds`.\n",
      "properties": {
        "groups": {
          "items": {
            "type": "string"
          },
          "title": "Groups",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "groups"
      ],
      "title": "Hook groups",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/list-hook-groups-response.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A snapshot of the current status of a hook.\n",
      "properties": {
        "lastFire": {
          "description": "Information about the last time this hook fired.  This property is only present\nif the hook has fired at least once.\n",
          "oneOf": [
            {
              "additionalProperties": false,
              "description": "Information about a successful firing of the hook",
              "properties": {
                "result": {
                  "enum": [
                    "success"
                  ],
                  "type": "string"
                },
                "taskId": {
                  "description": "The task created",
                  "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "taskId",
                "time"
              ],
              "title": "Successful Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about an unsuccessful firing of the hook",
              "properties": {
                "error": {
                  "description": "The error that occurred when firing the task.  This is typically,\nbut not always, an API error message.\n",
                  "type": "object"
                },
                "result": {
                  "enum": [
                    "error"
                  ],
                  "type": "string"
                },
                "time": {
                  "description": "The time the task was created.  This will not necessarily match `task.created`.\n",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "result",
                "error",
                "time"
              ],
              "title": "Failed Fire",
              "type": "object"
            },
            {
              "additionalProperties": false,
              "description": "Information about no firing of the hook (e.g., a new hook)",
              "properties": {
                "result": {
                  "enum": [
                    "no-fire"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "result"
              ],
              "title": "No Fire",
              "type": "object"
            }
          ]
        },
        "nextScheduledDate": {
          "description": "The next time this hook's task is scheduled to be created. This property\nis only present if there is a scheduled next time. Some hooks don't have\nany schedules.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "lastFire"
      ],
      "title": "Hook status response",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-status.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-metadata.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "properties": {
        "description": {
          "description": "Long-form of the hook's purpose and behavior",
          "maxLength": 32768,
          "title": "Description",
          "type": "string"
        },
        "emailOnError": {
          "default": true,
          "description": "Whether to email the owner on an error creating the task.",
          "title": "Email on error",
          "type": "boolean"
        },
        "name": {
          "description": "Human readable name of the hook",
          "maxLength": 255,
          "title": "Name",
          "type": "string"
        },
        "owner": {
          "description": "Email of the person or group responsible for this hook.",
          "format": "email",
          "maxLength": 255,
          "title": "Owner",
          "type": "string"
        }
      },
      "required": [
        "name",
        "description",
        "owner"
      ],
      "title": "Hook Metadata",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-metadata.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/hook-definition.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that will create tasks when defined events occur.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "$ref": "schedule.json#"
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://taskcluster.github.io/json-e/)\nas described in [firing hooks](/docs/reference/core/hooks/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "type": "object"
        }
      },
      "required": [
        "hookGroupId",
        "hookId",
        "metadata",
        "task",
        "schedule",
        "triggerSchema"
      ],
      "title": "Hook definition",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/hook-definition.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/create-hook-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Definition of a hook that can create tasks at defined times.\n",
      "properties": {
        "bindings": {
          "$ref": "bindings.json#"
        },
        "hookGroupId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_]*)$",
          "type": "string"
        },
        "hookId": {
          "maxLength": 64,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_/]*)$",
          "type": "string"
        },
        "metadata": {
          "$ref": "hook-metadata.json#"
        },
        "schedule": {
          "default": [
          ],
          "description": "Definition of the times at which a hook will result in creation of a task.\nIf several patterns are specified, tasks will be created at any time\nspecified by one or more patterns.\n",
          "items": {
            "description": "Cron-like specification for when tasks should be created.  The pattern is\nparsed in a UTC context.\nSee [cron-parser on npm](https://www.npmjs.com/package/cron-parser).\nNote that tasks may not be created at exactly the time specified.\n",
            "title": "Cron Pattern",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "task": {
          "description": "Template for the task definition.  This is rendered using [JSON-e](https://taskcluster.github.io/json-e/)\nas described in [firing hooks](/docs/reference/core/hooks/firing-hooks) to produce\na task definition that is submitted to the Queue service.\n",
          "title": "Task Template",
          "type": "object"
        },
        "triggerSchema": {
          "default": {
            "additionalProperties": false,
            "type": "object"
          },
          "type": "object"
        }
      },
      "required": [
        "metadata",
        "task"
      ],
      "title": "Hook creation request",
      "type": "object"
    },
    "filename": "schemas/hooks/v1/create-hook-request.json"
  },
  {
    "content": {
      "$id": "/schemas/hooks/v1/bindings.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "items": {
        "additionalProperties": false,
        "description": "Exchange and RoutingKeyPattern for each binding\n",
        "properties": {
          "exchange": {
            "minLength": 1,
            "type": "string"
          },
          "routingKeyPattern": {
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "exchange",
          "routingKeyPattern"
        ],
        "title": "Binding",
        "type": "object"
      },
      "title": "List of Bindings",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/hooks/v1/bindings.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.v1.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v1, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "policy": {
          "pullRequests": {
            "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
            "enum": [
              "public",
              "collaborators"
            ],
            "type": "string"
          }
        },
        "reporting": {
          "description": "Policy for reporting status of PR or a commit. If absent, Github Statuses API is used",
          "enum": [
            "checks-v1"
          ],
          "type": "string"
        },
        "tasks": {
          "default": [
          ],
          "description": "Definitions of tasks that can be scheduled. Rendered with JSON-e\n",
          "oneOf": [
            {
              "description": "Each element of this should evaluate to a task definition via json-e",
              "items": {
                "additionalProperties": true,
                "type": "object"
              },
              "type": "array",
              "uniqueItems": false
            },
            {
              "additionalProperties": true,
              "description": "This must evaluate to an array via json-e i.e. `$flatten`",
              "type": "object"
            }
          ],
          "title": "Task definition template\""
        },
        "version": {
          "description": "Version of the format of this file; must be 1",
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.v1.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/taskcluster-github-config.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Description of a taskcluster.yml file v0, which may be used to generate a taskgraph\nand tasks.\n",
      "properties": {
        "allowPullRequests": {
          "description": "Policy for creating tasks for pull requests.  The effective policy is found in this property\nin the `.taskcluster.yml` file in the repository's default branch.  See the documentation for\ndetailed definition of the options.\n",
          "enum": [
            "public",
            "collaborators"
          ],
          "type": "string"
        },
        "metadata": {
          "additionalProperties": false,
          "description": "Required task graph metadata",
          "properties": {
            "description": {
              "description": "Human readable description of the task, please **explain** what the\ntask does. A few lines of documentation is not going to hurt you.\n",
              "maxLength": 32768,
              "title": "Description",
              "type": "string"
            },
            "name": {
              "description": "Human readable name of task, used to very briefly given an idea about\nwhat the task does.\n",
              "maxLength": 255,
              "title": "Name",
              "type": "string"
            },
            "owner": {
              "description": "E-mail of person who caused this task, e.g. the person who did\n`hg push`. The person we should contact to ask why this task is here.\n",
              "maxLength": 255,
              "title": "Owner",
              "type": "string"
            },
            "source": {
              "description": "Link to source of this task, should specify a file, revision and\nrepository. This should be place someone can go an do a git/hg blame\nto who came up with recipe for this task.\n",
              "maxLength": 4096,
              "title": "Source",
              "type": "string"
            }
          },
          "required": [
            "name",
            "description",
            "owner",
            "source"
          ],
          "type": "object"
        },
        "tasks": {
          "default": [
          ],
          "items": {
            "additionalProperties": true,
            "description": "Definition of a task that can be scheduled\n",
            "properties": {
              "created": {
                "default": "{{ $fromNow }}",
                "description": "Creation time of task",
                "title": "Created",
                "type": "string"
              },
              "deadline": {
                "default": "{{ '1 day' | $fromNow }}",
                "description": "Deadline of the task, `pending` and `running` runs are resolved as **failed** if not resolved by other means before the deadline",
                "title": "Deadline",
                "type": "string"
              }
            },
            "required": [
            ],
            "title": "Task Definition",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "version": {
          "description": ".taskcluster.yml version",
          "enum": [
            0
          ],
          "type": "integer"
        }
      },
      "required": [
        "version"
      ],
      "title": ".taskcluster.yml format",
      "type": "object"
    },
    "filename": "schemas/github/v1/taskcluster-github-config.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/task-group-creation-requested.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Indicates that this service has created a new task group in response to a GitHub event.\nThis message is for internal use only and should not be relied on for other purposes.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "taskGroupId": {
          "description": "The id of the taskGroup that had been created.",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "taskGroupId",
        "organization",
        "repository",
        "version"
      ],
      "title": "Task Group Defined - Create Status",
      "type": "object"
    },
    "filename": "schemas/github/v1/task-group-creation-requested.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/repository.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Any Taskcluster-specific Github repository information.\n",
      "properties": {
        "installed": {
          "description": "True if integration is installed, False otherwise.\n",
          "type": "boolean"
        }
      },
      "required": [
        "installed"
      ],
      "title": "Repository Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/repository.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-release-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub release has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the release (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Release Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-release-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-push-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub push has occurred\n",
      "properties": {
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the push (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maxLength": 10000000000,
          "minLength": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Push Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-push-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/github-pull-request-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a GitHub pull request has occurred\n",
      "properties": {
        "action": {
          "description": "The GitHub `action` which triggered an event.\n",
          "enum": [
            "assigned",
            "unassigned",
            "labeled",
            "unlabeled",
            "opened",
            "edited",
            "closed",
            "reopened",
            "synchronize",
            "review_requested",
            "review_request_removed"
          ]
        },
        "body": {
          "description": "The raw body of github event (for version 1)\n",
          "type": "object"
        },
        "branch": {
          "description": "The head ref of the event (for version 1)\n",
          "type": "string"
        },
        "details": {
          "description": "Metadata describing the pull request (for version 0)\n",
          "type": "object"
        },
        "eventId": {
          "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
          "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
          "type": "string"
        },
        "installationId": {
          "description": "The installation which had an event.\n",
          "maximum": 10000000000,
          "minimum": 0,
          "type": "integer"
        },
        "organization": {
          "description": "The GitHub `organization` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "repository": {
          "description": "The GitHub `repository` which had an event.\n",
          "maxLength": 100,
          "minLength": 1,
          "pattern": "^([a-zA-Z0-9-_%]*)$",
          "type": "string"
        },
        "tasks_for": {
          "description": "The type of the event (for version 1)\n",
          "type": "string"
        },
        "version": {
          "description": "Message version",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "organization",
        "repository",
        "action",
        "installationId",
        "eventId",
        "body",
        "tasks_for",
        "branch"
      ],
      "title": "GitHub Pull Request Message",
      "type": "object"
    },
    "filename": "schemas/github/v1/github-pull-request-message.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-status.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Create a commit status on GitHub.\nFull specification on [GitHub docs](https://developer.github.com/v3/repos/statuses/#create-a-status)\n",
      "properties": {
        "context": {
          "description": "A string label to differentiate this status from the status of other systems.",
          "type": "string"
        },
        "description": {
          "description": "A short description of the status.",
          "type": "string"
        },
        "state": {
          "description": "The state of the status.",
          "enum": [
            "pending",
            "success",
            "error",
            "failure"
          ],
          "type": "string"
        },
        "target_url": {
          "description": "The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the 'source' of the Status.",
          "type": "string"
        }
      },
      "required": [
        "state"
      ],
      "title": "Create Status Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-status.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/create-comment.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Write a new comment on a GitHub Issue or Pull Request.\nFull specification on [GitHub docs](https://developer.github.com/v3/issues/comments/#create-a-comment)\n",
      "properties": {
        "body": {
          "description": "The contents of the comment.",
          "type": "string"
        }
      },
      "required": [
        "body"
      ],
      "title": "Create Comment Request",
      "type": "object"
    },
    "filename": "schemas/github/v1/create-comment.json"
  },
  {
    "content": {
      "$id": "/schemas/github/v1/build-list.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A paginated list of builds\n",
      "properties": {
        "builds": {
          "description": "A simple list of builds.\n",
          "items": {
            "additionalProperties": false,
            "properties": {
              "created": {
                "description": "The initial creation time of the build. This is when it became pending.\n",
                "format": "date-time",
                "type": "string"
              },
              "eventId": {
                "description": "The GitHub webhook deliveryId. Extracted from the header 'X-GitHub-Delivery'\n",
                "oneOf": [
                  {
                    "pattern": "^[a-zA-Z0-9]{8}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{12}$",
                    "title": "Github GUID",
                    "type": "string"
                  },
                  {
                    "enum": [
                      "Unknown"
                    ],
                    "title": "Unknown Github GUID",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "eventType": {
                "description": "Type of Github event that triggered the build (i.e. push, pull_request.opened).",
                "type": "string"
              },
              "organization": {
                "description": "Github organization associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "repository": {
                "description": "Github repository associated with the build.",
                "maxLength": 100,
                "minLength": 1,
                "pattern": "^([a-zA-Z0-9-_%]*)$",
                "type": "string"
              },
              "sha": {
                "description": "Github revision associated with the build.",
                "maxLength": 40,
                "minLength": 40,
                "type": "string"
              },
              "state": {
                "description": "Github status associated with the build.",
                "enum": [
                  "pending",
                  "success",
                  "error",
                  "failure"
                ],
                "type": "string"
              },
              "taskGroupId": {
                "description": "Taskcluster task-group associated with the build.",
                "pattern": "^[A-Za-z0-9_-]{8}[Q-T][A-Za-z0-9_-][CGKOSWaeimquy26-][A-Za-z0-9_-]{10}[AQgw]$",
                "type": "string"
              },
              "updated": {
                "description": "The last updated of the build. If it is done, this is when it finished.\n",
                "format": "date-time",
                "type": "string"
              }
            },
            "required": [
              "organization",
              "repository",
              "sha",
              "state",
              "taskGroupId",
              "eventType",
              "eventId",
              "created",
              "updated"
            ],
            "title": "Build",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": false
        },
        "continuationToken": {
          "description": "Passed back from Azure to allow us to page through long result sets.",
          "type": "string"
        }
      },
      "required": [
        "builds"
      ],
      "title": "Builds Response",
      "type": "object"
    },
    "filename": "schemas/github/v1/build-list.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metaschema.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "allOf": [
        {
          "$ref": "http://json-schema.org/draft-06/schema#"
        },
        {
          "$ref": "#/definitions/schema"
        }
      ],
      "definitions": {
        "recurse": {
          "properties": {
            "additionalItems": {
              "$ref": "#/definitions/schema"
            },
            "additionalProperties": {
              "$ref": "#/definitions/schema"
            },
            "allOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "anyOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "contains": {
              "$ref": "#/definitions/schema"
            },
            "definitions": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "dependencies": {
              "additionalProperties": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/schema"
                  },
                  {
                    "$ref": "http://json-schema.org/draft-06/schema#/definitions/stringArray"
                  }
                ]
              }
            },
            "items": {
              "anyOf": [
                {
                  "$ref": "#/definitions/schema"
                },
                {
                  "$ref": "#/definitions/schemaArray"
                }
              ]
            },
            "not": {
              "$ref": "#/definitions/schema"
            },
            "oneOf": {
              "$ref": "#/definitions/schemaArray"
            },
            "patternProperties": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "properties": {
              "additionalProperties": {
                "$ref": "#/definitions/schema"
              }
            },
            "propertyNames": {
              "$ref": "#/definitions/schema"
            }
          }
        },
        "requiredProperties": {
          "dependencies": {
            "items": [
              "type",
              "uniqueItems"
            ],
            "properties": [
              "type",
              "additionalProperties",
              "required"
            ]
          }
        },
        "schema": {
          "allOf": [
            {
              "$ref": "#/definitions/recurse"
            },
            {
              "$ref": "#/definitions/requiredProperties"
            }
          ]
        },
        "schemaArray": {
          "items": {
            "$ref": "#/definitions/schema"
          },
          "type": "array",
          "uniqueItems": false
        }
      },
      "description": "This is a refinement of JSON-schema, with the following changes:\n\n  * if `properties` is present, `type` and `additionalProperties` must be present, too\n  * if `entries` is present, `type` and `uniqueItems` must be present, too\n\nNote that any schema that validates against this metaschema will also\nvalidate against the upstream draft-06 metaschema, and is usable by any\nJSON-schema tool.\n",
      "title": "Taskcluster JSON-Schema Meta-Schema, with some stricter validation"
    },
    "filename": "schemas/common/metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/metadata-metaschema.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "allOf": [
        {
          "$ref": "./metaschema.json#"
        },
        {
          "$ref": "#/definitions/topLevelMetadata"
        }
      ],
      "definitions": {
        "topLevelMetadata": {
          "additionalProperties": true,
          "properties": {
            "metadata": {
              "additionalProperties": false,
              "description": "Metadata identifying the documents that the schema document describes,\ngiving both a name (a category of document) and a version (to allow\nseveral versions of the same category).  Consumers of the documents can\nconsult the schema metadata to determine how to process the document.\n\nAny changes to a schema that require changes to consumers of the described\ndocuments should be accompanied by a version increase.\n",
              "properties": {
                "name": {
                  "description": "This is used to identify the category of document for later consumption.\nIt is also used to determine schema id's.  Common values for Taskcluster\nreferences are `manifest`, `exchanges`, and `api`.\n",
                  "title": "Name of the document category",
                  "type": "string"
                },
                "version": {
                  "title": "Version of the document format",
                  "type": "integer"
                }
              },
              "required": [
                "version",
                "name"
              ],
              "title": "Metadata for this schema",
              "type": "object"
            }
          },
          "required": [
            "metadata"
          ],
          "type": "object"
        }
      },
      "description": "This is a refinement of the Taskcluster metaschema, with the following changes:\n\n  * top level must be an object (no trivial true or false schemas)\n  * `{metadata: {name, version}}` must be present at the top level\n\nNote that any schema that validates against this metaschema will also\nvalidate against the upstream draft-06 metaschema, and is usable by any\nJSON-schema tool.\n",
      "title": "JSON-Schema Meta-Schema, with the addition of a `metadata` property"
    },
    "filename": "schemas/common/metadata-metaschema.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v3.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "metadata": {
        "name": "manifest",
        "version": 3
      },
      "properties": {
        "references": {
          "description": "Array of URLs of reference documents",
          "items": {
            "formt": "uri",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "references"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v3.json"
  },
  {
    "content": {
      "$id": "/schemas/common/manifest-v2.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "description": "Manifest of taskcluster service definitions available in a taskcluster service deployment.\nThese manifests are served from `$ROOT_URL/references/manifest.json`.",
      "properties": {
        "services": {
          "default": [
          ],
          "description": "List of services that comprise a taskcluster build.",
          "items": {
            "additionalProperties": false,
            "description": "A taskcluster microservice's APIs",
            "properties": {
              "apis": {
                "default": [
                ],
                "description": "HTTP API exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "HTTP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/api-reference-v1.json#` describing the API exposed by service.",
                      "title": "HTTP API reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "HTTP API Reference",
                  "type": "object"
                },
                "title": "HTTP APIs",
                "type": "array",
                "uniqueItems": true
              },
              "pulse": {
                "default": [
                ],
                "description": "Pulse exchanges exposed by this service.",
                "items": {
                  "additionalProperties": false,
                  "description": "AMQP API",
                  "properties": {
                    "reference": {
                      "description": "A document conformant to `$ROOT_URL/schemas/common/exchanges-reference-v1.json#` describing the API exposed by service.",
                      "title": "Pulse exchanges reference",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of API, e.g. `v1`.",
                      "pattern": "^v[0-9][0-9]*$",
                      "title": "Version",
                      "type": "string"
                    }
                  },
                  "required": [
                    "version",
                    "reference"
                  ],
                  "title": "Pulse reference",
                  "type": "object"
                },
                "title": "Pulse references",
                "type": "array",
                "uniqueItems": true
              },
              "serviceName": {
                "description": "A short name for the service, such as `queue` / `purge-cache` / `ec2-manager`.\nThis matches the `serviceName` field in any references linked from here.\n",
                "pattern": "^[a-z][a-z0-9_-]*$",
                "title": "Service Name",
                "type": "string"
              }
            },
            "required": [
              "serviceName"
            ],
            "title": "Service",
            "type": "object"
          },
          "title": "List of taskcluster services",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "services"
      ],
      "title": "Taskcluster Service Manifest",
      "type": "object"
    },
    "filename": "schemas/common/manifest-v2.json"
  },
  {
    "content": {
      "$id": "/schemas/common/logs-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of messages output by structured logging",
      "metadata": {
        "name": "logs",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Log Message Reference",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of the taskcluster service",
          "pattern": "^[a-z][a-z0-9_-]*$",
          "title": "Service Name",
          "type": "string"
        },
        "types": {
          "description": "Array of log message types",
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "A description of this message type",
                "type": "string"
              },
              "fields": {
                "additionalProperties": true,
                "description": "The set of fields that will be in every instance of this message type. Mapping field name to description.",
                "type": "object"
              },
              "level": {
                "description": "Either \"any\" or the syslog level that this log will write at.",
                "enum": [
                  "emerg",
                  "alert",
                  "crit",
                  "err",
                  "warning",
                  "notice",
                  "info",
                  "debug",
                  "any"
                ]
              },
              "name": {
                "description": "The service-specific name of this message type.",
                "pattern": "^[a-z][a-zA-Z0-9_]*",
                "type": "string"
              },
              "title": {
                "description": "A human-readable name for the message type.",
                "type": "string"
              },
              "type": {
                "description": "The \"type\" of the message will be in the top-level keys of a message under the name \"Type\".",
                "pattern": "^[a-z][a-z0-9.-_]*",
                "type": "string"
              },
              "version": {
                "description": "The version of the fields for this log type. Will increment for breaking changes.",
                "minimum": 1,
                "type": "integer"
              }
            },
            "required": [
              "type",
              "title",
              "name",
              "level",
              "version",
              "description",
              "fields"
            ],
            "title": "Message Type",
            "type": "object"
          },
          "title": "Types",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "serviceName",
        "$schema",
        "types"
      ],
      "title": "Log Messages Reference File",
      "type": "object"
    },
    "filename": "schemas/common/logs-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/exchanges-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "description": "Reference of exchanges published",
      "metadata": {
        "name": "exchanges",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "Description of set of exchanges in markdown",
          "type": "string"
        },
        "entries": {
          "items": {
            "additionalProperties": false,
            "properties": {
              "description": {
                "description": "Description (ie. documentation) for the exchange",
                "type": "string"
              },
              "exchange": {
                "description": "Exchange name on AMQP server, must be prefixed with `exchangePrefix` from this document.",
                "type": "string"
              },
              "name": {
                "description": "Name of exchange, this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "routingKey": {
                "items": {
                  "additionalProperties": false,
                  "properties": {
                    "constant": {
                      "description": "Constant to be used for this field, cannot be overwritten, only present if applicable.",
                      "type": "string"
                    },
                    "multipleWords": {
                      "description": "True, if key may contain dots, which AMQP will consider as words. This determines if `#` or `*` should be used in client libraries",
                      "type": "boolean"
                    },
                    "name": {
                      "description": "Identifier usable in client libraries",
                      "type": "string"
                    },
                    "required": {
                      "description": "True, if the key is always present, if `false` the value `_` will be used in place when no appropriate value is available for the key.",
                      "type": "boolean"
                    },
                    "summary": {
                      "description": "Short description of key in markdown",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "summary",
                    "multipleWords",
                    "required"
                  ],
                  "type": "object"
                },
                "type": "array",
                "uniqueItems": true
              },
              "schema": {
                "description": "JSON schema for messages on this exchange. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName>`.",
                "type": "string"
              },
              "title": {
                "description": "Title of exchange entry",
                "type": "string"
              },
              "type": {
                "const": "topic-exchange",
                "description": "Type of entry, currently only `topic-exchange`.",
                "type": "string"
              }
            },
            "required": [
              "type",
              "exchange",
              "name",
              "title",
              "description",
              "routingKey",
              "schema"
            ],
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "exchangePrefix": {
          "description": "Prefix for all exchanges described in this document",
          "type": "string"
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "Title for set of exchanges in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "serviceName",
        "title",
        "description",
        "exchangePrefix",
        "entries"
      ],
      "title": "Exchange Reference File",
      "type": "object"
    },
    "filename": "schemas/common/exchanges-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/api-reference-v0.json#",
      "$schema": "/schemas/common/metadata-metaschema.json#",
      "additionalProperties": false,
      "definitions": {
        "scopeExpressionTemplate": {
          "oneOf": [
            {
              "$ref": "#/definitions/scopeExpressionTemplateString"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateAllOf"
            },
            {
              "$ref": "#/definitions/scopeExpressionTemplateIf"
            },
            {
              "additionalProperties": false,
              "description": "for/each/in objects will replace themselves with an array of basic scopes. They will be flattened into the array this object is a part of.",
              "properties": {
                "each": {
                  "pattern": "^[\\x20-\\x7e]*$",
                  "type": "string"
                },
                "for": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                },
                "in": {
                  "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
                  "type": "string"
                }
              },
              "required": [
                "for",
                "each",
                "in"
              ],
              "title": "For-All",
              "type": "object"
            }
          ]
        },
        "scopeExpressionTemplateAllOf": {
          "additionalProperties": false,
          "description": "AllOf objects will evaluate to true if all subexpressions are true",
          "properties": {
            "AllOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AllOf"
          ],
          "title": "Conjunction",
          "type": "object"
        },
        "scopeExpressionTemplateAnyOf": {
          "additionalProperties": false,
          "description": "AnyOf objects will evaluate to true if any subexpressions are true",
          "properties": {
            "AnyOf": {
              "items": {
                "$ref": "#/definitions/scopeExpressionTemplate"
              },
              "type": "array",
              "uniqueItems": true
            }
          },
          "required": [
            "AnyOf"
          ],
          "title": "Disjunction",
          "type": "object"
        },
        "scopeExpressionTemplateIf": {
          "additionalProperties": false,
          "description": "if/then objects will replace themselves with the contents of then if the `if` is true",
          "properties": {
            "else": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            },
            "if": {
              "pattern": "^[a-zA-Z][a-zA-Z0-9_]*$",
              "type": "string"
            },
            "then": {
              "$ref": "#/definitions/scopeExpressionTemplate"
            }
          },
          "required": [
            "if",
            "then"
          ],
          "title": "Conditional",
          "type": "object"
        },
        "scopeExpressionTemplateString": {
          "description": "The most basic element of a scope expression",
          "pattern": "^[\\x20-\\x7e]*$",
          "title": "Required-Scope",
          "type": "string"
        }
      },
      "description": "Reference of methods implemented by API",
      "metadata": {
        "name": "api",
        "version": 0
      },
      "properties": {
        "$schema": {
          "description": "Link to schema for this reference. That is a link to this very document. Typically used to identify what kind of reference this file is.",
          "format": "uri",
          "title": "Schema Reference",
          "type": "string"
        },
        "apiVersion": {
          "description": "Version of the API",
          "pattern": "^v[0-9]+$",
          "type": "string"
        },
        "description": {
          "description": "API description in markdown",
          "type": "string"
        },
        "entries": {
          "description": "Array of methods in this reference",
          "items": {
            "additionalProperties": false,
            "properties": {
              "args": {
                "description": "Arguments from `route` that must be replaced, they'll appear wrapped in brackets inside `route`.",
                "items": {
                  "description": "Argument that appears in `route` warpped in angle brackets. It must be replaced to call the function.",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "category": {
                "description": "Category for the API method",
                "type": "string"
              },
              "description": {
                "description": "Description (ie. documentation) for the API entry",
                "type": "string"
              },
              "input": {
                "description": "JSON schema for input, if input is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                "type": "string"
              },
              "method": {
                "description": "HTTP method (verb) used to access the function",
                "enum": [
                  "get",
                  "post",
                  "put",
                  "head",
                  "delete",
                  "options",
                  "trace",
                  "copy",
                  "lock",
                  "mkcol",
                  "move",
                  "purge",
                  "propfind",
                  "proppatch",
                  "unlock",
                  "report",
                  "mkactivity",
                  "checkout",
                  "merge",
                  "m-search",
                  "notify",
                  "subscribe",
                  "unsubscribe",
                  "patch",
                  "search"
                ],
                "type": "string"
              },
              "name": {
                "description": "Name of the `function` this is a stable identifier for use in auto-generated client libraries",
                "type": "string"
              },
              "output": {
                "oneOf": [
                  {
                    "description": "JSON schema for output, if output is validated, otherwise not present. The value must be a relative URI, based on the service's schema location; that is, based at `<rootUrl>/schemas/<serviceName`.",
                    "title": "Output Schema",
                    "type": "string"
                  },
                  {
                    "description": "Output kind if not JSON matching a specific schema.",
                    "enum": [
                      "blob"
                    ],
                    "title": "Blob",
                    "type": "string"
                  }
                ],
                "type": "string"
              },
              "query": {
                "description": "List of accepted query-string parameters, these are always optional.",
                "items": {
                  "description": "Optional query-string parameter",
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              "route": {
                "description": "Route for the call, note that arguments wrapped with brackets, like `/user/<userId>/` must be replaced.",
                "type": "string"
              },
              "scopes": {
                "description": "Scope expression template specifying required scopes for a method. Not provided if authentication isn't required.",
                "oneOf": [
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateString"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAnyOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateAllOf"
                  },
                  {
                    "$ref": "#/definitions/scopeExpressionTemplateIf"
                  }
                ]
              },
              "stability": {
                "description": "Stability level of the API",
                "enum": [
                  "deprecated",
                  "experimental",
                  "stable"
                ],
                "title": "Stability-Level",
                "type": "string"
              },
              "title": {
                "description": "Title of API entry",
                "type": "string"
              },
              "type": {
                "description": "Type of entry, currently only `function`.",
                "enum": [
                  "function"
                ],
                "type": "string"
              }
            },
            "required": [
              "type",
              "method",
              "route",
              "args",
              "name",
              "stability",
              "title",
              "description",
              "category"
            ],
            "title": "API Entry",
            "type": "object"
          },
          "title": "Entries",
          "type": "array",
          "uniqueItems": true
        },
        "serviceName": {
          "description": "Name of service for automation. Will be consumed by client generators to produce URLs",
          "maxLength": 22,
          "minLength": 1,
          "pattern": "^[a-z][a-z0-9_-]*$",
          "type": "string"
        },
        "title": {
          "description": "API title in markdown",
          "type": "string"
        }
      },
      "required": [
        "apiVersion",
        "$schema",
        "title",
        "description",
        "serviceName",
        "entries"
      ],
      "title": "API Reference File",
      "type": "object"
    },
    "filename": "schemas/common/api-reference-v0.json"
  },
  {
    "content": {
      "$id": "/schemas/common/action-schema-v1.json#",
      "$schema": "http://json-schema.org/draft-06/schema#",
      "additionalProperties": false,
      "definitions": {
        "context": {
          "default": [
          ],
          "description": "The `context` property determines in what context the action is\nrelevant. Thus, what context the action should be presented to the\nend-user.\n",
          "items": {
            "additionalProperties": {
              "maxLength": 4096,
              "type": "string"
            },
            "description": "A set of key-value pairs specifying a _tag-set_.\n",
            "title": "tag-set",
            "type": "object"
          },
          "type": "array",
          "uniqueItems": true
        },
        "description": {
          "description": "Human readable description of the action in markdown. This\ncan be displayed in a tooltip, popup and/or dialog when triggering\nthe action.\n",
          "maxLength": 4096,
          "type": "string"
        },
        "extra": {
          "description": "Extra data that the decision task wishes to include for use by other\nservices interpreting `actions.json`.  Consumers of this file are free to\nignore any and all data in this field.\n",
          "type": "object"
        },
        "name": {
          "description": "The name of this action.  This is used by user interfaces to\nidentify the action.\n",
          "maxLength": 255,
          "type": "string"
        },
        "schema": {
          "description": "JSON schema for user input to the action.  If this property is omitted,\nthen the input is `null`.\n"
        },
        "title": {
          "description": "Title text to be displayed on the button or link triggering the action.\n",
          "maxLength": 255,
          "type": "string"
        }
      },
      "description": "This document specifies the schema for the `public/actions.json` used by\n_decision tasks_ to expose actions that can be triggered by end-users.\n\nFor the purpose of this document the _consumer_ is the user-interface that\ndisplays task results to the end-user and allows end-users to trigger actions\ndefined by `public/actions.json`. A _consumer_ might be Treeherder.\nThe _end-user_ is a developer who is inspecting the results, and wishes to\ntrigger actions.\n",
      "properties": {
        "actions": {
          "description": "List of actions that can be triggered.\n",
          "items": {
            "anyOf": [
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "kind": {
                    "enum": [
                      "task"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "task": {
                    "description": "Task template for triggering the action.\n\nWhen an action have been selected in the appropriate context and\ninput satisfying the `schema` (if any) has been collected. The\naction is triggered by parameterizing the task template given in\nthis property, and creating the resulting task.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the context\ndescribed in the documentation.\n",
                    "title": "Task Template",
                    "type": "object"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "task"
                ],
                "type": "object"
              },
              {
                "additionalProperties": false,
                "properties": {
                  "context": {
                    "$ref": "#/definitions/context"
                  },
                  "description": {
                    "$ref": "#/definitions/description"
                  },
                  "extra": {
                    "$ref": "#/definitions/extra"
                  },
                  "hookGroupId": {
                    "description": "The `hookGroupId` of the hook to trigger to run this action",
                    "title": "Hook Group ID",
                    "type": "string"
                  },
                  "hookId": {
                    "description": "The `hookId` of the hook to trigger to run this action",
                    "title": "Hook ID",
                    "type": "string"
                  },
                  "hookPayload": {
                    "description": "JSON-e template that renders to the payload for `hooks.triggerHook`.\n\nThe template is an object that is parameterized using\n[JSON-e](https://github.com/taskcluster/json-e), with the\ncontext described in the documentation. The output of this\nrendering is provided as the payload to `hooks.triggerHook`\n(where it becomes the context for another JSON-e rendering\nstep - don't get the two confused!)\n",
                    "title": "Hook Payload Template",
                    "type": "object"
                  },
                  "kind": {
                    "enum": [
                      "hook"
                    ]
                  },
                  "name": {
                    "$ref": "#/definitions/name"
                  },
                  "schema": {
                    "$ref": "#/definitions/schema"
                  },
                  "title": {
                    "$ref": "#/definitions/title"
                  }
                },
                "required": [
                  "kind",
                  "title",
                  "description",
                  "hookGroupId",
                  "hookId",
                  "hookPayload"
                ],
                "type": "object"
              }
            ]
          },
          "type": "array",
          "uniqueItems": true
        },
        "variables": {
          "additionalProperties": true,
          "description": "Additional variables included in JSON-e context.\n",
          "type": "object"
        },
        "version": {
          "enum": [
            1
          ],
          "type": "integer"
        }
      },
      "required": [
        "version",
        "actions",
        "variables"
      ],
      "title": "Schema for Exposing Actions",
      "type": "object"
    },
    "filename": "schemas/common/action-schema-v1.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/websocktunnel-token-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Token for connecting a worker to websocktunnel proxy\n",
      "properties": {
        "expires": {
          "description": "The time at which the JWT will expire.\n",
          "format": "date-time",
          "title": "Expires",
          "type": "string"
        },
        "token": {
          "description": "The JWT to be used as `Bearer <token>` when connecting to the service.\n",
          "title": "Token",
          "type": "string"
        },
        "wstAudience": {
          "description": "Audience identifying the websocktunnel servers that will honor this token; this will be the\nsame as the requested `wstAudience`.\n",
          "pattern": "^[a-zA-Z0-9_-]{1,38}$",
          "title": "Websocktunnel Audience",
          "type": "string"
        },
        "wstClient": {
          "description": "Id for the websocktunnel client connection; this will be the same as the requested `wstClient`.\n",
          "pattern": "^[a-zA-Z0-9_~.%-]+$",
          "title": "Websocktunnel Client",
          "type": "string"
        }
      },
      "required": [
        "wstClient",
        "wstAudience",
        "token",
        "expires"
      ],
      "title": "Websocktunnel Token Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/websocktunnel-token-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request was authenticated.\n",
      "properties": {
        "clientId": {
          "description": "ClientId from the request as it will be logged\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the request was authorized.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "scopes"
      ],
      "title": "Test Authenticate Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/test-authenticate-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Details on how the test request should be authenticated.\n",
      "properties": {
        "clientScopes": {
          "default": [
          ],
          "description": "List of scopes that should be client used should be given.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "requiredScopes": {
          "default": [
          ],
          "description": "List of scopes the request should require.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientScopes",
        "requiredScopes"
      ],
      "title": "Test Authenticate Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/test-authenticate-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/sentry-dsn-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Sentry DSN for submitting errors.\n",
      "properties": {
        "dsn": {
          "additionalProperties": false,
          "description": "Access credentials and urls for the Sentry project.\nCredentials will expire in 24-48 hours, you should refresh them within\n24 hours.\n",
          "properties": {
            "public": {
              "description": "Access credential and URL for public error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in client-side applications only.\n",
              "format": "uri",
              "type": "string"
            },
            "secret": {
              "description": "Access credential and URL for private error reports.\nThese credentials can be used for up-to 24 hours.\nThis is for use in serser-side applications and should **not** be\nleaked.\n",
              "format": "uri",
              "type": "string"
            }
          },
          "required": [
            "secret",
            "public"
          ],
          "type": "object"
        },
        "expires": {
          "description": "Expiration time for the credentials. The credentials should not be used\nafter this time. They might not be revoked immediately, but will be at\nsome arbitrary point after this date-time.\n",
          "format": "date-time",
          "type": "string"
        },
        "project": {
          "description": "Project name that the DSN grants access to.\n",
          "title": "Project",
          "type": "string"
        }
      },
      "required": [
        "project",
        "dsn",
        "expires"
      ],
      "title": "Sentry DSN Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/sentry-dsn-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/scopeset.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A set of scopes\n",
      "properties": {
        "scopes": {
          "description": "List of scopes.  Scopes must be composed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes"
      ],
      "title": "Set of scopes",
      "type": "object"
    },
    "filename": "schemas/auth/v1/scopeset.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/role-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a role has changed\n",
      "properties": {
        "roleId": {
          "description": "`roleId` of the role that was changed\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "roleId"
      ],
      "title": "Role Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/role-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles2-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roles": {
          "description": "A list of requested roles\n",
          "items": {
            "$ref": "get-role-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roles"
      ],
      "title": "Get All Roles Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-roles2-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-roles-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "List of roles\n",
      "items": {
        "$ref": "get-role-response.json#"
      },
      "title": "Get All Roles (no pagination)",
      "type": "array",
      "uniqueItems": true
    },
    "filename": "schemas/auth/v1/list-roles-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-role-ids-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "If no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.\n",
      "properties": {
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "roleIds": {
          "description": "A list of requested roleIds\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "roleIds"
      ],
      "title": "Get Role Ids Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-role-ids-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/list-clients-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "List of clients\n",
      "properties": {
        "clients": {
          "items": {
            "$ref": "get-client-response.json#"
          },
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "A continuation token is returned if there are more results than listed\nhere. You can optionally provide the token in the request payload to\nload the additional results.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "clients"
      ],
      "title": "List Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/list-clients-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-role-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a role\n",
      "properties": {
        "created": {
          "description": "Date and time when this role was created\n",
          "format": "date-time",
          "type": "string"
        },
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expandedScopes": {
          "description": "List of scopes granted anyone who assumes this role, including anything\ngranted by roles that can be assumed when you have this role.\nHence, this includes any scopes in-directly granted as well.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "roleId": {
          "description": "roleId of the role requested\n",
          "pattern": "^[\\x20-\\x7e]+$",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": false
        }
      },
      "required": [
        "roleId",
        "scopes",
        "description",
        "created",
        "lastModified",
        "expandedScopes"
      ],
      "title": "Get Role Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-role-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/get-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Get all details about a client, useful for tools modifying a client\n",
      "properties": {
        "clientId": {
          "description": "ClientId of the client scopes is requested about\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope that client is granted by a role\n",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Get Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/get-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/gcp-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for a request to get a GCP temporary credential.\n",
      "properties": {
        "accessToken": {
          "description": "Temporary oauth2 access token to access the given service account\n",
          "title": "Temporary access token",
          "type": "string"
        },
        "expireTime": {
          "description": "The access token expire time",
          "format": "date-time",
          "title": "Expire time",
          "type": "string"
        }
      },
      "required": [
        "accessToken",
        "expireTime"
      ],
      "title": "GCP Credentials Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/gcp-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-role-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Data to create or update a role.\n",
      "properties": {
        "description": {
          "description": "Description of what this role is used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the role grants access to.  Scopes must be composed of\nprintable ASCII characters and spaces.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "scopes",
        "description"
      ],
      "title": "Create Role Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-role-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "All details about a client including the `accessToken`\n",
      "properties": {
        "accessToken": {
          "description": "AccessToken used for authenticating requests, you should store this\nyou won't be able to retrive it again!\n",
          "pattern": "^[a-zA-Z0-9_-]{22,66}$",
          "type": "string"
        },
        "clientId": {
          "description": "ClientId of the client\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "created": {
          "description": "Date and time when this client was created\n",
          "format": "date-time",
          "type": "string"
        },
        "deleteOnExpiration": {
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false`, the client will remain after expiration, although it cannot be\nused for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "disabled": {
          "description": "If true, this client is disabled and cannot be used.  This usually occurs when the\nscopes available to the user owning the client no longer satisfy the client.\n",
          "type": "boolean"
        },
        "expandedScopes": {
          "description": "List of scopes granted to this client by matching roles, including the\nclient's scopes and the implicit role `client-id:<clientId>`.\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "lastDateUsed": {
          "description": "Date of last time this client was used. Will only be updated every 6 hours\nor so this may be off by up-to 6 hours. But it still gives a solid hint\nas to whether or not this client is in use.\n",
          "format": "date-time",
          "type": "string"
        },
        "lastModified": {
          "description": "Date and time of last modification\n",
          "format": "date-time",
          "type": "string"
        },
        "lastRotated": {
          "description": "Date and time of when the `accessToken` was reset last time.\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "default": [
          ],
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "clientId",
        "accessToken",
        "expires",
        "description",
        "created",
        "lastModified",
        "lastDateUsed",
        "lastRotated",
        "scopes",
        "expandedScopes",
        "disabled",
        "deleteOnExpiration"
      ],
      "title": "Create Client Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/create-client-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Properties to create a client.\n",
      "properties": {
        "deleteOnExpiration": {
          "default": false,
          "description": "If `true`, the service may delete this client after it has expired.  If\n`false` (the default), the client will remain after expiration, although\nit cannot be used for authentication in that state.\n",
          "type": "boolean"
        },
        "description": {
          "description": "Description of what these credentials are used for in markdown.\nShould include who is the owner, point of contact.\n",
          "maxLength": 10240,
          "type": "string"
        },
        "expires": {
          "description": "Date and time where the clients access is set to expire\n",
          "format": "date-time",
          "type": "string"
        },
        "scopes": {
          "description": "List of scopes the client has (unexpanded).\n",
          "items": {
            "description": "A single scope. A scope must be composed of\nprintable ASCII characters and spaces.  Scopes ending in more than\none `*` character are forbidden.\n",
            "name": "Scope",
            "pattern": "^[ -~]*$",
            "type": "string"
          },
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "expires",
        "description"
      ],
      "title": "Create Client Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/create-client-request.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/client-message.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Message reporting that a client has changed\n",
      "properties": {
        "clientId": {
          "description": "`clientId` of the client that was changed\n",
          "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
          "type": "string"
        },
        "version": {
          "description": "Message version number",
          "enum": [
            1
          ]
        }
      },
      "required": [
        "version",
        "clientId"
      ],
      "title": "Client Message",
      "type": "object"
    },
    "filename": "schemas/auth/v1/client-message.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure tables in an account\n",
      "properties": {
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of tables.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called `azureAccountTables` with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        },
        "tables": {
          "description": "A list of tables that are in an account. These are\nthe tables that can have SAS credentials fetched for them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Tables",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "tables"
      ],
      "title": "Azure List Table Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-table-access-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access and Azure\nTable Storage table.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Table Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-table-access-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response to a request for an Shared-Access-Signature to access an Azure\nBlob Storage container.\n",
      "properties": {
        "expiry": {
          "description": "Date and time of when the Shared-Access-Signature expires.\n",
          "format": "date-time",
          "type": "string"
        },
        "sas": {
          "description": "Shared-Access-Signature string. This is the querystring parameters to\nbe appened after `?` or `&` depending on whether or not a querystring is\nalready present in the URL.\n",
          "type": "string"
        }
      },
      "required": [
        "sas",
        "expiry"
      ],
      "title": "Azure Blob Shared-Access-Signature",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-container-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure containers in an account\n",
      "properties": {
        "containers": {
          "description": "A list of containers that are in an account.  Credentials are available for\nthese containers from the `azureBlobSAS` method.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Containers",
          "type": "array",
          "uniqueItems": true
        },
        "continuationToken": {
          "description": "Opaque `continuationToken` to be given as query-string option to get the\nnext set of containers.\nThis property is only present if another request is necessary to fetch all\nresults. In practice the next request with a `continuationToken` may not\nreturn additional results, but it can. Thus, you can only be sure to have\nall the results if you've called this method with `continuationToken`\nuntil you get a result without a `continuationToken`.\n",
          "title": "Continuation Token",
          "type": "string"
        }
      },
      "required": [
        "containers"
      ],
      "title": "Azure List Containers Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-container-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/azure-account-list-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "A list of Azure accounts managed by taskcluster-auth\n",
      "properties": {
        "accounts": {
          "description": "A list of accountIds that are managed by auth. These are\nthe accounts that can have SAS credentials fetched for tables\nwithin them.\n",
          "items": {
            "type": "string"
          },
          "title": "Azure Accounts",
          "type": "array",
          "uniqueItems": true
        }
      },
      "required": [
        "accounts"
      ],
      "title": "Azure List Account Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/azure-account-list-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/aws-s3-credentials-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Response for a request to get access to an S3 bucket.\n",
      "properties": {
        "credentials": {
          "additionalProperties": false,
          "description": "Temporary STS credentials for use when operating on S3\n",
          "properties": {
            "accessKeyId": {
              "description": "Access key identifier that identifies the temporary security\ncredentials.\n",
              "title": "AccessKeyId",
              "type": "string"
            },
            "secretAccessKey": {
              "description": "Secret access key used to sign requests\n",
              "title": "SecretAccessKey",
              "type": "string"
            },
            "sessionToken": {
              "description": "A token that must passed with request to use the temporary\nsecurity credentials.\n",
              "title": "SessionToken",
              "type": "string"
            }
          },
          "required": [
            "accessKeyId",
            "secretAccessKey",
            "sessionToken"
          ],
          "title": "Temporary Security Credentials",
          "type": "object"
        },
        "expires": {
          "description": "Date and time of when the temporary credentials expires.\n",
          "format": "date-time",
          "type": "string"
        }
      },
      "required": [
        "credentials",
        "expires"
      ],
      "title": "AWS S3 Credentials Response",
      "type": "object"
    },
    "filename": "schemas/auth/v1/aws-s3-credentials-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-response.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "description": "Response from a request to authenticate a hawk request.\n",
      "oneOf": [
        {
          "additionalProperties": false,
          "properties": {
            "clientId": {
              "description": "The `clientId` that made this request.  This may be the `id` supplied in\nthe Authorization header, or in the case of a named temporary credential\nmay be embedded in the payload.  In any case, this clientId can be used\nfor logging, auditing, and identifying the credential but **must** not be\nused for access control.  That's what scopes are for.\n",
              "pattern": "^[A-Za-z0-9!@/:.+|_-]+$",
              "type": "string"
            },
            "expires": {
              "description": "The expiration time for the credentials used to make this request.\nThis should be treated as the latest time at which the authorization\nis valid.  For most cases, where the access being authorized occurs\nimmediately, this field can be ignored, as the value will always be\nin the future if the status is `auth-success`.\n",
              "format": "date-time",
              "type": "string"
            },
            "hash": {
              "description": "Payload as extracted from `Authentication` header. This property is\nonly present if a hash is available. You are not required to validate\nthis hash, but if you do, please check `scheme` to ensure that it's\non a scheme you support.\n"
            },
            "scheme": {
              "description": "Authentication scheme the client used. Generally, you don't need to\nread this property unless `hash` is provided and you want to validate\nthe payload hash. Additional values may be added in the future.\n",
              "enum": [
                "hawk"
              ],
              "type": "string"
            },
            "scopes": {
              "description": "List of scopes the client is authorized to access.  Scopes must be\ncomposed of printable ASCII characters and spaces.\n",
              "items": {
                "pattern": "^[ -~]*$",
                "type": "string"
              },
              "type": "array",
              "uniqueItems": true
            },
            "status": {
              "description": "The kind of response, `auth-failed` or `auth-success`.\n",
              "enum": [
                "auth-success"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "scopes",
            "scheme",
            "clientId",
            "expires"
          ],
          "title": "Authentication Successful Response",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "message": {
              "description": "Message saying why the authentication failed.\n",
              "type": "string"
            },
            "status": {
              "description": "The kind of response, `auth-failed` or `auth-success`.\n",
              "enum": [
                "auth-failed"
              ],
              "type": "string"
            }
          },
          "required": [
            "status",
            "message"
          ],
          "title": "Authentication Failed Response",
          "type": "object"
        }
      ],
      "title": "Hawk Signature Authentication Response"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-response.json"
  },
  {
    "content": {
      "$id": "/schemas/auth/v1/authenticate-hawk-request.json#",
      "$schema": "/schemas/common/metaschema.json#",
      "additionalProperties": false,
      "description": "Request to authenticate a hawk request.\n",
      "properties": {
        "authorization": {
          "description": "Authorization header, **must** only be specified if request being\nauthenticated has a `Authorization` header.\n",
          "type": "string"
        },
        "host": {
          "description": "Host for which the request came in, this is typically the `Host` header\nexcluding the port if any.\n",
          "format": "hostname",
          "title": "Hostname or IPv4",
          "type": "string"
        },
        "method": {
          "description": "HTTP method of the request being authenticated.\n",
          "enum": [
            "get",
            "post",
            "put",
            "head",
            "delete",
            "options",
            "trace",
            "copy",
            "lock",
            "mkcol",
            "move",
            "purge",
            "propfind",
            "proppatch",
            "unlock",
            "report",
            "mkactivity",
            "checkout",
            "merge",
            "m-search",
            "notify",
            "subscribe",
            "unsubscribe",
            "patch",
            "search",
            "connect"
          ],
          "type": "string"
        },
        "port": {
          "description": "Port on which the request came in, this is typically `80` or `443`.\nIf you are running behind a reverse proxy look for the `x-forwarded-port`\nheader.\n",
          "maximum": 65535,
          "minimum": 0,
          "type": "integer"
        },
        "resource": {
          "description": "Resource the request operates on including querystring. This is the\nstring that follows the HTTP method.\n**Note,** order of querystring elements is important.\n",
          "type": "string"
        },
        "sourceIp": {
          "description": "Source IP of the authentication request or request that requires\nauthentication. This is only used for audit logging.\n",
          "oneOf": [
            {
              "format": "ipv6"
            },
            {
              "format": "ipv4"
            }
          ],
          "title": "Source IP",
          "type": "string"
        }
      },
      "required": [
        "method",
        "resource",
        "host",
        "port"
      ],
      "title": "Hawk Signature Authentication Request",
      "type": "object"
    },
    "filename": "schemas/auth/v1/authenticate-hawk-request.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "worker-manager",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A worker pool's provisioning run has completed",
          "fields": {
            "providerId": "The provider that did the work for this worker pool.",
            "workerPoolId": "The worker pool ID (provisionerId/workerType)"
          },
          "level": "info",
          "name": "workerPoolProvisioned",
          "title": "Worker Pool Provisioned",
          "type": "worker-pool-provisioned",
          "version": 1
        },
        {
          "description": "The simple estimator has decided that we need some number of instances.",
          "fields": {
            "desiredCapacity": "Amount of capacity that this estimator thinks we should have",
            "maxCapacity": "The maximum amount of capacity that should be running",
            "minCapacity": "The minimum amount of capacity that should be running",
            "pendingTasks": "The number of tasks the queue reports are pending for this worker pool",
            "requestedCapacity": "Amount of capacity that this estimator thinks we should add",
            "runningCapacity": "Amount of currently requested and available capacity",
            "workerPoolId": "The worker pool name (provisionerId/workerType)"
          },
          "level": "notice",
          "name": "simpleEstimate",
          "title": "Simple Estimate Provided",
          "type": "simple-estimate",
          "version": 1
        },
        {
          "description": "An error was reported regarding the given worker pool.  Such errors are generally\nthe responsibility of the owner of the worker pool, but may also indicate issues\nwith the Taskcluster deployment and as such are reported in the service logs as\nwell.  Note that the 'extra' data associated with such a report is not included\nhere.  To see that, use the UI or API to view the worker pool errors directly.",
          "fields": {
            "description": "Description of the error",
            "errorId": "The unique id of this error report",
            "kind": "The error kind",
            "title": "The error title",
            "workerPoolId": "The workerPool where the error occurred"
          },
          "level": "notice",
          "name": "workerError",
          "title": "Worker Error",
          "type": "worker-error",
          "version": 1
        },
        {
          "description": "Rate limiting engaged for a cloud api",
          "fields": {
            "duration": "Length of time the queue is paused for in ms.",
            "providerId": "Which provider has hit a limit",
            "queueName": "Which queue is paused -- there is one for each class of api request",
            "queueSize": "Number of requests remaining in the queue when it is paused.",
            "reason": "Either `errors` or `rateLimit`."
          },
          "level": "any",
          "name": "cloudApiPaused",
          "title": "Cloud API Paused",
          "type": "cloud-api-paused",
          "version": 1
        },
        {
          "description": "A provider has resumed api requests.",
          "fields": {
            "providerId": "Which provider has hit a limit (each provider manages a single project)",
            "queueName": "Which queue is paused -- there is one for each class of api request"
          },
          "level": "notice",
          "name": "cloudApiResumed",
          "title": "Cloud API Resumed",
          "type": "cloud-api-resumed",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/worker-manager/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "These exchanges provide notifications when a worker pool is created or updated.This is so that the provisioner running in a differentprocess at the other end can synchronize to the changes. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create aworker pool, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "worker-pool-created",
          "name": "workerPoolCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-worker-pool-message.json#",
          "title": "Worker Pool Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update aworker pool, a message is posted to this exchange anda provider can act upon it.",
          "exchange": "worker-pool-updated",
          "name": "workerPoolUpdated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-worker-pool-message.json#",
          "title": "Worker Pool Updated Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-worker-manager/v1/",
      "serviceName": "worker-manager",
      "title": "Worker Manager Exchanges"
    },
    "filename": "references/worker-manager/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This service manages workers, including provisioning for dynamic worker pools.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Manager",
          "description": "Retrieve a list of providers that are available for worker pools.",
          "method": "get",
          "name": "listProviders",
          "output": "v1/provider-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/providers",
          "stability": "stable",
          "title": "List Providers",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Create a new worker pool. If the worker pool already exists, this will throw an error.",
          "input": "v1/create-worker-pool-request.json#",
          "method": "put",
          "name": "createWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "worker-manager:manage-worker-pool:<workerPoolId>",
              "worker-manager:provider:<providerId>"
            ]
          },
          "stability": "stable",
          "title": "Create Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Given an existing worker pool definition, this will modify it and return\nthe new definition.\n\nTo delete a worker pool, set its `providerId` to `\"null-provider\"`.\nAfter any existing workers have exited, a cleanup job will remove the\nworker pool.  During that time, the worker pool can be updated again, such\nas to set its `providerId` to a real provider.",
          "input": "v1/update-worker-pool-request.json#",
          "method": "post",
          "name": "updateWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "worker-manager:manage-worker-pool:<workerPoolId>",
              "worker-manager:provider:<providerId>"
            ]
          },
          "stability": "stable",
          "title": "Update Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Mark a worker pool for deletion.  This is the same as updating the pool to\nset its providerId to `\"null-provider\"`, but does not require scope\n`worker-manager:provider:null-provider`.",
          "method": "delete",
          "name": "deleteWorkerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "scopes": "worker-manager:manage-worker-pool:<workerPoolId>",
          "stability": "stable",
          "title": "Delete Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Fetch an existing worker pool defition.",
          "method": "get",
          "name": "workerPool",
          "output": "v1/worker-pool-full.json#",
          "query": [
          ],
          "route": "/worker-pool/<workerPoolId>",
          "stability": "stable",
          "title": "Get Worker Pool",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Manager",
          "description": "Get the list of all the existing worker pools.",
          "method": "get",
          "name": "listWorkerPools",
          "output": "v1/worker-pool-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/worker-pools",
          "stability": "stable",
          "title": "List All Worker Pools",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Report an error that occurred on a worker.  This error will be included\nwith the other errors in `listWorkerPoolErrors(workerPoolId)`.\n\nWorkers can use this endpoint to report startup or configuration errors\nthat might be associated with the worker pool configuration and thus of\ninterest to a worker-pool administrator.\n\nNOTE: errors are publicly visible.  Ensure that none of the content\ncontains secrets or other sensitive information.",
          "input": "v1/report-worker-error-request.json#",
          "method": "post",
          "name": "reportWorkerError",
          "output": "v1/worker-pool-error.json#",
          "query": [
          ],
          "route": "/worker-pool-errors/<workerPoolId>",
          "scopes": {
            "AllOf": [
              "assume:worker-pool:<workerPoolId>",
              "assume:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "stable",
          "title": "Report an error from a worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Get the list of worker pool errors.",
          "method": "get",
          "name": "listWorkerPoolErrors",
          "output": "v1/worker-pool-error-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/worker-pool-errors/<workerPoolId>",
          "stability": "stable",
          "title": "List Worker Pool Errors",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup"
          ],
          "category": "Worker Manager",
          "description": "Get the list of all the existing workers in a given group in a given worker pool.",
          "method": "get",
          "name": "listWorkersForWorkerGroup",
          "output": "v1/worker-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>",
          "stability": "stable",
          "title": "Workers in a specific Worker Group in a Worker Pool",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Manager",
          "description": "Get a single worker.",
          "method": "get",
          "name": "worker",
          "output": "v1/worker-full.json#",
          "query": [
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Get a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Manager",
          "description": "Create a new worker.  The precise behavior of this method depends\non the provider implementing the given worker pool.  Some providers\ndo not support creating workers at all, and will return a 400 error.",
          "input": "v1/create-worker-request.json#",
          "method": "put",
          "name": "createWorker",
          "output": "v1/worker-full.json#",
          "query": [
          ],
          "route": "/workers/<workerPoolId>:/<workerGroup>/<workerId>",
          "scopes": "worker-manager:create-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Create a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId",
            "workerGroup",
            "workerId"
          ],
          "category": "Worker Manager",
          "description": "Remove an existing worker.  The precise behavior of this method depends\non the provider implementing the given worker.  Some providers\ndo not support removing workers at all, and will return a 400 error.\nOthers may begin removing the worker, but it may remain available via\nthe API (perhaps even in state RUNNING) afterward.",
          "method": "delete",
          "name": "removeWorker",
          "query": [
          ],
          "route": "/workers/<workerPoolId>/<workerGroup>/<workerId>",
          "scopes": "worker-manager:remove-worker:<workerPoolId>/<workerGroup>/<workerId>",
          "stability": "stable",
          "title": "Remove a Worker",
          "type": "function"
        },
        {
          "args": [
            "workerPoolId"
          ],
          "category": "Worker Manager",
          "description": "Get the list of all the existing workers in a given worker pool.",
          "method": "get",
          "name": "listWorkersForWorkerPool",
          "output": "v1/worker-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/workers/<workerPoolId>",
          "stability": "stable",
          "title": "Workers in a Worker Pool",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Worker Manager",
          "description": "Register a running worker.  Workers call this method on worker start-up.\n\nThis call both marks the worker as running and returns the credentials\nthe worker will require to perform its work.  The worker must provide\nsome proof of its identity, and that proof varies by provider type.",
          "input": "v1/register-worker-request.json#",
          "method": "post",
          "name": "registerWorker",
          "output": "v1/register-worker-response.json#",
          "query": [
          ],
          "route": "/worker/register",
          "stability": "stable",
          "title": "Register a running worker",
          "type": "function"
        }
      ],
      "serviceName": "worker-manager",
      "title": "Taskcluster Worker Manager"
    },
    "filename": "references/worker-manager/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "secrets",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/secrets/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The secrets service provides a simple key/value store for small bits of secret\ndata.  Access is limited by scopes, so values can be considered secret from\nthose who do not have the relevant scopes.\n\nSecrets also have an expiration date, and once a secret has expired it can no\nlonger be read.  This is useful for short-term secrets such as a temporary\nservice credential or a one-time signing key.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Set the secret associated with some key.  If the secret already exists, it is\nupdated instead.",
          "input": "v1/secret.json#",
          "method": "put",
          "name": "set",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Set Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Delete the secret associated with some key.",
          "method": "delete",
          "name": "remove",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:set:<name>",
          "stability": "stable",
          "title": "Delete Secret",
          "type": "function"
        },
        {
          "args": [
            "name"
          ],
          "category": "Secrets Service",
          "description": "Read the secret associated with some key.  If the secret has recently\nexpired, the response code 410 is returned.  If the caller lacks the\nscope necessary to get the secret, the call will fail with a 403 code\nregardless of whether the secret exists.",
          "method": "get",
          "name": "get",
          "output": "v1/secret.json#",
          "query": [
          ],
          "route": "/secret/<name>",
          "scopes": "secrets:get:<name>",
          "stability": "stable",
          "title": "Read Secret",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Secrets Service",
          "description": "List the names of all secrets.\n\nBy default this end-point will try to return up to 1000 secret names in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "list",
          "output": "v1/secret-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/secrets",
          "stability": "stable",
          "title": "List Secrets",
          "type": "function"
        }
      ],
      "serviceName": "secrets",
      "title": "Taskcluster Secrets API Documentation"
    },
    "filename": "references/secrets/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "queue",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Report result of polling messages from an azure queue.",
          "fields": {
            "failed": "Number of these messages that failed to be handled.",
            "messages": "Number of messages fetched.",
            "resolver": "The name of the queue being polled."
          },
          "level": "info",
          "name": "azureQueuePoll",
          "title": "Azure Queue Poll",
          "type": "azure-queue-poll",
          "version": 1
        },
        {
          "description": "A task has been created (via defineTask or createTask).  This is logged when the task-defined\npulse message is sent.",
          "fields": {
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskDefined",
          "title": "Task Defined",
          "type": "task-defined",
          "version": 1
        },
        {
          "description": "A task is now pending and ready to be executed.  This is logged when the task-pending pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that is now pending.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskPending",
          "title": "Task Pending",
          "type": "task-pending",
          "version": 1
        },
        {
          "description": "A task is now being executed.  This is logged when the task-running pulse message is sent.",
          "fields": {
            "runId": "The runId that is now running.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskRunning",
          "title": "Task Running",
          "type": "task-running",
          "version": 1
        },
        {
          "description": "A task run has been resolved as completed.  This is logged when the task-completed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskCompleted",
          "title": "Task Completed",
          "type": "task-completed",
          "version": 1
        },
        {
          "description": "A task run has been resolved as failed.  This is logged when the task-failed pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskFailed",
          "title": "Task Failed",
          "type": "task-failed",
          "version": 1
        },
        {
          "description": "A task run has been resolved as an exception.  This is logged when the task-exception pulse\nmessage is sent.",
          "fields": {
            "runId": "The runId that was resolved.",
            "taskId": "The task's taskId."
          },
          "level": "notice",
          "name": "taskException",
          "title": "Task Exception",
          "type": "task-exception",
          "version": 1
        },
        {
          "description": "A worker has claimed a task.  In cases where multple tasks were claimed,\none log message will be produced for each task.",
          "fields": {
            "provisionerId": "Provisioner that provisioned the worker claiming work.",
            "runId": "The run of this task assigned to the worker.",
            "taskId": "The task given to the worker.",
            "workerGroup": "Group of worker claiming work.",
            "workerId": "The id of the claiming worker.",
            "workerType": "Type of worker claiming work."
          },
          "level": "notice",
          "name": "taskClaimed",
          "title": "Task Claimed",
          "type": "task-claimed",
          "version": 1
        },
        {
          "description": "A worker has reclaimed a task it had previously claimed, extending its takenUntil\ntimestamp.",
          "fields": {
            "runId": "The run of this task being reclaimed.",
            "taskId": "The task being reclaimed.",
            "workerGroup": "Group of the reclaiming worker.",
            "workerId": "Id of the reclaiming worker."
          },
          "level": "notice",
          "name": "taskReclaimed",
          "title": "Task Reclaimed",
          "type": "task-reclaimed",
          "version": 1
        },
        {
          "description": "Metrics of an iteration of the hint poller.",
          "fields": {
            "claimed": "Number of hints claimed on an iteration.",
            "released": "Number of hints released on an iteration. Should usually be 0.",
            "slept": "If true, there were no hints to claim and the poller slept before claiming again."
          },
          "level": "info",
          "name": "hintPoller",
          "title": "Hint Poller Report",
          "type": "hint-poller",
          "version": 1
        }
      ]
    },
    "filename": "references/queue/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes AMQP exchanges offered by the queue, which allows\nthird-party listeners to monitor tasks as they progress to resolution.\nThese exchanges targets the following audience:\n * Schedulers, who takes action after tasks are completed,\n * Workers, who wants to listen for new or canceled tasks (optional),\n * Tools, that wants to update their view as task progress.\n\nYou'll notice that all the exchanges in the document shares the same\nrouting key pattern. This makes it very easy to bind to all messages\nabout a certain kind tasks.\n\n**Task specific routes**, a task can define a task specific route using\nthe `task.routes` property. See task creation documentation for details\non permissions required to provide task specific routes. If a task has\nthe entry `'notify.by-email'` in as task specific route defined in\n`task.routes` all messages about this task will be CC'ed with the\nrouting-key `'route.notify.by-email'`.\n\nThese routes will always be prefixed `route.`, so that cannot interfere\nwith the _primary_ routing key as documented here. Notice that the\n_primary_ routing key is always prefixed `primary.`. This is ensured\nin the routing key reference, so API clients will do this automatically.\n\nPlease, note that the way RabbitMQ works, the message will only arrive\nin your queue once, even though you may have bound to the exchange with\nmultiple routing key patterns that matches more of the CC'ed routing\nrouting keys.\n\n**Delivery guarantees**, most operations on the queue are idempotent,\nwhich means that if repeated with the same arguments then the requests\nwill ensure completion of the operation and return the same response.\nThis is useful if the server crashes or the TCP connection breaks, but\nwhen re-executing an idempotent operation, the queue will also resend\nany related AMQP messages. Hence, messages may be repeated.\n\nThis shouldn't be much of a problem, as the best you can achieve using\nconfirm messages with AMQP is at-least-once delivery semantics. Hence,\nthis only prevents you from obtaining at-most-once delivery semantics.\n\n**Remark**, some message generated by timeouts maybe dropped if the\nserver crashes at wrong time. Ideally, we'll address this in the\nfuture. For now we suggest you ignore this corner case, and notify us\nif this corner case is of concern to you.",
      "entries": [
        {
          "description": "When a task is created or just defined a message is posted to this\nexchange.\n\nThis message exchange is mainly useful when tasks are scheduled by a\nscheduler that uses `defineTask` as this does not make the task\n`pending`. Thus, no `taskPending` message is published.\nPlease, note that messages are also published on this exchange if defined\nusing `createTask`.",
          "exchange": "task-defined",
          "name": "taskDefined",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-defined-message.json#",
          "title": "Task Defined Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task becomes `pending` a message is posted to this exchange.\n\nThis is useful for workers who doesn't want to constantly poll the queue\nfor new tasks. The queue will also be authority for task states and\nclaims. But using this exchange workers should be able to distribute work\nefficiently and they would be able to reduce their polling interval\nsignificantly without affecting general responsiveness.",
          "exchange": "task-pending",
          "name": "taskPending",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-pending-message.json#",
          "title": "Task Pending Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever a task is claimed by a worker, a run is started on the worker,\nand a message is posted on this exchange.",
          "exchange": "task-running",
          "name": "taskRunning",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-running-message.json#",
          "title": "Task Running Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the `createArtifact` end-point is called, the queue will create\na record of the artifact and post a message on this exchange. All of this\nhappens before the queue returns a signed URL for the caller to upload\nthe actual artifact with (pending on `storageType`).\n\nThis means that the actual artifact is rarely available when this message\nis posted. But it is not unreasonable to assume that the artifact will\nwill become available at some point later. Most signatures will expire in\n30 minutes or so, forcing the uploader to call `createArtifact` with\nthe same payload again in-order to continue uploading the artifact.\n\nHowever, in most cases (especially for small artifacts) it's very\nreasonable assume the artifact will be available within a few minutes.\nThis property means that this exchange is mostly useful for tools\nmonitoring task evaluation. One could also use it count number of\nartifacts per task, or _index_ artifacts though in most cases it'll be\nsmarter to index artifacts after the task in question have completed\nsuccessfully.\n\n*NOTE*: this message is currently only sent for reference and error\nartifacts.  This will be remedied in a future version of Taskcluster.",
          "exchange": "artifact-created",
          "name": "artifactCreated",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/artifact-created-message.json#",
          "title": "Artifact Creation Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task is successfully completed by a worker a message is posted\nthis exchange.\nThis message is routed using the `runId`, `workerGroup` and `workerId`\nthat completed the task. But information about additional runs is also\navailable from the task status structure.",
          "exchange": "task-completed",
          "name": "taskCompleted",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": true,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": true,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": true,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-completed-message.json#",
          "title": "Task Completed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "When a task ran, but failed to complete successfully a message is posted\nto this exchange. This is same as worker ran task-specific code, but the\ntask specific code exited non-zero.",
          "exchange": "task-failed",
          "name": "taskFailed",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-failed-message.json#",
          "title": "Task Failed Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever Taskcluster fails to run a message is posted to this exchange.\nThis happens if the task isn't completed before its `deadlìne`,\nall retries failed (i.e. workers stopped responding), the task was\ncanceled by another entity, or the task carried a malformed payload.\n\nThe specific _reason_ is evident from that task status structure, refer\nto the `reasonResolved` property for the last run.",
          "exchange": "task-exception",
          "name": "taskException",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskId",
              "required": true,
              "summary": "`taskId` for the task this message concerns"
            },
            {
              "multipleWords": false,
              "name": "runId",
              "required": false,
              "summary": "`runId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerGroup",
              "required": false,
              "summary": "`workerGroup` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "workerId",
              "required": false,
              "summary": "`workerId` of latest run for the task, `_` if no run is exists for the task."
            },
            {
              "multipleWords": false,
              "name": "provisionerId",
              "required": true,
              "summary": "`provisionerId` this task is targeted at."
            },
            {
              "multipleWords": false,
              "name": "workerType",
              "required": true,
              "summary": "`workerType` this task must run on."
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` this task was created by."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` this task was created in."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-exception-message.json#",
          "title": "Task Exception Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message is published on task-group-resolved whenever all submitted\ntasks (whether scheduled or unscheduled) for a given task group have\nbeen resolved, regardless of whether they resolved as successful or\nnot. A task group may be resolved multiple times, since new tasks may\nbe submitted against an already resolved task group.",
          "exchange": "task-group-resolved",
          "name": "taskGroupResolved",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "taskGroupId",
              "required": true,
              "summary": "`taskGroupId` for the task-group this message concerns"
            },
            {
              "multipleWords": false,
              "name": "schedulerId",
              "required": true,
              "summary": "`schedulerId` for the task-group this message concerns"
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/task-group-resolved.json#",
          "title": "Task Group Resolved Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-queue/v1/",
      "serviceName": "queue",
      "title": "Queue AMQP Exchanges"
    },
    "filename": "references/queue/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The queue service is responsible for accepting tasks and track their state\nas they are executed by workers. In order ensure they are eventually\nresolved.\n\nThis document describes the API end-points offered by the queue. These \nend-points targets the following audience:\n * Schedulers, who create tasks to be executed,\n * Workers, who execute tasks, and\n * Tools, that wants to inspect the state of a task.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "This end-point will return the task-definition. Notice that the task\ndefinition may have been modified by queue, if an optional property is\nnot specified the queue may provide a default value.",
          "method": "get",
          "name": "task",
          "output": "v1/task.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "stability": "stable",
          "title": "Get Task Definition",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "Get task status structure from `taskId`",
          "method": "get",
          "name": "status",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/status",
          "stability": "stable",
          "title": "Get task status",
          "type": "function"
        },
        {
          "args": [
            "taskGroupId"
          ],
          "category": "Queue Service",
          "description": "List tasks sharing the same `taskGroupId`.\n\nAs a task-group may contain an unbounded number of tasks, this end-point\nmay return a `continuationToken`. To continue listing tasks you must call\nthe `listTaskGroup` again with the `continuationToken` as the\nquery-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 members in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listTaskGroup` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listTaskGroup",
          "output": "v1/list-task-group-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task-group/<taskGroupId>/list",
          "stability": "stable",
          "title": "List Task Group",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "List tasks that depend on the given `taskId`.\n\nAs many tasks from different task-groups may dependent on a single tasks,\nthis end-point may return a `continuationToken`. To continue listing\ntasks you must call `listDependentTasks` again with the\n`continuationToken` as the query-string option `continuationToken`.\n\nBy default this end-point will try to return up to 1000 tasks in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listDependentTasks` with the last `continuationToken` until\nyou get a result without a `continuationToken`.\n\nIf you are not interested in listing all the tasks at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDependentTasks",
          "output": "v1/list-dependent-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/dependents",
          "stability": "stable",
          "title": "List Dependent Tasks",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "Create a new task, this is an **idempotent** operation, so repeat it if\nyou get an internal server error or network connection is dropped.\n\n**Task `deadline`**: the deadline property can be no more than 5 days\ninto the future. This is to limit the amount of pending tasks not being\ntaken care of. Ideally, you should use a much shorter deadline.\n\n**Task expiration**: the `expires` property must be greater than the\ntask `deadline`. If not provided it will default to `deadline` + one\nyear. Notice, that artifacts created by task must expire before the task.\n\n**Task specific routing-keys**: using the `task.routes` property you may\ndefine task specific routing-keys. If a task has a task specific \nrouting-key: `<route>`, then when the AMQP message about the task is\npublished, the message will be CC'ed with the routing-key: \n`route.<route>`. This is useful if you want another component to listen\nfor completed tasks you have posted.  The caller must have scope\n`queue:route:<route>` for each route.\n\n**Dependencies**: any tasks referenced in `task.dependencies` must have\nalready been created at the time of this call.\n\n**Scopes**: Note that the scopes required to complete this API call depend\non the content of the `scopes`, `routes`, `schedulerId`, `priority`,\n`provisionerId`, and `workerType` properties of the task definition.\n\n**Legacy Scopes**: The `queue:create-task:..` scope without a priority and\nthe `queue:define-task:..` and `queue:task-group-id:..` scopes are considered\nlegacy and should not be used. Note that the new, non-legacy scopes require\na `queue:scheduler-id:..` scope as well as scopes for the proper priority.",
          "input": "v1/create-task-request.json#",
          "method": "put",
          "name": "createTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>",
          "scopes": {
            "AllOf": [
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              },
              {
                "each": "queue:route:<route>",
                "for": "route",
                "in": "routes"
              },
              {
                "AnyOf": [
                  {
                    "AllOf": [
                      "queue:scheduler-id:<schedulerId>",
                      {
                        "AnyOf": [
                          {
                            "each": "queue:create-task:<priority>:<provisionerId>/<workerType>",
                            "for": "priority",
                            "in": "priorities"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "if": "legacyScopes",
                    "then": {
                      "AnyOf": [
                        "queue:create-task:<provisionerId>/<workerType>",
                        {
                          "AllOf": [
                            "queue:define-task:<provisionerId>/<workerType>",
                            "queue:task-group-id:<schedulerId>/<taskGroupId>",
                            "queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>"
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Create New Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "**Deprecated**, this is the same as `createTask` with a **self-dependency**.\nThis is only present for legacy.",
          "input": "v1/create-task-request.json#",
          "method": "post",
          "name": "defineTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/define",
          "scopes": {
            "AllOf": [
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              },
              {
                "each": "queue:route:<route>",
                "for": "route",
                "in": "routes"
              },
              {
                "AnyOf": [
                  {
                    "AllOf": [
                      "queue:scheduler-id:<schedulerId>",
                      {
                        "AnyOf": [
                          {
                            "each": "queue:create-task:<priority>:<provisionerId>/<workerType>",
                            "for": "priority",
                            "in": "priorities"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "if": "legacyScopes",
                    "then": {
                      "AnyOf": [
                        "queue:define-task:<provisionerId>/<workerType>",
                        "queue:create-task:<provisionerId>/<workerType>",
                        {
                          "AllOf": [
                            "queue:define-task:<provisionerId>/<workerType>",
                            "queue:task-group-id:<schedulerId>/<taskGroupId>"
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Define Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "scheduleTask will schedule a task to be executed, even if it has\nunresolved dependencies. A task would otherwise only be scheduled if\nits dependencies were resolved.\n\nThis is useful if you have defined a task that depends on itself or on\nsome other task that has not been resolved, but you wish the task to be\nscheduled immediately.\n\nThis will announce the task as pending and workers will be allowed to\nclaim it and resolve the task.\n\n**Note** this operation is **idempotent** and will not fail or complain\nif called with a `taskId` that is already scheduled, or even resolved.\nTo reschedule a task previously resolved, use `rerunTask`.",
          "method": "post",
          "name": "scheduleTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/schedule",
          "scopes": {
            "AnyOf": [
              "queue:schedule-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:schedule-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Schedule Defined Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "This method _reruns_ a previously resolved task, even if it was\n_completed_. This is useful if your task completes unsuccessfully, and\nyou just want to run it from scratch again. This will also reset the\nnumber of `retries` allowed.\n\nThis method is deprecated in favour of creating a new task with the same\ntask definition (but with a new taskId).\n\nRemember that `retries` in the task status counts the number of runs that\nthe queue have started because the worker stopped responding, for example\nbecause a spot node died.\n\n**Remark** this operation is idempotent, if you try to rerun a task that\nis not either `failed` or `completed`, this operation will just return\nthe current task status.",
          "method": "post",
          "name": "rerunTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/rerun",
          "scopes": {
            "AnyOf": [
              "queue:rerun-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:rerun-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Rerun a Resolved Task",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "This method will cancel a task that is either `unscheduled`, `pending` or\n`running`. It will resolve the current run as `exception` with\n`reasonResolved` set to `canceled`. If the task isn't scheduled yet, ie.\nit doesn't have any runs, an initial run will be added and resolved as\ndescribed above. Hence, after canceling a task, it cannot be scheduled\nwith `queue.scheduleTask`, but a new run can be created with\n`queue.rerun`. These semantics is equivalent to calling\n`queue.scheduleTask` immediately followed by `queue.cancelTask`.\n\n**Remark** this operation is idempotent, if you try to cancel a task that\nisn't `unscheduled`, `pending` or `running`, this operation will just\nreturn the current task status.",
          "method": "post",
          "name": "cancelTask",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/cancel",
          "scopes": {
            "AnyOf": [
              "queue:cancel-task:<schedulerId>/<taskGroupId>/<taskId>",
              {
                "AllOf": [
                  "queue:cancel-task",
                  "assume:scheduler-id:<schedulerId>/<taskGroupId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Cancel Task",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Queue Service",
          "description": "Claim pending task(s) for the given `provisionerId`/`workerType` queue.\n\nIf any work is available (even if fewer than the requested number of\ntasks, this will return immediately. Otherwise, it will block for tens of\nseconds waiting for work.  If no work appears, it will return an emtpy\nlist of tasks.  Callers should sleep a short while (to avoid denial of\nservice in an error condition) and call the endpoint again.  This is a\nsimple implementation of \"long polling\".",
          "input": "v1/claim-work-request.json#",
          "method": "post",
          "name": "claimWork",
          "output": "v1/claim-work-response.json#",
          "query": [
          ],
          "route": "/claim-work/<provisionerId>/<workerType>",
          "scopes": {
            "AllOf": [
              "queue:claim-work:<provisionerId>/<workerType>",
              "queue:worker-id:<workerGroup>/<workerId>"
            ]
          },
          "stability": "stable",
          "title": "Claim Work",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "claim a task - never documented",
          "input": "v1/task-claim-request.json#",
          "method": "post",
          "name": "claimTask",
          "output": "v1/task-claim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/claim",
          "scopes": {
            "AnyOf": [
              {
                "AllOf": [
                  "queue:claim-task:<provisionerId>/<workerType>",
                  "queue:worker-id:<workerGroup>/<workerId>"
                ]
              },
              {
                "AllOf": [
                  "queue:claim-task",
                  "assume:worker-type:<provisionerId>/<workerType>",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "deprecated",
          "title": "Claim Task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "Refresh the claim for a specific `runId` for given `taskId`. This updates\nthe `takenUntil` property and returns a new set of temporary credentials\nfor performing requests on behalf of the task. These credentials should\nbe used in-place of the credentials returned by `claimWork`.\n\nThe `reclaimTask` requests serves to:\n * Postpone `takenUntil` preventing the queue from resolving\n   `claim-expired`,\n * Refresh temporary credentials used for processing the task, and\n * Abort execution if the task/run have been resolved.\n\nIf the `takenUntil` timestamp is exceeded the queue will resolve the run\nas _exception_ with reason `claim-expired`, and proceeded to retry to the\ntask. This ensures that tasks are retried, even if workers disappear\nwithout warning.\n\nIf the task is resolved, this end-point will return `409` reporting\n`RequestConflict`. This typically happens if the task have been canceled\nor the `task.deadline` have been exceeded. If reclaiming fails, workers\nshould abort the task and forget about the given `runId`. There is no\nneed to resolve the run or upload artifacts.",
          "method": "post",
          "name": "reclaimTask",
          "output": "v1/task-reclaim-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/reclaim",
          "scopes": {
            "AnyOf": [
              "queue:reclaim-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:claim-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Reclaim task",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "Report a task completed, resolving the run as `completed`.",
          "method": "post",
          "name": "reportCompleted",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/completed",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Run Completed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "Report a run failed, resolving the run as `failed`. Use this to resolve\na run that failed because the task specific code behaved unexpectedly.\nFor example the task exited non-zero, or didn't produce expected output.\n\nDo not use this if the task couldn't be run because if malformed\npayload, or other unexpected condition. In these cases we have a task\nexception, which should be reported with `reportException`.",
          "method": "post",
          "name": "reportFailed",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/failed",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Run Failed",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "Resolve a run as _exception_. Generally, you will want to report tasks as\nfailed instead of exception. You should `reportException` if,\n\n  * The `task.payload` is invalid,\n  * Non-existent resources are referenced,\n  * Declared actions cannot be executed due to unavailable resources,\n  * The worker had to shutdown prematurely,\n  * The worker experienced an unknown error, or,\n  * The task explicitly requested a retry.\n\nDo not use this to signal that some user-specified code crashed for any\nreason specific to this code. If user-specific code hits a resource that\nis temporarily unavailable worker should report task _failed_.",
          "input": "v1/task-exception-request.json#",
          "method": "post",
          "name": "reportException",
          "output": "v1/task-status-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/exception",
          "scopes": {
            "AnyOf": [
              "queue:resolve-task:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:resolve-task",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Report Task Exception",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Queue Service",
          "description": "This API end-point creates an artifact for a specific run of a task. This\nshould **only** be used by a worker currently operating on this task, or\nfrom a process running within the task (ie. on the worker).\n\nAll artifacts must specify when they `expires`, the queue will\nautomatically take care of deleting artifacts past their\nexpiration point. This features makes it feasible to upload large\nintermediate artifacts from data processing applications, as the\nartifacts can be set to expire a few days later.\n\nWe currently support \"S3 Artifacts\" officially, with remaining support\nfor two deprecated types.  Do not use these deprecated types.\n\n**S3 artifacts**, is useful for static files which will be\nstored on S3. When creating an S3 artifact the queue will return a\npre-signed URL to which you can do a `PUT` request to upload your\nartifact. Note that `PUT` request **must** specify the `content-length`\nheader and **must** give the `content-type` header the same value as in\nthe request to `createArtifact`.\n\n**Reference artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts really only have a `url` property and\nwhen the artifact is requested the client will be redirect the URL\nprovided with a `303` (See Other) redirect. Please note that we cannot\ndelete artifacts you upload to other service, we can only delete the\nreference to the artifact, when it expires.\n\n**Error artifacts**, only consists of meta-data which the queue will\nstore for you. These artifacts are only meant to indicate that you the\nworker or the task failed to generate a specific artifact, that you\nwould otherwise have uploaded. For example docker-worker will upload an\nerror artifact, if the file it was supposed to upload doesn't exists or\nturns out to be a directory. Clients requesting an error artifact will\nget a `424` (Failed Dependency) response. This is mainly designed to\nensure that dependent tasks can distinguish between artifacts that were\nsuppose to be generated and artifacts for which the name is misspelled.\n\n**Artifact immutability**, generally speaking you cannot overwrite an\nartifact when created. But if you repeat the request with the same\nproperties the request will succeed as the operation is idempotent.\nThis is useful if you need to refresh a signed URL while uploading.\nDo not abuse this to overwrite artifacts created by another entity!\nSuch as worker-host overwriting artifact created by worker-code.\n\nAs a special case the `url` property on _reference artifacts_ can be\nupdated. You should only use this to update the `url` property for\nreference artifacts your process has created.",
          "input": "v1/post-artifact-request.json#",
          "method": "post",
          "name": "createArtifact",
          "output": "v1/post-artifact-response.json#",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "AnyOf": [
              "queue:create-artifact:<taskId>/<runId>",
              {
                "AllOf": [
                  "queue:create-artifact:<name>",
                  "assume:worker-id:<workerGroup>/<workerId>"
                ]
              }
            ]
          },
          "stability": "stable",
          "title": "Create Artifact",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId",
            "name"
          ],
          "category": "Queue Service",
          "description": "Get artifact by `<name>` from a specific run.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with an HTTP client that can handle responses correctly.\n\n**Downloading artifacts**\nThere are some special considerations for those http clients which download\nartifacts.  This api endpoint is designed to be compatible with an HTTP 1.1\ncompliant client, but has extra features to ensure the download is valid.\nIt is strongly recommend that consumers use either taskcluster-lib-artifact (JS),\ntaskcluster-lib-artifact-go (Go) or the CLI written in Go to interact with\nartifacts.\n\nIn order to download an artifact the following must be done:\n\n1. Obtain queue url.  Building a signed url with a taskcluster client is\nrecommended\n1. Make a GET request which does not follow redirects\n1. In all cases, if specified, the\nx-taskcluster-location-{content,transfer}-{sha256,length} values must be\nvalidated to be equal to the Content-Length and Sha256 checksum of the\nfinal artifact downloaded. as well as any intermediate redirects\n1. If this response is a 500-series error, retry using an exponential\nbackoff.  No more than 5 retries should be attempted\n1. If this response is a 400-series error, treat it appropriately for\nyour context.  This might be an error in responding to this request or\nan Error storage type body.  This request should not be retried.\n1. If this response is a 200-series response, the response body is the artifact.\nIf the x-taskcluster-location-{content,transfer}-{sha256,length} and\nx-taskcluster-location-content-encoding are specified, they should match\nthis response body\n1. If the response type is a 300-series redirect, the artifact will be at the\nlocation specified by the `Location` header.  There are multiple artifact storage\ntypes which use a 300-series redirect.\n1. For all redirects followed, the user must verify that the content-sha256, content-length,\ntransfer-sha256, transfer-length and content-encoding match every further request.  The final\nartifact must also be validated against the values specified in the original queue response\n1. Caching of requests with an x-taskcluster-artifact-storage-type value of `reference`\nmust not occur\n\n**Headers**\nThe following important headers are set on the response to this method:\n\n* location: the url of the artifact if a redirect is to be performed\n* x-taskcluster-artifact-storage-type: the storage type.  Example: s3\n\nThe following important headers are set on responses to this method for Blob artifacts\n\n* x-taskcluster-location-content-sha256: the SHA256 of the artifact\n*after* any content-encoding is undone.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-content-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-transfer-sha256: the SHA256 of the artifact\n*before* any content-encoding is undone.  This is the SHA256 of what is sent over\nthe wire.  Sha256 is hex encoded (e.g. [0-9A-Fa-f]{64})\n* x-taskcluster-location-transfer-length: the number of bytes *after* any content-encoding\nis undone\n* x-taskcluster-location-content-encoding: the content-encoding used.  It will either\nbe `gzip` or `identity` right now.  This is hardcoded to a value set when the artifact\nwas created and no content-negotiation occurs\n* x-taskcluster-location-content-type: the content-type of the artifact\n\n**Caching**, artifacts may be cached in data centers closer to the\nworkers in-order to reduce bandwidth costs. This can lead to longer\nresponse times. Caching can be skipped by setting the header\n`x-taskcluster-skip-cache: true`, this should only be used for resources\nwhere request volume is known to be low, and caching not useful.\n(This feature may be disabled in the future, use is sparingly!)",
          "method": "get",
          "name": "getArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": {
              "AllOf": [
                "queue:get-artifact:<name>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Artifact from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "name"
          ],
          "category": "Queue Service",
          "description": "Get artifact by `<name>` from the last run of a task.\n\n**Public Artifacts**, in-order to get an artifact you need the scope\n`queue:get-artifact:<name>`, where `<name>` is the name of the artifact.\nBut if the artifact `name` starts with `public/`, authentication and\nauthorization is not necessary to fetch the artifact.\n\n**API Clients**, this method will redirect you to the artifact, if it is\nstored externally. Either way, the response may not be JSON. So API\nclient users might want to generate a signed URL for this end-point and\nuse that URL with a normal HTTP client.\n\n**Remark**, this end-point is slightly slower than\n`queue.getArtifact`, so consider that if you already know the `runId` of\nthe latest run. Otherwise, just us the most convenient API end-point.",
          "method": "get",
          "name": "getLatestArtifact",
          "query": [
          ],
          "route": "/task/<taskId>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": {
              "AllOf": [
                "queue:get-artifact:<name>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Artifact from Latest Run",
          "type": "function"
        },
        {
          "args": [
            "taskId",
            "runId"
          ],
          "category": "Queue Service",
          "description": "Returns a list of artifacts and associated meta-data for a given run.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/runs/<runId>/artifacts",
          "stability": "stable",
          "title": "Get Artifacts from Run",
          "type": "function"
        },
        {
          "args": [
            "taskId"
          ],
          "category": "Queue Service",
          "description": "Returns a list of artifacts and associated meta-data for the latest run\nfrom the given task.\n\nAs a task may have many artifacts paging may be necessary. If this\nend-point returns a `continuationToken`, you should call the end-point\nagain with the `continuationToken` as the query-string option:\n`continuationToken`.\n\nBy default this end-point will list up-to 1000 artifacts in a single page\nyou may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listLatestArtifacts",
          "output": "v1/list-artifacts-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/task/<taskId>/artifacts",
          "stability": "stable",
          "title": "Get Artifacts from Latest Run",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Queue Service",
          "description": "Get all active provisioners.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 provisioners in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listProvisioners",
          "output": "v1/list-provisioners-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners",
          "stability": "experimental",
          "title": "Get a list of all active provisioners",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Queue Service",
          "description": "Get an active provisioner.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "method": "get",
          "name": "getProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "stability": "experimental",
          "title": "Get an active provisioner",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Queue Service",
          "description": "Declare a provisioner, supplying some details about it.\n\n`declareProvisioner` allows updating one or more properties of a provisioner as long as the required scopes are\npossessed. For example, a request to update the `my-provisioner`\nprovisioner with a body `{description: 'This provisioner is great'}` would require you to have the scope\n`queue:declare-provisioner:my-provisioner#description`.\n\nThe term \"provisioner\" is taken broadly to mean anything with a provisionerId.\nThis does not necessarily mean there is an associated service performing any\nprovisioning activity.",
          "input": "v1/update-provisioner-request.json#",
          "method": "put",
          "name": "declareProvisioner",
          "output": "v1/provisioner-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-provisioner:<provisionerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Update a provisioner",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Queue Service",
          "description": "Get an approximate number of pending tasks for the given `provisionerId`\nand `workerType`.\n\nThe underlying Azure Storage Queues only promises to give us an estimate.\nFurthermore, we cache the result in memory for 20 seconds. So consumers\nshould be no means expect this to be an accurate number.\nIt is, however, a solid estimate of the number of pending tasks.",
          "method": "get",
          "name": "pendingTasks",
          "output": "v1/pending-tasks-response.json#",
          "query": [
          ],
          "route": "/pending/<provisionerId>/<workerType>",
          "stability": "stable",
          "title": "Get Number of Pending Tasks",
          "type": "function"
        },
        {
          "args": [
            "provisionerId"
          ],
          "category": "Queue Service",
          "description": "Get all active worker-types for the given provisioner.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 worker-types in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkerTypes",
          "output": "v1/list-workertypes-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/provisioners/<provisionerId>/worker-types",
          "stability": "experimental",
          "title": "Get a list of all active worker-types",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Queue Service",
          "description": "Get a worker-type from a provisioner.",
          "method": "get",
          "name": "getWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "stability": "experimental",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Queue Service",
          "description": "Declare a workerType, supplying some details about it.\n\n`declareWorkerType` allows updating one or more properties of a worker-type as long as the required scopes are\npossessed. For example, a request to update the `highmem` worker-type within the `my-provisioner`\nprovisioner with a body `{description: 'This worker type is great'}` would require you to have the scope\n`queue:declare-worker-type:my-provisioner/highmem#description`.",
          "input": "v1/update-workertype-request.json#",
          "method": "put",
          "name": "declareWorkerType",
          "output": "v1/workertype-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker-type:<provisionerId>/<workerType>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Update a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Queue Service",
          "description": "Get a list of all active workers of a workerType.\n\n`listWorkers` allows a response to be filtered by quarantined and non quarantined workers.\nTo filter the query, you should call the end-point with `quarantined` as a query-string option with a\ntrue or false value.\n\nThe response is paged. If this end-point returns a `continuationToken`, you\nshould call the end-point again with the `continuationToken` as a query-string\noption. By default this end-point will list up to 1000 workers in a single\npage. You may limit this with the query-string parameter `limit`.",
          "method": "get",
          "name": "listWorkers",
          "output": "v1/list-workers-response.json#",
          "query": [
            "continuationToken",
            "limit",
            "quarantined"
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers",
          "stability": "experimental",
          "title": "Get a list of all active workers of a workerType",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Queue Service",
          "description": "Get a worker from a worker-type.",
          "method": "get",
          "name": "getWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "stability": "experimental",
          "title": "Get a worker-type",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Queue Service",
          "description": "Quarantine a worker",
          "input": "v1/quarantine-worker-request.json#",
          "method": "put",
          "name": "quarantineWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/workers/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              "queue:quarantine-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>"
            ]
          },
          "stability": "experimental",
          "title": "Quarantine a worker",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType",
            "workerGroup",
            "workerId"
          ],
          "category": "Queue Service",
          "description": "Declare a worker, supplying some details about it.\n\n`declareWorker` allows updating one or more properties of a worker as long as the required scopes are\npossessed.",
          "input": "v1/update-worker-request.json#",
          "method": "put",
          "name": "declareWorker",
          "output": "v1/worker-response.json#",
          "query": [
          ],
          "route": "/provisioners/<provisionerId>/worker-types/<workerType>/<workerGroup>/<workerId>",
          "scopes": {
            "AllOf": [
              {
                "each": "queue:declare-worker:<provisionerId>/<workerType>/<workerGroup>/<workerId>#<property>",
                "for": "property",
                "in": "properties"
              }
            ]
          },
          "stability": "experimental",
          "title": "Declare a worker",
          "type": "function"
        }
      ],
      "serviceName": "queue",
      "title": "Queue API Documentation"
    },
    "filename": "references/queue/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "purge-cache",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/purge-cache/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The purge-cache service is responsible for tracking cache-purge requests.\n\nUser create purge requests for specific caches on specific workers, and\nthese requests are timestamped.  Workers consult the service before\nstarting a new task, and purge any caches older than the timestamp.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Purge-Cache Service",
          "description": "Publish a request to purge caches named `cacheName` with\non `provisionerId`/`workerType` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
          "input": "v1/purge-cache-request.json#",
          "method": "post",
          "name": "purgeCache",
          "query": [
          ],
          "route": "/purge-cache/<provisionerId>/<workerType>",
          "scopes": "purge-cache:<provisionerId>/<workerType>:<cacheName>",
          "stability": "stable",
          "title": "Purge Worker Cache",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Purge-Cache Service",
          "description": "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.",
          "method": "get",
          "name": "allPurgeRequests",
          "output": "v1/all-purge-cache-request-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/purge-cache/list",
          "stability": "stable",
          "title": "All Open Purge Requests",
          "type": "function"
        },
        {
          "args": [
            "provisionerId",
            "workerType"
          ],
          "category": "Purge-Cache Service",
          "description": "List the caches for this `provisionerId`/`workerType` that should to be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
          "method": "get",
          "name": "purgeRequests",
          "output": "v1/purge-cache-request-list.json#",
          "query": [
            "since"
          ],
          "route": "/purge-cache/<provisionerId>/<workerType>",
          "stability": "stable",
          "title": "Open Purge Requests for a provisionerId/workerType pair",
          "type": "function"
        }
      ],
      "serviceName": "purge-cache",
      "title": "Purge Cache API"
    },
    "filename": "references/purge-cache/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "notify",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "Email has been sent.",
          "fields": {
            "address": "The requested recepient of the email."
          },
          "level": "info",
          "name": "email",
          "title": "Email Sent",
          "type": "email",
          "version": 1
        },
        {
          "description": "A pulse event has been published.",
          "fields": {
            "routingKey": "The requested routingKey of the message."
          },
          "level": "info",
          "name": "pulse",
          "title": "Pulse Event Published",
          "type": "pulse",
          "version": 1
        },
        {
          "description": "An irc message has been sent.",
          "fields": {
            "dest": "A user or channel. Will begin with \"#\" if a channel."
          },
          "level": "info",
          "name": "irc",
          "title": "IRC Message Sent",
          "type": "irc",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/notify/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "This pretty much only contains the simple free-form\nmessage that can be published from this service from a request\nby anybody with the proper scopes.",
      "entries": [
        {
          "description": "An arbitrary message that a taskcluster user\ncan trigger if they like.\n\nThe standard one that is published by us watching\nfor the completion of tasks is just the task status\ndata that we pull from the queue `status()` endpoint\nwhen we notice a task is complete.",
          "exchange": "notification",
          "name": "notify",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/notification-message.json#",
          "title": "Notification Messages",
          "type": "topic-exchange"
        },
        {
          "description": "A message which is to be sent to an irc channel or\nuser is published to this exchange",
          "exchange": "irc-request",
          "name": "ircRequest",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `'primary'` for the formalized routing key."
            },
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/irc-request.json#",
          "title": "Request for irc notification",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-notify/v1/",
      "serviceName": "notify",
      "title": "Notify AMQP Exchanges"
    },
    "filename": "references/notify/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The notification service listens for tasks with associated notifications\nand handles requests to send emails and post pulse messages.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Send an email to `address`. The content is markdown and will be rendered\nto HTML, but both the HTML and raw markdown text will be sent in the\nemail. If a link is included, it will be rendered to a nice button in the\nHTML version of the email",
          "input": "v1/email-request.json#",
          "method": "post",
          "name": "email",
          "query": [
          ],
          "route": "/email",
          "scopes": "notify:email:<address>",
          "stability": "experimental",
          "title": "Send an Email",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Publish a message on pulse with the given `routingKey`.",
          "input": "v1/pulse-request.json#",
          "method": "post",
          "name": "pulse",
          "query": [
          ],
          "route": "/pulse",
          "scopes": "notify:pulse:<routingKey>",
          "stability": "experimental",
          "title": "Publish a Pulse Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Post a message on IRC to a specific channel or user, or a specific user\non a specific channel.\n\nSuccess of this API method does not imply the message was successfully\nposted. This API method merely inserts the IRC message into a queue\nthat will be processed by a background process.\nThis allows us to re-send the message in face of connection issues.\n\nHowever, if the user isn't online the message will be dropped without\nerror. We maybe improve this behavior in the future. For now just keep\nin mind that IRC is a best-effort service.",
          "input": "v1/irc-request.json#",
          "method": "post",
          "name": "irc",
          "query": [
          ],
          "route": "/irc",
          "scopes": {
            "else": "notify:irc-user:<user>",
            "if": "channelRequest",
            "then": "notify:irc-channel:<channel>"
          },
          "stability": "experimental",
          "title": "Post IRC Message",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Add the given address to the notification denylist. The address\ncan be of either of the three supported address type namely pulse, email\nor IRC(user or channel). Addresses in the denylist will be ignored\nby the notification service.",
          "input": "v1/notification-address.json#",
          "method": "post",
          "name": "addDenylistAddress",
          "query": [
          ],
          "route": "/denylist/add",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Denylist Given Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Delete the specified address from the notification denylist.",
          "input": "v1/notification-address.json#",
          "method": "delete",
          "name": "deleteDenylistAddress",
          "query": [
          ],
          "route": "/denylist/delete",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "Delete Denylisted Address",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Notify Service",
          "description": "Lists all the denylisted addresses.\n\nBy default this end-point will try to return up to 1000 addresses in one\nrequest. But it **may return less**, even if more tasks are available.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `list` with the last `continuationToken` until you\nget a result without a `continuationToken`.\n\nIf you are not interested in listing all the members at once, you may\nuse the query-string option `limit` to return fewer.",
          "method": "get",
          "name": "listDenylist",
          "output": "v1/notification-address-list.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/denylist/list",
          "scopes": "notify:manage-denylist",
          "stability": "experimental",
          "title": "List Denylisted Notifications",
          "type": "function"
        }
      ],
      "serviceName": "notify",
      "title": "Notification Service"
    },
    "filename": "references/notify/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/manifest-v3.json#",
      "references": [
        "/references/auth/v1/api.json",
        "/references/auth/v1/exchanges.json",
        "/references/auth/v1/logs.json",
        "/references/built-in-workers/v1/logs.json",
        "/references/github/v1/api.json",
        "/references/github/v1/exchanges.json",
        "/references/github/v1/logs.json",
        "/references/hooks/v1/api.json",
        "/references/hooks/v1/exchanges.json",
        "/references/hooks/v1/logs.json",
        "/references/index/v1/api.json",
        "/references/index/v1/logs.json",
        "/references/notify/v1/api.json",
        "/references/notify/v1/exchanges.json",
        "/references/notify/v1/logs.json",
        "/references/purge-cache/v1/api.json",
        "/references/purge-cache/v1/logs.json",
        "/references/queue/v1/api.json",
        "/references/queue/v1/exchanges.json",
        "/references/queue/v1/logs.json",
        "/references/secrets/v1/api.json",
        "/references/secrets/v1/logs.json",
        "/references/worker-manager/v1/api.json",
        "/references/worker-manager/v1/exchanges.json",
        "/references/worker-manager/v1/logs.json"
      ]
    },
    "filename": "references/manifest.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "index",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        }
      ]
    },
    "filename": "references/index/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The index service is responsible for indexing tasks. The service ensures that\ntasks can be located by user-defined names.\n\nAs described in the service documentation, tasks are typically indexed via Pulse\nmessages, so the most common use of API methods is to read from the index.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
            "indexPath"
          ],
          "category": "Index Service",
          "description": "Find a task by index path, returning the highest-rank task with that path. If no\ntask exists for the given path, this API end-point will respond with a 404 status.",
          "method": "get",
          "name": "findTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<indexPath>",
          "stability": "stable",
          "title": "Find Indexed Task",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "List the namespaces immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 namespaces. If more namespaces are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.",
          "method": "get",
          "name": "listNamespaces",
          "output": "v1/list-namespaces-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/namespaces/<namespace>",
          "stability": "stable",
          "title": "List Namespaces",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "List the tasks immediately under a given namespace.\n\nThis endpoint\nlists up to 1000 tasks. If more tasks are present, a\n`continuationToken` will be returned, which can be given in the next\nrequest. For the initial request, the payload should be an empty JSON\nobject.\n\n**Remark**, this end-point is designed for humans browsing for tasks, not\nservices, as that makes little sense.",
          "method": "get",
          "name": "listTasks",
          "output": "v1/list-tasks-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/tasks/<namespace>",
          "stability": "stable",
          "title": "List Tasks",
          "type": "function"
        },
        {
          "args": [
            "namespace"
          ],
          "category": "Index Service",
          "description": "Insert a task into the index.  If the new rank is less than the existing rank\nat the given index path, the task is not indexed but the response is still 200 OK.\n\nPlease see the introduction above for information\nabout indexing successfully completed tasks automatically using custom routes.",
          "input": "v1/insert-task-request.json#",
          "method": "put",
          "name": "insertTask",
          "output": "v1/indexed-task-response.json#",
          "query": [
          ],
          "route": "/task/<namespace>",
          "scopes": "index:insert-task:<namespace>",
          "stability": "stable",
          "title": "Insert Task into Index",
          "type": "function"
        },
        {
          "args": [
            "indexPath",
            "name"
          ],
          "category": "Index Service",
          "description": "Find a task by index path and redirect to the artifact on the most recent\nrun with the given `name`.\n\nNote that multiple calls to this endpoint may return artifacts from differen tasks\nif a new task is inserted into the index between calls. Avoid using this method as\na stable link to multiple, connected files if the index path does not contain a\nunique identifier.  For example, the following two links may return unrelated files:\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/installer.exe`\n* https://tc.example.com/api/index/v1/task/some-app.win64.latest.installer/artifacts/public/debug-symbols.zip`\n\nThis problem be remedied by including the revision in the index path or by bundling both\ninstaller and debug symbols into a single artifact.\n\nIf no task exists for the given index path, this API end-point responds with 404.",
          "method": "get",
          "name": "findArtifactFromTask",
          "query": [
          ],
          "route": "/task/<indexPath>/artifacts/<name>",
          "scopes": {
            "if": "private",
            "then": "queue:get-artifact:<name>"
          },
          "stability": "stable",
          "title": "Get Artifact From Indexed Task",
          "type": "function"
        }
      ],
      "serviceName": "index",
      "title": "Task Index API Documentation"
    },
    "filename": "references/index/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "hooks",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A hook was fired, meaning that a task was created for it.  This is also\nlogged when the attempt to fire the hook failed, in which case the 'result'\nfield is \"failed\".  Since this is often the result of user error, the error\nmessage itself is not included; consult the last-fires for the indicated\nhook to see them.",
          "fields": {
            "firedBy": "The event leading to the hook being fired",
            "hookGroupId": "The group ID of the hook that failed",
            "hookId": "The ID of the hook that failed",
            "result": "\"success\" (task created), \"failure\" (task not created), or \"declined\" (hook did not generate a task)\"",
            "taskId": "The taskId of the task that was (or would have been) created"
          },
          "level": "info",
          "name": "hookFire",
          "title": "A hook was fired",
          "type": "hook-fire",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/hooks/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service is responsible for creating tasks at specific times orin .  response to webhooks and API calls.Using this exchange allows us tomake hooks which repsond to particular pulse messagesThese exchanges provide notifications when a hook is created, updatedor deleted. This is so that the listener running in a different hooks process at the other end can direct another listener specified by`hookGroupId` and `hookId` to synchronize its bindings. But you are ofcourse welcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Whenever the api receives a request to create apulse based hook, a message is posted to this exchange andthe receiver creates a listener with the bindings, to create a task",
          "exchange": "hook-created",
          "name": "hookCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to update apulse based hook, a message is posted to this exchange andthe receiver updates the listener associated with that hook.",
          "exchange": "hook-updated",
          "name": "hookUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Whenever the api receives a request to delete apulse based hook, a message is posted to this exchange andthe receiver deletes the listener associated with that hook.",
          "exchange": "hook-deleted",
          "name": "hookDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/pulse-hook-changed-message.json#",
          "title": "Hook Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-hooks/v1/",
      "serviceName": "hooks",
      "title": "Exchanges to manage hooks"
    },
    "filename": "references/hooks/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The hooks service provides a mechanism for creating tasks in response to events.\n",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Hooks Service",
          "description": "This endpoint will return a list of all hook groups with at least one hook.",
          "method": "get",
          "name": "listHookGroups",
          "output": "v1/list-hook-groups-response.json#",
          "query": [
          ],
          "route": "/hooks",
          "stability": "stable",
          "title": "List hook groups",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will return a list of all the hook definitions within a\ngiven hook group.",
          "method": "get",
          "name": "listHooks",
          "output": "v1/list-hooks-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>",
          "stability": "stable",
          "title": "List hooks in a given group",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will return the hook definition for the given `hookGroupId`\nand hookId.",
          "method": "get",
          "name": "hook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get hook definition",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will return the current status of the hook.  This represents a\nsnapshot in time and may vary from one call to the next.\n\nThis method is deprecated in favor of listLastFires.",
          "method": "get",
          "name": "getHookStatus",
          "output": "v1/hook-status.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/status",
          "stability": "deprecated",
          "title": "Get hook status",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will create a new hook.\n\nThe caller's credentials must include the role that will be used to\ncreate the task.  That role must satisfy task.scopes as well as the\nnecessary scopes to add the task to the queue.",
          "input": "v1/create-hook-request.json#",
          "method": "put",
          "name": "createHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Create a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will update an existing hook.  All fields except\n`hookGroupId` and `hookId` can be modified.",
          "input": "v1/create-hook-request.json#",
          "method": "post",
          "name": "updateHook",
          "output": "v1/hook-definition.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": {
            "AllOf": [
              "hooks:modify-hook:<hookGroupId>/<hookId>",
              "assume:hook-id:<hookGroupId>/<hookId>"
            ]
          },
          "stability": "stable",
          "title": "Update a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will remove a hook definition.",
          "method": "delete",
          "name": "removeHook",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>",
          "scopes": "hooks:modify-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Delete a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will trigger the creation of a task from a hook definition.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHook",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger",
          "scopes": "hooks:trigger-hook:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Trigger a hook",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "Retrieve a unique secret token for triggering the specified hook. This\ntoken can be deactivated with `resetTriggerToken`.",
          "method": "get",
          "name": "getTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:get-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Get a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "Reset the token for triggering a given hook. This invalidates token that\nmay have been issued via getTriggerToken with a new token.",
          "method": "post",
          "name": "resetTriggerToken",
          "output": "v1/trigger-token-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/token",
          "scopes": "hooks:reset-trigger-token:<hookGroupId>/<hookId>",
          "stability": "stable",
          "title": "Reset a trigger token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId",
            "token"
          ],
          "category": "Hooks Service",
          "description": "This endpoint triggers a defined hook with a valid token.\n\nThe HTTP payload must match the hooks `triggerSchema`.  If it does, it is\nprovided as the `payload` property of the JSON-e context used to render the\ntask template.",
          "input": "v1/trigger-hook.json#",
          "method": "post",
          "name": "triggerHookWithToken",
          "output": "v1/trigger-hook-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/trigger/<token>",
          "stability": "stable",
          "title": "Trigger a hook with a token",
          "type": "function"
        },
        {
          "args": [
            "hookGroupId",
            "hookId"
          ],
          "category": "Hooks Service",
          "description": "This endpoint will return information about the the last few times this hook has been\nfired, including whether the hook was fired successfully or not",
          "method": "get",
          "name": "listLastFires",
          "output": "v1/list-lastFires-response.json#",
          "query": [
          ],
          "route": "/hooks/<hookGroupId>/<hookId>/last-fires",
          "stability": "stable",
          "title": "Get information about recent hook fires",
          "type": "function"
        }
      ],
      "serviceName": "hooks",
      "title": "Hooks API Documentation"
    },
    "filename": "references/hooks/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "github",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/github/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service publishes a pulse\nmessage for supported github events, translating Github webhook\nevents into pulse messages.\n\nThis document describes the exchange offered by the taskcluster\ngithub service",
      "entries": [
        {
          "description": "When a GitHub pull request event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "pull-request",
          "name": "pullRequest",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "action",
              "required": true,
              "summary": "The GitHub `action` which triggered an event. See for possible values see the payload actions property."
            }
          ],
          "schema": "v1/github-pull-request-message.json#",
          "title": "GitHub Pull Request Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub push event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "push",
          "name": "push",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-push-message.json#",
          "title": "GitHub push Event",
          "type": "topic-exchange"
        },
        {
          "description": "When a GitHub release event is posted it will be broadcast on this\nexchange with the designated `organization` and `repository`\nin the routing-key along with event specific metadata in the payload.",
          "exchange": "release",
          "name": "release",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/github-release-message.json#",
          "title": "GitHub release Event",
          "type": "topic-exchange"
        },
        {
          "description": "supposed to signal that taskCreate API has been called for every task in the task group\nfor this particular repo and this particular organization\ncurrently used for creating initial status indicators in GitHub UI using Statuses API.\nThis particular exchange can also be bound to RabbitMQ queues by custom routes - for that,\nPass in the array of routes as a second argument to the publish method. Currently, we do\nuse the statuses routes to bind the handler that creates the initial status.",
          "exchange": "task-group-creation-requested",
          "name": "taskGroupCreationRequested",
          "routingKey": [
            {
              "constant": "primary",
              "multipleWords": false,
              "name": "routingKeyKind",
              "required": true,
              "summary": "Identifier for the routing-key kind. This is always `\"primary\"` for the formalized routing key."
            },
            {
              "multipleWords": false,
              "name": "organization",
              "required": true,
              "summary": "The GitHub `organization` which had an event. All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            },
            {
              "multipleWords": false,
              "name": "repository",
              "required": true,
              "summary": "The GitHub `repository` which had an event.All periods have been replaced by % - such that foo.bar becomes foo%bar - and all other special characters aside from - and _ have been stripped."
            }
          ],
          "schema": "v1/task-group-creation-requested.json#",
          "title": "tc-gh requested the Queue service to create all the tasks in a group",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-github/v1/",
      "serviceName": "github",
      "title": "Taskcluster-Github Exchanges"
    },
    "filename": "references/github/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The github service is responsible for creating tasks in reposnse\nto GitHub events, and posting results to the GitHub UI.\n\nThis document describes the API end-point for consuming GitHub\nweb hooks, as well as some useful consumer APIs.\n\nWhen Github forbids an action, this service returns an HTTP 403\nwith code ForbiddenByGithub.",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Github Service",
          "description": "Capture a GitHub event and publish it via pulse, if it's a push,\nrelease or pull request.",
          "method": "post",
          "name": "githubWebHookConsumer",
          "query": [
          ],
          "route": "/github",
          "stability": "stable",
          "title": "Consume GitHub WebHook",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Github Service",
          "description": "A paginated list of builds that have been run in\nTaskcluster. Can be filtered on various git-specific\nfields.",
          "method": "get",
          "name": "builds",
          "output": "v1/build-list.json#",
          "query": [
            "continuationToken",
            "limit",
            "organization",
            "repository",
            "sha"
          ],
          "route": "/builds",
          "stability": "stable",
          "title": "List of Builds",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "category": "Github Service",
          "description": "Checks the status of the latest build of a given branch\nand returns corresponding badge svg.",
          "method": "get",
          "name": "badge",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/badge.svg",
          "stability": "experimental",
          "title": "Latest Build Status Badge",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo"
          ],
          "category": "Github Service",
          "description": "Returns any repository metadata that is\nuseful within Taskcluster related services.",
          "method": "get",
          "name": "repository",
          "output": "v1/repository.json#",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>",
          "stability": "experimental",
          "title": "Get Repository Info",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "branch"
          ],
          "category": "Github Service",
          "description": "For a given branch of a repository, this will always point\nto a status page for the most recent task triggered by that\nbranch.\n\nNote: This is a redirect rather than a direct link.",
          "method": "get",
          "name": "latest",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/<branch>/latest",
          "stability": "stable",
          "title": "Latest Status for Branch",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "sha"
          ],
          "category": "Github Service",
          "description": "For a given changeset (SHA) of a repository, this will attach a \"commit status\"\non github. These statuses are links displayed next to each revision.\nThe status is either OK (green check) or FAILURE (red cross), \nmade of a custom title and link.",
          "input": "v1/create-status.json#",
          "method": "post",
          "name": "createStatus",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/statuses/<sha>",
          "scopes": "github:create-status:<owner>/<repo>",
          "stability": "experimental",
          "title": "Post a status against a given changeset",
          "type": "function"
        },
        {
          "args": [
            "owner",
            "repo",
            "number"
          ],
          "category": "Github Service",
          "description": "For a given Issue or Pull Request of a repository, this will write a new message.",
          "input": "v1/create-comment.json#",
          "method": "post",
          "name": "createComment",
          "query": [
          ],
          "route": "/repository/<owner>/<repo>/issues/<number>/comments",
          "scopes": "github:create-comment:<owner>/<repo>",
          "stability": "stable",
          "title": "Post a comment on a given GitHub Issue or Pull Request",
          "type": "function"
        }
      ],
      "serviceName": "github",
      "title": "Taskcluster GitHub API Documentation"
    },
    "filename": "references/github/v1/api.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "built-in-workers",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        }
      ]
    },
    "filename": "references/built-in-workers/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/logs-reference-v0.json#",
      "serviceName": "auth",
      "types": [
        {
          "description": "Status and duration of a periodic background process.",
          "fields": {
            "duration": "The duration in ms of the process.",
            "name": "The name of this process.",
            "status": "Either success, or exception depending on the outcome."
          },
          "level": "any",
          "name": "periodic",
          "title": "Periodic Process",
          "type": "monitor.periodic",
          "version": 1
        },
        {
          "description": "The most basic timer.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "basicTimer",
          "title": "Basic Timer",
          "type": "monitor.timer",
          "version": 1
        },
        {
          "description": "A basic timer applied to a function.",
          "fields": {
            "duration": "The duration in ms of the function.",
            "name": "The name of the handler.",
            "status": "Whether or not the handler resolved succesfully."
          },
          "level": "info",
          "name": "handlerTimer",
          "title": "Handler Timer",
          "type": "monitor.timedHandler",
          "version": 1
        },
        {
          "description": "A timer for calls to aws services.",
          "fields": {
            "duration": "How long it took to resolve the request in ms.",
            "operation": "The specific operation of this call.",
            "region": "The AWS region this service is in.",
            "service": "The name of the aws service being accessed."
          },
          "level": "info",
          "name": "awsTimer",
          "title": "AWS Request Report",
          "type": "monitor.aws",
          "version": 1
        },
        {
          "description": "Metrics of a node process.",
          "fields": {
            "lastCpuUsage": "The output of node's process.cpuUsage",
            "lastMemoryUsage": "The output of node's process.memoryUsage"
          },
          "level": "info",
          "name": "resourceMetrics",
          "title": "Resource Usage Metrics",
          "type": "monitor.resources",
          "version": 1
        },
        {
          "description": "A simple measurement. The reported values are expected to have statistics calculated over them.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be calculated over in a time span."
          },
          "level": "info",
          "name": "measureMetric",
          "title": "Generic Measure",
          "type": "monitor.measure",
          "version": 1
        },
        {
          "description": "A simple count. The reported values should be summed up in a time span.",
          "fields": {
            "key": "An arbitrary key.",
            "val": "A number that should be summed over a time span."
          },
          "level": "info",
          "name": "countMetric",
          "title": "Generic Count",
          "type": "monitor.count",
          "version": 1
        },
        {
          "description": "A specifically formatted error report. Will have at least the following but can contain more.",
          "fields": {
            "message": "Whatever message the error contained.",
            "name": "The name of the error.",
            "stack": "A nodejs stack trace."
          },
          "level": "any",
          "name": "errorReport",
          "title": "Error Report",
          "type": "monitor.error",
          "version": 1
        },
        {
          "description": "A simple timekeeper for measuring arbitrary time spans.",
          "fields": {
            "duration": "The duration in ms of whatever was timed.",
            "key": "A key that should be unique to the logger prefix."
          },
          "level": "info",
          "name": "timekeeper",
          "title": "TimeKeeper Report",
          "type": "monitor.timekeeper",
          "version": 1
        },
        {
          "description": "An internal type for logging simple messages. No required fields.",
          "fields": {
          },
          "level": "any",
          "name": "generic",
          "title": "Generic Message",
          "type": "monitor.generic",
          "version": 1
        },
        {
          "description": "An internal type for reporting malformed logging calls.",
          "fields": {
          },
          "level": "err",
          "name": "loggingError",
          "title": "Error in Logging",
          "type": "monitor.loggingError",
          "version": 1
        },
        {
          "description": "A timer and audit for express API endpoints.\nYou can combine this with auth audit logs to get\na complete picture of what was authorized when.\n\nHere, anything that is not public should have authenticated\nand if it authenticated, we will tell the clientId here. Given\nthat, it is not necessarily true that the endpoint was\n_authorized_. You can tell that by the statusCode.",
          "fields": {
            "apiVersion": "The version of the API (e.g., `v1`)",
            "clientId": "The clientId that made the request, if there was one.",
            "duration": "The duration in ms of the call.",
            "expires": "The expiration date of the credentials, if the header was authenticated.",
            "hasAuthed": "Will be true if the request had req.authorize() called on it.",
            "method": "The http method of the request.",
            "name": "The name of the API method",
            "public": "True if the endpoint requires no scopes.",
            "query": "Query params that were passed to the request (only ones that are specified as possible in the entry)",
            "resource": "The path of the http request.",
            "satisfyingScopes": "The set of scopes posessed by the caller that were\nused to authorize this request, or [] if scopes were not required.\n\nThis set of scopes is intuitively the scopes the caller used to\nauthorize the call.  More precisely, it is the minimal subset of the supplied\nscopes required to satisfy the API method's authorization requirements.\nBut is not quite minimal in one sense: If several alternatives of an\n`AnyOf` in the API method's scope ression are satisfied, then the\nscopes used to satisfy *all* such alternatives are included.",
            "sourceIp": "The API method caller's IP",
            "statusCode": "The http status code that the endpoint resolved with."
          },
          "level": "notice",
          "name": "apiMethod",
          "title": "API Method Report",
          "type": "monitor.apiMethod",
          "version": 1
        },
        {
          "description": "A connection to Pulse has been established.  Taskcluster services\nautomatically reconnect to Pulse periodically and in the event of\nan error, but rapid reconnections may signal a Pulse failure.",
          "fields": {
          },
          "level": "info",
          "name": "pulseConnected",
          "title": "Connection to pulse established",
          "type": "pulse.connected",
          "version": 1
        },
        {
          "description": "A connection to Pulse has ended or failed.  This may be due to normal\nreconnection or to an error communicating with Pulse.  The service\nautomatically reconnects, so even an error is not necessarily a problem.",
          "fields": {
            "error": "The error message, if the disconnection was due to an error."
          },
          "level": "info",
          "name": "pulseDisconnected",
          "title": "Connection to pulse has ended",
          "type": "pulse.disconnected",
          "version": 1
        },
        {
          "description": "A pulse publisher has been notified by the pulse server\nthat it has been blocked, usually because the server is\nresource-constrained.  If `blocked` is false, then the\nnotification is that the publisher has been unblocked\nafter having previously been blocked.",
          "fields": {
            "blocked": "If true, the publisher has been blocked; if false, it has been unblocked."
          },
          "level": "warning",
          "name": "pulsePublisherBlocked",
          "title": "Pulse server has (un)blocked a publisher",
          "type": "pulsePublisherBlocked",
          "version": 1
        }
      ]
    },
    "filename": "references/auth/v1/logs.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/exchanges-reference-v0.json#",
      "apiVersion": "v1",
      "description": "The auth service is responsible for storing credentials, managing\nassignment of scopes, and validation of request signatures from other\nservices.\n\nThese exchanges provides notifications when credentials or roles are\nupdated. This is mostly so that multiple instances of the auth service\ncan purge their caches and synchronize state. But you are of course\nwelcome to use these for other purposes, monitoring changes for example.",
      "entries": [
        {
          "description": "Message that a new client has been created.",
          "exchange": "client-created",
          "name": "clientCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been updated.",
          "exchange": "client-updated",
          "name": "clientUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new client has been deleted.",
          "exchange": "client-deleted",
          "name": "clientDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/client-message.json#",
          "title": "Client Deleted Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been created.",
          "exchange": "role-created",
          "name": "roleCreated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Created Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been updated.",
          "exchange": "role-updated",
          "name": "roleUpdated",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Updated Messages",
          "type": "topic-exchange"
        },
        {
          "description": "Message that a new role has been deleted.",
          "exchange": "role-deleted",
          "name": "roleDeleted",
          "routingKey": [
            {
              "multipleWords": true,
              "name": "reserved",
              "required": false,
              "summary": "Space reserved for future routing-key entries, you should always match this entry with `#`. As automatically done by our tooling, if not specified."
            }
          ],
          "schema": "v1/role-message.json#",
          "title": "Role Deleted Messages",
          "type": "topic-exchange"
        }
      ],
      "exchangePrefix": "exchange/taskcluster-auth/v1/",
      "serviceName": "auth",
      "title": "Auth Pulse Exchanges"
    },
    "filename": "references/auth/v1/exchanges.json"
  },
  {
    "content": {
      "$schema": "/schemas/common/api-reference-v0.json#",
      "apiVersion": "v1",
      "description": "Authentication related API end-points for Taskcluster and related\nservices. These API end-points are of interest if you wish to:\n  * Authorize a request signed with Taskcluster credentials,\n  * Manage clients and roles,\n  * Inspect or audit clients and roles,\n  * Gain access to various services guarded by this API.\n",
      "entries": [
        {
          "args": [
          ],
          "category": "Ping Server",
          "description": "Respond without doing anything.\nThis endpoint is used to check that the service is up.",
          "method": "get",
          "name": "ping",
          "query": [
          ],
          "route": "/ping",
          "stability": "stable",
          "title": "Ping Server",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Get a list of all clients.  With `prefix`, only clients for which\nit is a prefix of the clientId are returned.\n\nBy default this end-point will try to return up to 1000 clients in one\nrequest. But it **may return less, even none**.\nIt may also return a `continuationToken` even though there are no more\nresults. However, you can only be sure to have seen all results if you\nkeep calling `listClients` with the last `continuationToken` until you\nget a result without a `continuationToken`.",
          "method": "get",
          "name": "listClients",
          "output": "v1/list-clients-response.json#",
          "query": [
            "prefix",
            "continuationToken",
            "limit"
          ],
          "route": "/clients/",
          "stability": "stable",
          "title": "List Clients",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Get information about a single client.",
          "method": "get",
          "name": "client",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "stability": "stable",
          "title": "Get Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Create a new client and get the `accessToken` for this client.\nYou should store the `accessToken` from this API call as there is no\nother way to retrieve it.\n\nIf you loose the `accessToken` you can call `resetAccessToken` to reset\nit, and a new `accessToken` will be returned, but you cannot retrieve the\ncurrent `accessToken`.\n\nIf a client with the same `clientId` already exists this operation will\nfail. Use `updateClient` if you wish to update an existing client.\n\nThe caller's scopes must satisfy `scopes`.",
          "input": "v1/create-client-request.json#",
          "method": "put",
          "name": "createClient",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:create-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Reset a clients `accessToken`, this will revoke the existing\n`accessToken`, generate a new `accessToken` and return it from this\ncall.\n\nThere is no way to retrieve an existing `accessToken`, so if you loose it\nyou must reset the accessToken to acquire it again.",
          "method": "post",
          "name": "resetAccessToken",
          "output": "v1/create-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/reset",
          "scopes": "auth:reset-access-token:<clientId>",
          "stability": "stable",
          "title": "Reset `accessToken`",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Update an exisiting client. The `clientId` and `accessToken` cannot be\nupdated, but `scopes` can be modified.  The caller's scopes must\nsatisfy all scopes being added to the client in the update operation.\nIf no scopes are given in the request, the client's scopes remain\nunchanged",
          "input": "v1/create-client-request.json#",
          "method": "post",
          "name": "updateClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": {
            "AllOf": [
              "auth:update-client:<clientId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Enable a client that was disabled with `disableClient`.  If the client\nis already enabled, this does nothing.\n\nThis is typically used by identity providers to re-enable clients that\nhad been disabled when the corresponding identity's scopes changed.",
          "method": "post",
          "name": "enableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/enable",
          "scopes": "auth:enable-client:<clientId>",
          "stability": "stable",
          "title": "Enable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Disable a client.  If the client is already disabled, this does nothing.\n\nThis is typically used by identity providers to disable clients when the\ncorresponding identity's scopes no longer satisfy the client's scopes.",
          "method": "post",
          "name": "disableClient",
          "output": "v1/get-client-response.json#",
          "query": [
          ],
          "route": "/clients/<clientId>/disable",
          "scopes": "auth:disable-client:<clientId>",
          "stability": "stable",
          "title": "Disable Client",
          "type": "function"
        },
        {
          "args": [
            "clientId"
          ],
          "category": "Auth Service",
          "description": "Delete a client, please note that any roles related to this client must\nbe deleted independently.",
          "method": "delete",
          "name": "deleteClient",
          "query": [
          ],
          "route": "/clients/<clientId>",
          "scopes": "auth:delete-client:<clientId>",
          "stability": "stable",
          "title": "Delete Client",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This always returns all roles in a single HTTP\nrequest.\n\nTo get paginated results, use `listRoles2`.",
          "method": "get",
          "name": "listRoles",
          "output": "v1/list-roles-response.json#",
          "query": [
          ],
          "route": "/roles/",
          "stability": "stable",
          "title": "List Roles (no pagination)",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Get a list of all roles. Each role object also includes the list of\nscopes it expands to.  This is similar to `listRoles` but differs in the\nformat of the response.\n\nIf no limit is given, all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoles2",
          "output": "v1/list-roles2-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roles2/",
          "stability": "stable",
          "title": "List Roles",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Get a list of all role IDs.\n\nIf no limit is given, the roleIds of all roles are returned. Since this\nlist may become long, callers can use the `limit` and `continuationToken`\nquery arguments to page through the responses.",
          "method": "get",
          "name": "listRoleIds",
          "output": "v1/list-role-ids-response.json#",
          "query": [
            "continuationToken",
            "limit"
          ],
          "route": "/roleids/",
          "stability": "stable",
          "title": "List Role IDs",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Auth Service",
          "description": "Get information about a single role, including the set of scopes that the\nrole expands to.",
          "method": "get",
          "name": "role",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "stability": "stable",
          "title": "Get Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Auth Service",
          "description": "Create a new role.\n\nThe caller's scopes must satisfy the new role's scopes.\n\nIf there already exists a role with the same `roleId` this operation\nwill fail. Use `updateRole` to modify an existing role.\n\nCreation of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "put",
          "name": "createRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:create-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopes"
              }
            ]
          },
          "stability": "stable",
          "title": "Create Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Auth Service",
          "description": "Update an existing role.\n\nThe caller's scopes must satisfy all of the new scopes being added, but\nneed not satisfy all of the role's existing scopes.\n\nAn update of a role that will generate an infinite expansion will result\nin an error response.",
          "input": "v1/create-role-request.json#",
          "method": "post",
          "name": "updateRole",
          "output": "v1/get-role-response.json#",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": {
            "AllOf": [
              "auth:update-role:<roleId>",
              {
                "each": "<scope>",
                "for": "scope",
                "in": "scopesAdded"
              }
            ]
          },
          "stability": "stable",
          "title": "Update Role",
          "type": "function"
        },
        {
          "args": [
            "roleId"
          ],
          "category": "Auth Service",
          "description": "Delete a role. This operation will succeed regardless of whether or not\nthe role exists.",
          "method": "delete",
          "name": "deleteRole",
          "query": [
          ],
          "route": "/roles/<roleId>",
          "scopes": "auth:delete-role:<roleId>",
          "stability": "stable",
          "title": "Delete Role",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Return an expanded copy of the given scopeset, with scopes implied by any\nroles included.",
          "input": "v1/scopeset.json#",
          "method": "post",
          "name": "expandScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/expand",
          "stability": "stable",
          "title": "Expand Scopes",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Return the expanded scopes available in the request, taking into account all sources\nof scopes and scope restrictions (temporary credentials, assumeScopes, client scopes,\nand roles).",
          "method": "get",
          "name": "currentScopes",
          "output": "v1/scopeset.json#",
          "query": [
          ],
          "route": "/scopes/current",
          "stability": "stable",
          "title": "Get Current Scopes",
          "type": "function"
        },
        {
          "args": [
            "level",
            "bucket",
            "prefix"
          ],
          "category": "Auth Service",
          "description": "Get temporary AWS credentials for `read-write` or `read-only` access to\na given `bucket` and `prefix` within that bucket.\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned. Please note that the `level`\nparameter is required in the scope guarding access.  The bucket name must\nnot contain `.`, as recommended by Amazon.\n\nThis method can only allow access to a whitelisted set of buckets.  To add\na bucket to that whitelist, contact the Taskcluster team, who will add it to\nthe appropriate IAM policy.  If the bucket is in a different AWS account, you\nwill also need to add a bucket policy allowing access from the Taskcluster\naccount.  That policy should look like this:\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"allow-taskcluster-auth-to-delegate-access\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::692406183521:root\"\n      },\n      \"Action\": [\n        \"s3:ListBucket\",\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:DeleteObject\",\n        \"s3:GetBucketLocation\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::<bucket>\",\n        \"arn:aws:s3:::<bucket>/*\"\n      ]\n    }\n  ]\n}\n```\n\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.\n\nPlease note that your `prefix` may not start with slash `/`. Such a prefix\nis allowed on S3, but we forbid it here to discourage bad behavior.\n\nAlso note that if your `prefix` doesn't end in a slash `/`, the STS\ncredentials may allow access to unexpected keys, as S3 does not treat\nslashes specially.  For example, a prefix of `my-folder` will allow\naccess to `my-folder/file.txt` as expected, but also to `my-folder.txt`,\nwhich may not be intended.\n\nFinally, note that the `PutObjectAcl` call is not allowed.  Passing a canned\nACL other than `private` to `PutObject` is treated as a `PutObjectAcl` call, and\nwill result in an access-denied error from AWS.  This limitation is due to a\nsecurity flaw in Amazon S3 which might otherwise allow indefinite access to\nuploaded objects.\n\n**EC2 metadata compatibility**, if the querystring parameter\n`?format=iam-role-compat` is given, the response will be compatible\nwith the JSON exposed by the EC2 metadata service. This aims to ease\ncompatibility for libraries and tools built to auto-refresh credentials.\nFor details on the format returned by EC2 metadata service see:\n[EC2 User Guide](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#instance-metadata-security-credentials).",
          "method": "get",
          "name": "awsS3Credentials",
          "output": "v1/aws-s3-credentials-response.json#",
          "query": [
            "format"
          ],
          "route": "/aws/s3/<level>/<bucket>/<prefix>",
          "scopes": {
            "else": "auth:aws-s3:read-write:<bucket>/<prefix>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:aws-s3:read-only:<bucket>/<prefix>",
                "auth:aws-s3:read-write:<bucket>/<prefix>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Temporary Read/Write Credentials S3",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Retrieve a list of all Azure accounts managed by Taskcluster Auth.",
          "method": "get",
          "name": "azureAccounts",
          "output": "v1/azure-account-list-response.json#",
          "query": [
          ],
          "route": "/azure/accounts",
          "scopes": "auth:azure-table:list-accounts",
          "stability": "stable",
          "title": "List Accounts Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "category": "Auth Service",
          "description": "Retrieve a list of all tables in an account.",
          "method": "get",
          "name": "azureTables",
          "output": "v1/azure-table-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/tables",
          "scopes": "auth:azure-table:list-tables:<account>",
          "stability": "stable",
          "title": "List Tables in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "table",
            "level"
          ],
          "category": "Auth Service",
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nTable Storage table.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ntable if it doesn't already exist.",
          "method": "get",
          "name": "azureTableSAS",
          "output": "v1/azure-table-access-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/table/<table>/<level>",
          "scopes": {
            "else": "auth:azure-table:read-write:<account>/<table>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-table:read-only:<account>/<table>",
                "auth:azure-table:read-write:<account>/<table>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Shared-Access-Signature for Azure Table",
          "type": "function"
        },
        {
          "args": [
            "account"
          ],
          "category": "Auth Service",
          "description": "Retrieve a list of all containers in an account.",
          "method": "get",
          "name": "azureContainers",
          "output": "v1/azure-container-list-response.json#",
          "query": [
            "continuationToken"
          ],
          "route": "/azure/<account>/containers",
          "scopes": "auth:azure-container:list-containers:<account>",
          "stability": "stable",
          "title": "List containers in an Account Managed by Auth",
          "type": "function"
        },
        {
          "args": [
            "account",
            "container",
            "level"
          ],
          "category": "Auth Service",
          "description": "Get a shared access signature (SAS) string for use with a specific Azure\nBlob Storage container.\n\nThe `level` parameter can be `read-write` or `read-only` and determines\nwhich type of credentials are returned.  If level is read-write, it will create the\ncontainer if it doesn't already exist.",
          "method": "get",
          "name": "azureContainerSAS",
          "output": "v1/azure-container-response.json#",
          "query": [
          ],
          "route": "/azure/<account>/containers/<container>/<level>",
          "scopes": {
            "else": "auth:azure-container:read-write:<account>/<container>",
            "if": "levelIsReadOnly",
            "then": {
              "AnyOf": [
                "auth:azure-container:read-only:<account>/<container>",
                "auth:azure-container:read-write:<account>/<container>"
              ]
            }
          },
          "stability": "stable",
          "title": "Get Shared-Access-Signature for Azure Container",
          "type": "function"
        },
        {
          "args": [
            "project"
          ],
          "category": "Auth Service",
          "description": "Get temporary DSN (access credentials) for a sentry project.\nThe credentials returned can be used with any Sentry client for up to\n24 hours, after which the credentials will be automatically disabled.\n\nIf the project doesn't exist it will be created, and assigned to the\ninitial team configured for this component. Contact a Sentry admin\nto have the project transferred to a team you have access to if needed",
          "method": "get",
          "name": "sentryDSN",
          "output": "v1/sentry-dsn-response.json#",
          "query": [
          ],
          "route": "/sentry/<project>/dsn",
          "scopes": "auth:sentry:<project>",
          "stability": "deprecated",
          "title": "Get DSN for Sentry Project",
          "type": "function"
        },
        {
          "args": [
            "wstAudience",
            "wstClient"
          ],
          "category": "Auth Service",
          "description": "Get a temporary token suitable for use connecting to a\n[websocktunnel](https://github.com/taskcluster/websocktunnel) server.\n\nThe resulting token will only be accepted by servers with a matching audience\nvalue.  Reaching such a server is the callers responsibility.  In general,\na server URL or set of URLs should be provided to the caller as configuration\nalong with the audience value.\n\nThe token is valid for a limited time (on the scale of hours). Callers should\nrefresh it before expiration.",
          "method": "get",
          "name": "websocktunnelToken",
          "output": "v1/websocktunnel-token-response.json#",
          "query": [
          ],
          "route": "/websocktunnel/<wstAudience>/<wstClient>",
          "scopes": "auth:websocktunnel-token:<wstAudience>/<wstClient>",
          "stability": "stable",
          "title": "Get a client token for the Websocktunnel service",
          "type": "function"
        },
        {
          "args": [
            "projectId",
            "serviceAccount"
          ],
          "category": "Auth Service",
          "description": "Get temporary GCP credentials for the given serviceAccount in the given project.\n\nOnly preconfigured projects are allowed.  Any serviceAccount in that project may\nbe used.\n\nThe call adds the necessary policy if the serviceAccount doesn't have it.\nThe credentials are set to expire after an hour, but this behavior is\nsubject to change. Hence, you should always read the `expires` property\nfrom the response, if you intend to maintain active credentials in your\napplication.",
          "method": "get",
          "name": "gcpCredentials",
          "output": "v1/gcp-credentials-response.json#",
          "query": [
          ],
          "route": "/gcp/credentials/<projectId>/<serviceAccount>",
          "scopes": "auth:gcp:access-token:<projectId>/<serviceAccount>",
          "stability": "stable",
          "title": "Get Temporary GCP Credentials",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Validate the request signature given on input and return list of scopes\nthat the authenticating client has.\n\nThis method is used by other services that wish rely on Taskcluster\ncredentials for authentication. This way we can use Hawk without having\nthe secret credentials leave this service.",
          "input": "v1/authenticate-hawk-request.json#",
          "method": "post",
          "name": "authenticateHawk",
          "output": "v1/authenticate-hawk-response.json#",
          "query": [
          ],
          "route": "/authenticate-hawk",
          "stability": "stable",
          "title": "Authenticate Hawk Request",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Utility method to test client implementations of Taskcluster\nauthentication.\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\nbased on `clientScopes` in the request body.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked against `requiredScopes`\nfrom the request body. On success, the response contains the clientId\nand scopes as seen by the API method.",
          "input": "v1/test-authenticate-request.json#",
          "method": "post",
          "name": "testAuthenticate",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate",
          "stability": "stable",
          "title": "Test Authentication",
          "type": "function"
        },
        {
          "args": [
          ],
          "category": "Auth Service",
          "description": "Utility method similar to `testAuthenticate`, but with the GET method,\nso it can be used with signed URLs (bewits).\n\nRather than using real credentials, this endpoint accepts requests with\nclientId `tester` and accessToken `no-secret`. That client's scopes are\n`['test:*', 'auth:create-client:test:*']`.  The call fails if the \n`test:authenticate-get` scope is not available.\n\nThe request is validated, with any certificate, authorizedScopes, etc.\napplied, and the resulting scopes are checked, just like any API call.\nOn success, the response contains the clientId and scopes as seen by\nthe API method.\n\nThis method may later be extended to allow specification of client and\nrequired scopes via query arguments.",
          "method": "get",
          "name": "testAuthenticateGet",
          "output": "v1/test-authenticate-response.json#",
          "query": [
          ],
          "route": "/test-authenticate-get/",
          "stability": "stable",
          "title": "Test Authentication (GET)",
          "type": "function"
        }
      ],
      "serviceName": "auth",
      "title": "Authentication API"
    },
    "filename": "references/auth/v1/api.json"
  }
]