{
  "access": {
    "auth": {
      "tables": {
        "clients_entities": "write",
        "roles_entities": "write"
      }
    },
    "github": {
      "tables": {
        "taskcluster_check_runs_entities": "write",
        "taskcluster_checks_to_tasks_entities": "write",
        "taskcluster_github_builds_entities": "write",
        "taskcluster_integration_owners_entities": "write"
      }
    },
    "hooks": {
      "tables": {
        "hooks_entities": "write",
        "last_fire_3_entities": "write",
        "queues_entities": "write"
      }
    },
    "index": {
      "tables": {
        "indexed_tasks_entities": "write",
        "namespaces_entities": "write"
      }
    },
    "notify": {
      "tables": {
        "denylisted_notification_entities": "write",
        "widgets": "write"
      }
    },
    "purge_cache": {
      "tables": {
        "cache_purges": "write",
        "cache_purges_entities": "write"
      }
    },
    "queue": {
      "tables": {
        "azure_queue_messages": "write",
        "queue_artifacts_entities": "write",
        "queue_provisioner_entities": "write",
        "queue_task_dependency_entities": "write",
        "queue_task_group_active_sets_entities": "write",
        "queue_task_group_members_entities": "write",
        "queue_task_groups_entities": "write",
        "queue_task_requirement_entities": "write",
        "queue_tasks_entities": "write",
        "queue_worker_entities": "write",
        "queue_worker_type_entities": "write"
      }
    },
    "secrets": {
      "tables": {
        "secrets_entities": "write"
      }
    },
    "web_server": {
      "tables": {
        "access_token_table_entities": "write",
        "authorization_codes_table_entities": "write",
        "github_access_token_table_entities": "write",
        "session_storage_table_entities": "write"
      }
    },
    "worker_manager": {
      "tables": {
        "wmworker_pool_errors_entities": "write",
        "wmworker_pools_entities": "write",
        "wmworkers_entities": "write"
      }
    }
  },
  "tables": {
    "access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "authorization_codes_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "azure_queue_messages": {
      "expires": "timestamp with time zone not null",
      "inserted": "timestamp with time zone not null",
      "message_id": "uuid not null",
      "message_text": "text not null",
      "pop_receipt": "uuid",
      "queue_name": "text not null",
      "visible": "timestamp with time zone not null"
    },
    "cache_purges": {
      "before": "timestamp with time zone not null",
      "cache_name": "text not null",
      "etag": "uuid",
      "expires": "timestamp with time zone not null",
      "provisioner_id": "text not null",
      "worker_type": "text not null"
    },
    "cache_purges_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "clients_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "denylisted_notification_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "github_access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "hooks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "indexed_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "last_fire_3_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "namespaces_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_artifacts_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_provisioner_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_dependency_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_active_sets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_members_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_groups_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_requirement_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_type_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queues_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "roles_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "secrets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "session_storage_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_check_runs_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_checks_to_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_github_builds_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_integration_owners_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "widgets": {
      "name": "text"
    },
    "wmworker_pool_errors_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "wmworker_pools_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "wmworkers_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    }
  },
  "versions": [
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on widgets from $db_user_prefix$_notify;\n  drop table widgets;\nend",
      "methods": {
        "update_widgets": {
          "args": "name_in text",
          "body": "begin\n  insert into widgets (name) values (name_in);\n  return query select widgets.name from widgets;\nend",
          "deprecated": false,
          "description": "Temporary method to test infrastructure support fo database access",
          "mode": "write",
          "returns": "table (name text)",
          "serviceName": "notify"
        }
      },
      "migrationScript": "begin\n  create table widgets (\n    name text\n  );\n  grant select, insert, update, delete on widgets to $db_user_prefix$_notify;\nend",
      "version": 1
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on clients_entities from $db_user_prefix$_auth;\n  revoke select, insert, update, delete on roles_entities from $db_user_prefix$_auth;\n\n  revoke select, insert, update, delete on taskcluster_check_runs_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_checks_to_tasks_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_github_builds_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_integration_owners_entities from $db_user_prefix$_github;\n\n  revoke select, insert, update, delete on hooks_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on last_fire_3_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on queues_entities from $db_user_prefix$_hooks;\n\n  revoke select, insert, update, delete on indexed_tasks_entities from $db_user_prefix$_index;\n  revoke select, insert, update, delete on namespaces_entities from $db_user_prefix$_index;\n\n  revoke select, insert, update, delete on denylisted_notification_entities from $db_user_prefix$_notify;\n\n  revoke select, insert, update, delete on cache_purges_entities from $db_user_prefix$_purge_cache;\n\n  revoke select, insert, update, delete on secrets_entities from $db_user_prefix$_secrets;\n\n  revoke select, insert, update, delete on access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on authorization_codes_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on github_access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on session_storage_table_entities from $db_user_prefix$_web_server;\n\n  revoke select, insert, update, delete on wmworker_pool_errors_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworker_pools_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworkers_entities from $db_user_prefix$_worker_manager;\n\n  revoke select, insert, update, delete on queue_tasks_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_artifacts_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_groups_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_members_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_active_sets_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_requirement_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_dependency_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_type_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_provisioner_entities from $db_user_prefix$_queue;\n\n  drop table clients_entities;\n  drop table roles_entities;\n  drop table taskcluster_github_builds_entities;\n  drop table taskcluster_integration_owners_entities;\n  drop table taskcluster_checks_to_tasks_entities;\n  drop table taskcluster_check_runs_entities;\n  drop table hooks_entities;\n  drop table queues_entities;\n  drop table last_fire_3_entities;\n  drop table indexed_tasks_entities;\n  drop table namespaces_entities;\n  drop table denylisted_notification_entities;\n  drop table cache_purges_entities;\n  drop table queue_tasks_entities;\n  drop table queue_artifacts_entities;\n  drop table queue_task_groups_entities;\n  drop table queue_task_group_members_entities;\n  drop table queue_task_group_active_sets_entities;\n  drop table queue_task_requirement_entities;\n  drop table queue_task_dependency_entities;\n  drop table queue_worker_entities;\n  drop table queue_worker_type_entities;\n  drop table queue_provisioner_entities;\n  drop table secrets_entities;\n  drop table authorization_codes_table_entities;\n  drop table access_token_table_entities;\n  drop table session_storage_table_entities;\n  drop table github_access_token_table_entities;\n  drop table wmworkers_entities;\n  drop table wmworker_pools_entities;\n  drop table wmworker_pool_errors_entities;\nend",
      "methods": {
        "access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, access_token_table_entities_create.version, new_etag)\n    where access_token_table_entities.partition_key = access_token_table_entities_create.pk and access_token_table_entities.row_key = access_token_table_entities_create.rk;\n  else\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version,\n  access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_load.partition_key and access_token_table_entities.row_key = access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update access_token_table_entities\n  set (value, version, etag) = (properties, access_token_table_entities_modify.version, new_etag)\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key and access_token_table_entities.etag = access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_remove.partition_key and access_token_table_entities.row_key = access_token_table_entities_remove.row_key\n  returning access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, authorization_codes_table_entities_create.version, new_etag)\n    where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_create.pk and authorization_codes_table_entities.row_key = authorization_codes_table_entities_create.rk;\n  else\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version,\n  authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_load.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update authorization_codes_table_entities\n  set (value, version, etag) = (properties, authorization_codes_table_entities_modify.version, new_etag)\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key and authorization_codes_table_entities.etag = authorization_codes_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_remove.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_remove.row_key\n  returning authorization_codes_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, cache_purges_entities_create.version, new_etag)\n    where cache_purges_entities.partition_key = cache_purges_entities_create.pk and cache_purges_entities.row_key = cache_purges_entities_create.rk;\n  else\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version,\n  cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_load.partition_key and cache_purges_entities.row_key = cache_purges_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update cache_purges_entities\n  set (value, version, etag) = (properties, cache_purges_entities_modify.version, new_etag)\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key and cache_purges_entities.etag = cache_purges_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_remove.partition_key and cache_purges_entities.row_key = cache_purges_entities_remove.row_key\n  returning cache_purges_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, clients_entities_create.version, new_etag)\n    where clients_entities.partition_key = clients_entities_create.pk and clients_entities.row_key = clients_entities_create.rk;\n  else\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "clients_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version,\n  clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_load.partition_key and clients_entities.row_key = clients_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update clients_entities\n  set (value, version, etag) = (properties, clients_entities_modify.version, new_etag)\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key and clients_entities.etag = clients_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from clients_entities\n  where clients_entities.partition_key = clients_entities_remove.partition_key and clients_entities.row_key = clients_entities_remove.row_key\n  returning clients_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, denylisted_notification_entities_create.version, new_etag)\n    where denylisted_notification_entities.partition_key = denylisted_notification_entities_create.pk and denylisted_notification_entities.row_key = denylisted_notification_entities_create.rk;\n  else\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version,\n  denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_load.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update denylisted_notification_entities\n  set (value, version, etag) = (properties, denylisted_notification_entities_modify.version, new_etag)\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key and denylisted_notification_entities.etag = denylisted_notification_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_remove.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_remove.row_key\n  returning denylisted_notification_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, github_access_token_table_entities_create.version, new_etag)\n    where github_access_token_table_entities.partition_key = github_access_token_table_entities_create.pk and github_access_token_table_entities.row_key = github_access_token_table_entities_create.rk;\n  else\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version,\n  github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_load.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update github_access_token_table_entities\n  set (value, version, etag) = (properties, github_access_token_table_entities_modify.version, new_etag)\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key and github_access_token_table_entities.etag = github_access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_remove.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_remove.row_key\n  returning github_access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, hooks_entities_create.version, new_etag)\n    where hooks_entities.partition_key = hooks_entities_create.pk and hooks_entities.row_key = hooks_entities_create.rk;\n  else\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "hooks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version,\n  hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_load.partition_key and hooks_entities.row_key = hooks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update hooks_entities\n  set (value, version, etag) = (properties, hooks_entities_modify.version, new_etag)\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key and hooks_entities.etag = hooks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_remove.partition_key and hooks_entities.row_key = hooks_entities_remove.row_key\n  returning hooks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, indexed_tasks_entities_create.version, new_etag)\n    where indexed_tasks_entities.partition_key = indexed_tasks_entities_create.pk and indexed_tasks_entities.row_key = indexed_tasks_entities_create.rk;\n  else\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "indexed_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version,\n  indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_load.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update indexed_tasks_entities\n  set (value, version, etag) = (properties, indexed_tasks_entities_modify.version, new_etag)\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key and indexed_tasks_entities.etag = indexed_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_remove.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_remove.row_key\n  returning indexed_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, last_fire_3_entities_create.version, new_etag)\n    where last_fire_3_entities.partition_key = last_fire_3_entities_create.pk and last_fire_3_entities.row_key = last_fire_3_entities_create.rk;\n  else\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version,\n  last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_load.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update last_fire_3_entities\n  set (value, version, etag) = (properties, last_fire_3_entities_modify.version, new_etag)\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key and last_fire_3_entities.etag = last_fire_3_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_remove.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_remove.row_key\n  returning last_fire_3_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, namespaces_entities_create.version, new_etag)\n    where namespaces_entities.partition_key = namespaces_entities_create.pk and namespaces_entities.row_key = namespaces_entities_create.rk;\n  else\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "namespaces_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version,\n  namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_load.partition_key and namespaces_entities.row_key = namespaces_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update namespaces_entities\n  set (value, version, etag) = (properties, namespaces_entities_modify.version, new_etag)\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key and namespaces_entities.etag = namespaces_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_remove.partition_key and namespaces_entities.row_key = namespaces_entities_remove.row_key\n  returning namespaces_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_artifacts_entities_create.version, new_etag)\n    where queue_artifacts_entities.partition_key = queue_artifacts_entities_create.pk and queue_artifacts_entities.row_key = queue_artifacts_entities_create.rk;\n  else\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version,\n  queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_load.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_artifacts_entities\n  set (value, version, etag) = (properties, queue_artifacts_entities_modify.version, new_etag)\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key and queue_artifacts_entities.etag = queue_artifacts_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_remove.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_remove.row_key\n  returning queue_artifacts_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_provisioner_entities_create.version, new_etag)\n    where queue_provisioner_entities.partition_key = queue_provisioner_entities_create.pk and queue_provisioner_entities.row_key = queue_provisioner_entities_create.rk;\n  else\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version,\n  queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_load.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_provisioner_entities\n  set (value, version, etag) = (properties, queue_provisioner_entities_modify.version, new_etag)\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key and queue_provisioner_entities.etag = queue_provisioner_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_remove.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_remove.row_key\n  returning queue_provisioner_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_dependency_entities_create.version, new_etag)\n    where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_create.pk and queue_task_dependency_entities.row_key = queue_task_dependency_entities_create.rk;\n  else\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version,\n  queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_load.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_dependency_entities\n  set (value, version, etag) = (properties, queue_task_dependency_entities_modify.version, new_etag)\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key and queue_task_dependency_entities.etag = queue_task_dependency_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_remove.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_remove.row_key\n  returning queue_task_dependency_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_active_sets_entities_create.version, new_etag)\n    where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_create.pk and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_create.rk;\n  else\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version,\n  queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_load.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_active_sets_entities\n  set (value, version, etag) = (properties, queue_task_group_active_sets_entities_modify.version, new_etag)\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key and queue_task_group_active_sets_entities.etag = queue_task_group_active_sets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_remove.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_remove.row_key\n  returning queue_task_group_active_sets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_members_entities_create.version, new_etag)\n    where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_create.pk and queue_task_group_members_entities.row_key = queue_task_group_members_entities_create.rk;\n  else\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version,\n  queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_load.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_members_entities\n  set (value, version, etag) = (properties, queue_task_group_members_entities_modify.version, new_etag)\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key and queue_task_group_members_entities.etag = queue_task_group_members_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_remove.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_remove.row_key\n  returning queue_task_group_members_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_groups_entities_create.version, new_etag)\n    where queue_task_groups_entities.partition_key = queue_task_groups_entities_create.pk and queue_task_groups_entities.row_key = queue_task_groups_entities_create.rk;\n  else\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version,\n  queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_load.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_groups_entities\n  set (value, version, etag) = (properties, queue_task_groups_entities_modify.version, new_etag)\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key and queue_task_groups_entities.etag = queue_task_groups_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_remove.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_remove.row_key\n  returning queue_task_groups_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_requirement_entities_create.version, new_etag)\n    where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_create.pk and queue_task_requirement_entities.row_key = queue_task_requirement_entities_create.rk;\n  else\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version,\n  queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_load.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_requirement_entities\n  set (value, version, etag) = (properties, queue_task_requirement_entities_modify.version, new_etag)\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key and queue_task_requirement_entities.etag = queue_task_requirement_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_remove.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_remove.row_key\n  returning queue_task_requirement_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_tasks_entities_create.version, new_etag)\n    where queue_tasks_entities.partition_key = queue_tasks_entities_create.pk and queue_tasks_entities.row_key = queue_tasks_entities_create.rk;\n  else\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version,\n  queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_load.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_tasks_entities\n  set (value, version, etag) = (properties, queue_tasks_entities_modify.version, new_etag)\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key and queue_tasks_entities.etag = queue_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_remove.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_remove.row_key\n  returning queue_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_entities_create.version, new_etag)\n    where queue_worker_entities.partition_key = queue_worker_entities_create.pk and queue_worker_entities.row_key = queue_worker_entities_create.rk;\n  else\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version,\n  queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_load.partition_key and queue_worker_entities.row_key = queue_worker_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_entities\n  set (value, version, etag) = (properties, queue_worker_entities_modify.version, new_etag)\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key and queue_worker_entities.etag = queue_worker_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_remove.partition_key and queue_worker_entities.row_key = queue_worker_entities_remove.row_key\n  returning queue_worker_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_type_entities_create.version, new_etag)\n    where queue_worker_type_entities.partition_key = queue_worker_type_entities_create.pk and queue_worker_type_entities.row_key = queue_worker_type_entities_create.rk;\n  else\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version,\n  queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_load.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_type_entities\n  set (value, version, etag) = (properties, queue_worker_type_entities_modify.version, new_etag)\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key and queue_worker_type_entities.etag = queue_worker_type_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_remove.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_remove.row_key\n  returning queue_worker_type_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queues_entities_create.version, new_etag)\n    where queues_entities.partition_key = queues_entities_create.pk and queues_entities.row_key = queues_entities_create.rk;\n  else\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "queues_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version,\n  queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_load.partition_key and queues_entities.row_key = queues_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queues_entities\n  set (value, version, etag) = (properties, queues_entities_modify.version, new_etag)\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key and queues_entities.etag = queues_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queues_entities\n  where queues_entities.partition_key = queues_entities_remove.partition_key and queues_entities.row_key = queues_entities_remove.row_key\n  returning queues_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, roles_entities_create.version, new_etag)\n    where roles_entities.partition_key = roles_entities_create.pk and roles_entities.row_key = roles_entities_create.rk;\n  else\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "roles_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version,\n  roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_load.partition_key and roles_entities.row_key = roles_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update roles_entities\n  set (value, version, etag) = (properties, roles_entities_modify.version, new_etag)\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key and roles_entities.etag = roles_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from roles_entities\n  where roles_entities.partition_key = roles_entities_remove.partition_key and roles_entities.row_key = roles_entities_remove.row_key\n  returning roles_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, secrets_entities_create.version, new_etag)\n    where secrets_entities.partition_key = secrets_entities_create.pk and secrets_entities.row_key = secrets_entities_create.rk;\n  else\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "secrets"
        },
        "secrets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version,\n  secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_load.partition_key and secrets_entities.row_key = secrets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update secrets_entities\n  set (value, version, etag) = (properties, secrets_entities_modify.version, new_etag)\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key and secrets_entities.etag = secrets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_remove.partition_key and secrets_entities.row_key = secrets_entities_remove.row_key\n  returning secrets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, session_storage_table_entities_create.version, new_etag)\n    where session_storage_table_entities.partition_key = session_storage_table_entities_create.pk and session_storage_table_entities.row_key = session_storage_table_entities_create.rk;\n  else\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version,\n  session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_load.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update session_storage_table_entities\n  set (value, version, etag) = (properties, session_storage_table_entities_modify.version, new_etag)\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key and session_storage_table_entities.etag = session_storage_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_remove.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_remove.row_key\n  returning session_storage_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_check_runs_entities_create.version, new_etag)\n    where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_create.pk and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_create.rk;\n  else\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version,\n  taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_load.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_check_runs_entities\n  set (value, version, etag) = (properties, taskcluster_check_runs_entities_modify.version, new_etag)\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key and taskcluster_check_runs_entities.etag = taskcluster_check_runs_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_remove.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_remove.row_key\n  returning taskcluster_check_runs_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_create.version, new_etag)\n    where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_create.pk and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_create.rk;\n  else\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version,\n  taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_load.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_checks_to_tasks_entities\n  set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_modify.version, new_etag)\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key and taskcluster_checks_to_tasks_entities.etag = taskcluster_checks_to_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_remove.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_remove.row_key\n  returning taskcluster_checks_to_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_github_builds_entities_create.version, new_etag)\n    where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_create.pk and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_create.rk;\n  else\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version,\n  taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_load.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_github_builds_entities\n  set (value, version, etag) = (properties, taskcluster_github_builds_entities_modify.version, new_etag)\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key and taskcluster_github_builds_entities.etag = taskcluster_github_builds_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_remove.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_remove.row_key\n  returning taskcluster_github_builds_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_integration_owners_entities_create.version, new_etag)\n    where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_create.pk and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_create.rk;\n  else\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version,\n  taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_load.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_integration_owners_entities\n  set (value, version, etag) = (properties, taskcluster_integration_owners_entities_modify.version, new_etag)\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key and taskcluster_integration_owners_entities.etag = taskcluster_integration_owners_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_remove.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_remove.row_key\n  returning taskcluster_integration_owners_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pool_errors_entities_create.version, new_etag)\n    where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_create.pk and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_create.rk;\n  else\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version,\n  wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_load.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pool_errors_entities\n  set (value, version, etag) = (properties, wmworker_pool_errors_entities_modify.version, new_etag)\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key and wmworker_pool_errors_entities.etag = wmworker_pool_errors_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_remove.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_remove.row_key\n  returning wmworker_pool_errors_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pools_entities_create.version, new_etag)\n    where wmworker_pools_entities.partition_key = wmworker_pools_entities_create.pk and wmworker_pools_entities.row_key = wmworker_pools_entities_create.rk;\n  else\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version,\n  wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_load.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pools_entities\n  set (value, version, etag) = (properties, wmworker_pools_entities_modify.version, new_etag)\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key and wmworker_pools_entities.etag = wmworker_pools_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_remove.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_remove.row_key\n  returning wmworker_pools_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworkers_entities_create.version, new_etag)\n    where wmworkers_entities.partition_key = wmworkers_entities_create.pk and wmworkers_entities.row_key = wmworkers_entities_create.rk;\n  else\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version,\n  wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_load.partition_key and wmworkers_entities.row_key = wmworkers_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworkers_entities\n  set (value, version, etag) = (properties, wmworkers_entities_modify.version, new_etag)\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key and wmworkers_entities.etag = wmworkers_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_remove.partition_key and wmworkers_entities.row_key = wmworkers_entities_remove.row_key\n  returning wmworkers_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  create table clients_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table clients_entities add primary key (partition_key, row_key);\n\n  create table roles_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table roles_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_github_builds_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_github_builds_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_integration_owners_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_integration_owners_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_checks_to_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_checks_to_tasks_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_check_runs_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_check_runs_entities add primary key (partition_key, row_key);\n\n  create table hooks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table hooks_entities add primary key (partition_key, row_key);\n\n  create table queues_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queues_entities add primary key (partition_key, row_key);\n\n  create table last_fire_3_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table last_fire_3_entities add primary key (partition_key, row_key);\n\n  create table indexed_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table indexed_tasks_entities add primary key (partition_key, row_key);\n\n  create table namespaces_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table namespaces_entities add primary key (partition_key, row_key);\n\n  create table denylisted_notification_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table denylisted_notification_entities add primary key (partition_key, row_key);\n\n  create table cache_purges_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table cache_purges_entities add primary key (partition_key, row_key);\n\n  create table queue_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_tasks_entities add primary key (partition_key, row_key);\n\n  create table queue_artifacts_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_artifacts_entities add primary key (partition_key, row_key);\n\n  create table queue_task_groups_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_groups_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_members_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_members_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_active_sets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_active_sets_entities add primary key (partition_key, row_key);\n\n  create table queue_task_requirement_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_requirement_entities add primary key (partition_key, row_key);\n\n  create table queue_task_dependency_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_dependency_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_type_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_type_entities add primary key (partition_key, row_key);\n\n  create table queue_provisioner_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_provisioner_entities add primary key (partition_key, row_key);\n\n  create table secrets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table secrets_entities add primary key (partition_key, row_key);\n\n  create table authorization_codes_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table authorization_codes_table_entities add primary key (partition_key, row_key);\n\n  create table access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table access_token_table_entities add primary key (partition_key, row_key);\n\n  create table session_storage_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table session_storage_table_entities add primary key (partition_key, row_key);\n\n  create table github_access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table github_access_token_table_entities add primary key (partition_key, row_key);\n\n  create table wmworkers_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworkers_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pools_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pools_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pool_errors_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pool_errors_entities add primary key (partition_key, row_key);\n\n  grant select, insert, update, delete on clients_entities to $db_user_prefix$_auth;\n  grant select, insert, update, delete on roles_entities to $db_user_prefix$_auth;\n\n  grant select, insert, update, delete on taskcluster_check_runs_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_checks_to_tasks_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_github_builds_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_integration_owners_entities to $db_user_prefix$_github;\n\n  grant select, insert, update, delete on hooks_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on last_fire_3_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on queues_entities to $db_user_prefix$_hooks;\n\n  grant select, insert, update, delete on indexed_tasks_entities to $db_user_prefix$_index;\n  grant select, insert, update, delete on namespaces_entities to $db_user_prefix$_index;\n\n  grant select, insert, update, delete on denylisted_notification_entities to $db_user_prefix$_notify;\n\n  grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge_cache;\n\n  grant select, insert, update, delete on secrets_entities to $db_user_prefix$_secrets;\n\n  grant select, insert, update, delete on access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on authorization_codes_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on github_access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on session_storage_table_entities to $db_user_prefix$_web_server;\n\n  grant select, insert, update, delete on wmworker_pool_errors_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworker_pools_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworkers_entities to $db_user_prefix$_worker_manager;\n\n  grant select, insert, update, delete on queue_tasks_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_artifacts_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_groups_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_members_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_active_sets_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_requirement_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_dependency_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_type_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_provisioner_entities to $db_user_prefix$_queue;\nend",
      "version": 2
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on azure_queue_messages from $db_user_prefix$_queue;\n  drop table azure_queue_messages;\nend",
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (select count(*)\n  from azure_queue_messages msgs\n  where msgs.queue_name = azure_queue_count.queue_name);\nend",
          "deprecated": false,
          "description": "Count messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        },
        "azure_queue_delete": {
          "args": "queue_name text, message_id uuid, pop_receipt uuid",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.queue_name = azure_queue_delete.queue_name\n      and msgs.message_id = azure_queue_delete.message_id\n      and msgs.pop_receipt = azure_queue_delete.pop_receipt;\nend",
          "deprecated": false,
          "description": "Delete the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_delete_expired": {
          "args": "",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.expires <= now();\nend",
          "deprecated": false,
          "description": "Delete all expired messages.  This is a maintenance task that should occur\nabout once an hour.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query update azure_queue_messages m1\n    set\n      pop_receipt = public.gen_random_uuid(),\n      visible = azure_queue_get.visible\n    where\n      m1.message_id in (\n        select m2.message_id from azure_queue_messages m2\n        where m2.queue_name = azure_queue_get.queue_name\n          and m2.visible <= now()\n          and m2.expires > now()\n        order by m2.inserted\n        for update skip locked\n        limit count\n    )\n    returning m1.message_id, m1.message_text, m1.pop_receipt;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        },
        "azure_queue_put": {
          "args": "queue_name text, message_text text, visible timestamp, expires timestamp",
          "body": "begin\n  insert into azure_queue_messages (\n      queue_name,\n      message_id,\n      message_text,\n      inserted,\n      visible,\n      expires\n    ) values (\n      azure_queue_put.queue_name,\n      public.gen_random_uuid(),\n      azure_queue_put.message_text,\n      now(),\n      azure_queue_put.visible,\n      azure_queue_put.expires\n    );\n  execute 'notify ' || quote_ident(queue_name);\nend",
          "deprecated": false,
          "description": "Put the given message into the given queue.  The message will not be visible until\nafter the visible timestamp, and will disappear after the expires timestamp.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_update": {
          "args": "queue_name text, message_text text, message_id uuid, pop_receipt uuid, visible timestamp",
          "body": "begin\n  update azure_queue_messages msgs\n    set message_text = azure_queue_update.message_text,\n      visible = azure_queue_update.visible\n    where msgs.queue_name = azure_queue_update.queue_name\n      and msgs.message_id = azure_queue_update.message_id\n      and msgs.pop_receipt = azure_queue_update.pop_receipt;\nend",
          "deprecated": false,
          "description": "Update the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`, setting its `visible` and `message_text` properties as\ngiven.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        }
      },
      "migrationScript": "begin\n  create table azure_queue_messages (\n    message_id uuid not null primary key,\n    queue_name text not null,\n    message_text text not null,\n    inserted timestamp not null,\n    visible timestamp not null, -- visible after this time\n    expires timestamp not null,  -- expired after this time\n    pop_receipt uuid -- null means not popped\n  );\n  -- 'get' operations sort by inserted within a queue\n  create index azure_queue_messages_inserted on azure_queue_messages(queue_name, inserted);\n  grant select, insert, update, delete on azure_queue_messages to $db_user_prefix$_queue;\nend",
      "version": 3
    },
    {
      "downgradeScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamp,\n    alter column visible type timestamp,\n    alter column expires type timestamp;\nend",
      "methods": {
      },
      "migrationScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamptz,\n    alter column visible type timestamptz,\n    alter column expires type timestamptz;\nend",
      "version": 4
    },
    {
      "downgradeScript": "begin\nend",
      "methods": {
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query\n    with updated as (\n      update azure_queue_messages m\n      set\n        pop_receipt = public.gen_random_uuid(),\n        visible = azure_queue_get.visible\n      where\n        m.message_id in (\n          select m2.message_id from azure_queue_messages m2\n          where m2.queue_name = azure_queue_get.queue_name\n            and m2.visible <= now()\n            and m2.expires > now()\n          order by m2.inserted\n          for update skip locked\n          limit count\n      )\n      returning m.inserted, m.message_id, m.message_text, m.pop_receipt\n    )\n    select\n      u.message_id, u.message_text, u.pop_receipt\n    from updated as u\n    order by u.inserted;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        }
      },
      "migrationScript": "begin\nend",
      "version": 5
    },
    {
      "downgradeScript": "begin\nend",
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (\n    select\n      count(*)\n    from\n      azure_queue_messages msgs\n    where\n      msgs.queue_name = azure_queue_count.queue_name\n      and msgs.expires > now()\n  );\nend",
          "deprecated": false,
          "description": "Count non-expired messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        }
      },
      "migrationScript": "begin\nend",
      "version": 6
    },
    {
      "downgradeScript": "begin\nend",
      "methods": {
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\nend",
      "version": 7
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on cache_purges from $db_user_prefix$_purge_cache;\n  drop table cache_purges;\nend",
      "methods": {
        "all_purge_requests": {
          "args": "size integer, page_offset integer",
          "body": "declare\nsql text := 'select cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name, cache_purges.before from cache_purges';\n\nbegin\n  sql := sql || ' order by cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page_offset is not null and page_offset > 0 then\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "View all active purge requests.\n\nThis is useful mostly for administors to view\nthe set of open purge requests. It should not\nbe used by workers. They should use the purgeRequests\nendpoint that is specific to their workerType and\nprovisionerId.\n\nNote: This endpoint supports pagination. The limit will always be size + 1 to allow consumers to detect\nwhen it's the last page. If the list of result > size then there are more entries to fetch.\nElse, there are no next pages.",
          "mode": "read",
          "returns": "table (provisioner_id text, worker_type text, cache_name text, before timestamptz)",
          "serviceName": "purge_cache"
        },
        "cache_purges_expires": {
          "args": "exp_in timestamptz",
          "body": "declare\n  count integer;\nbegin\n  delete from cache_purges where cache_purges.expires < exp_in;\n\n  if found then\n    get diagnostics count = row_count;\n    return count;\n  end if;\n\n  return 0;\nend",
          "deprecated": false,
          "description": "Expire cachePurges that are past their expiration.\n\nReturns a promise that all expired cachePurges have been deleted.",
          "mode": "write",
          "returns": "integer",
          "serviceName": "purge_cache"
        },
        "cache_purges_to_remove": {
          "args": "provisioner_id_in text, worker_type_in text, since_in timestamptz",
          "body": "begin\n  return query\n  select cache_purges.provisioner_id, cache_purges.worker_type, cache_purges.cache_name, cache_purges.before from cache_purges\n  where cache_purges.provisioner_id = cache_purges_to_remove.provisioner_id_in and cache_purges.worker_type = cache_purges_to_remove.worker_type_in and cache_purges.before > cache_purges_to_remove.since_in;\nend",
          "deprecated": false,
          "description": "List the caches for this `provisionerId`/`workerType` that should be\npurged if they are from before the time given in the response.\n\nThis is intended to be used by workers to determine which caches to purge.",
          "mode": "read",
          "returns": "table (provisioner_id text, worker_type text, cache_name text, before timestamptz)",
          "serviceName": "purge_cache"
        },
        "purge_cache": {
          "args": "prov_id text, wt text, c_name text, bef timestamptz, exp timestamptz",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  insert into cache_purges(provisioner_id, worker_type, cache_name, before, expires, etag)\n  values (\n    prov_id,\n    wt,\n    c_name,\n    bef,\n    exp,\n    new_etag\n  ) on conflict (provisioner_id, worker_type, cache_name) do\n  update\n  set (before, expires, etag) = (now(), exp, new_etag)\n  where cache_purges.provisioner_id = purge_cache.prov_id and cache_purges.worker_type = purge_cache.wt and cache_purges.cache_name = purge_cache.c_name;\nend",
          "deprecated": false,
          "description": "Publish a request to purge caches named `cacheName` with\non `provisionerId`/`workerType` workers.\n\nIf such a request already exists, its `before` timestamp is updated to\nthe current time.",
          "mode": "write",
          "returns": "void",
          "serviceName": "purge_cache"
        }
      },
      "migrationScript": "begin\n  create table cache_purges (\n    provisioner_id text not null,\n    worker_type text not null,\n    cache_name text not null,\n    before timestamptz not null,\n    expires timestamptz not null,\n    etag uuid default public.gen_random_uuid(),\n    PRIMARY KEY(provisioner_id, worker_type, cache_name)\n  );\n  grant select, insert, update, delete on cache_purges to $db_user_prefix$_purge_cache;\nend",
      "version": 8
    }
  ]
}