{
  "access": {
    "auth": {
      "tables": {
        "clients_entities": "write",
        "roles_entities": "write"
      }
    },
    "github": {
      "tables": {
        "taskcluster_check_runs_entities": "write",
        "taskcluster_checks_to_tasks_entities": "write",
        "taskcluster_github_builds_entities": "write",
        "taskcluster_integration_owners_entities": "write"
      }
    },
    "hooks": {
      "tables": {
        "hooks_entities": "write",
        "last_fire_3_entities": "write",
        "queues_entities": "write"
      }
    },
    "index": {
      "tables": {
        "indexed_tasks_entities": "write",
        "namespaces_entities": "write"
      }
    },
    "notify": {
      "tables": {
        "denylisted_notification_entities": "write",
        "widgets": "write"
      }
    },
    "purge_cache": {
      "tables": {
        "cache_purges_entities": "write"
      }
    },
    "queue": {
      "tables": {
        "azure_queue_messages": "write",
        "queue_artifacts_entities": "write",
        "queue_provisioner_entities": "write",
        "queue_task_dependency_entities": "write",
        "queue_task_group_active_sets_entities": "write",
        "queue_task_group_members_entities": "write",
        "queue_task_groups_entities": "write",
        "queue_task_requirement_entities": "write",
        "queue_tasks_entities": "write",
        "queue_worker_entities": "write",
        "queue_worker_type_entities": "write"
      }
    },
    "secrets": {
      "tables": {
        "secrets_entities": "write"
      }
    },
    "web_server": {
      "tables": {
        "access_token_table_entities": "write",
        "authorization_codes_table_entities": "write",
        "github_access_token_table_entities": "write",
        "session_storage_table_entities": "write"
      }
    },
    "worker_manager": {
      "tables": {
        "wmworker_pool_errors_entities": "write",
        "wmworker_pools_entities": "write",
        "wmworkers_entities": "write"
      }
    }
  },
  "tables": {
    "access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "authorization_codes_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "azure_queue_messages": {
      "expires": "timestamp with time zone not null",
      "inserted": "timestamp with time zone not null",
      "message_id": "uuid not null",
      "message_text": "text not null",
      "pop_receipt": "uuid",
      "queue_name": "text not null",
      "visible": "timestamp with time zone not null"
    },
    "cache_purges_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "clients_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "denylisted_notification_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "github_access_token_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "hooks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "indexed_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "last_fire_3_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "namespaces_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_artifacts_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_provisioner_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_dependency_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_active_sets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_group_members_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_groups_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_task_requirement_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queue_worker_type_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "queues_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "roles_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "secrets_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "session_storage_table_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_check_runs_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_checks_to_tasks_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_github_builds_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "taskcluster_integration_owners_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "widgets": {
      "name": "text"
    },
    "wmworker_pool_errors_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "wmworker_pools_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    },
    "wmworkers_entities": {
      "etag": "uuid",
      "partition_key": "text not null",
      "row_key": "text not null",
      "value": "jsonb not null",
      "version": "integer not null"
    }
  },
  "versions": [
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on widgets from $db_user_prefix$_notify;\n  drop table widgets;\nend",
      "methods": {
        "update_widgets": {
          "args": "name_in text",
          "body": "begin\n  insert into widgets (name) values (name_in);\n  return query select widgets.name from widgets;\nend",
          "deprecated": false,
          "description": "Temporary method to test infrastructure support fo database access",
          "mode": "write",
          "returns": "table (name text)",
          "serviceName": "notify"
        }
      },
      "migrationScript": "begin\n  create table widgets (\n    name text\n  );\n  grant select, insert, update, delete on widgets to $db_user_prefix$_notify;\nend",
      "version": 1
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on clients_entities from $db_user_prefix$_auth;\n  revoke select, insert, update, delete on roles_entities from $db_user_prefix$_auth;\n\n  revoke select, insert, update, delete on taskcluster_check_runs_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_checks_to_tasks_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_github_builds_entities from $db_user_prefix$_github;\n  revoke select, insert, update, delete on taskcluster_integration_owners_entities from $db_user_prefix$_github;\n\n  revoke select, insert, update, delete on hooks_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on last_fire_3_entities from $db_user_prefix$_hooks;\n  revoke select, insert, update, delete on queues_entities from $db_user_prefix$_hooks;\n\n  revoke select, insert, update, delete on indexed_tasks_entities from $db_user_prefix$_index;\n  revoke select, insert, update, delete on namespaces_entities from $db_user_prefix$_index;\n\n  revoke select, insert, update, delete on denylisted_notification_entities from $db_user_prefix$_notify;\n\n  revoke select, insert, update, delete on cache_purges_entities from $db_user_prefix$_purge_cache;\n\n  revoke select, insert, update, delete on secrets_entities from $db_user_prefix$_secrets;\n\n  revoke select, insert, update, delete on access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on authorization_codes_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on github_access_token_table_entities from $db_user_prefix$_web_server;\n  revoke select, insert, update, delete on session_storage_table_entities from $db_user_prefix$_web_server;\n\n  revoke select, insert, update, delete on wmworker_pool_errors_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworker_pools_entities from $db_user_prefix$_worker_manager;\n  revoke select, insert, update, delete on wmworkers_entities from $db_user_prefix$_worker_manager;\n\n  revoke select, insert, update, delete on queue_tasks_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_artifacts_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_groups_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_members_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_group_active_sets_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_requirement_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_task_dependency_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_worker_type_entities from $db_user_prefix$_queue;\n  revoke select, insert, update, delete on queue_provisioner_entities from $db_user_prefix$_queue;\n\n  drop table clients_entities;\n  drop table roles_entities;\n  drop table taskcluster_github_builds_entities;\n  drop table taskcluster_integration_owners_entities;\n  drop table taskcluster_checks_to_tasks_entities;\n  drop table taskcluster_check_runs_entities;\n  drop table hooks_entities;\n  drop table queues_entities;\n  drop table last_fire_3_entities;\n  drop table indexed_tasks_entities;\n  drop table namespaces_entities;\n  drop table denylisted_notification_entities;\n  drop table cache_purges_entities;\n  drop table queue_tasks_entities;\n  drop table queue_artifacts_entities;\n  drop table queue_task_groups_entities;\n  drop table queue_task_group_members_entities;\n  drop table queue_task_group_active_sets_entities;\n  drop table queue_task_requirement_entities;\n  drop table queue_task_dependency_entities;\n  drop table queue_worker_entities;\n  drop table queue_worker_type_entities;\n  drop table queue_provisioner_entities;\n  drop table secrets_entities;\n  drop table authorization_codes_table_entities;\n  drop table access_token_table_entities;\n  drop table session_storage_table_entities;\n  drop table github_access_token_table_entities;\n  drop table wmworkers_entities;\n  drop table wmworker_pools_entities;\n  drop table wmworker_pool_errors_entities;\nend",
      "methods": {
        "access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, access_token_table_entities_create.version, new_etag)\n    where access_token_table_entities.partition_key = access_token_table_entities_create.pk and access_token_table_entities.row_key = access_token_table_entities_create.rk;\n  else\n    insert into access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version,\n  access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_load.partition_key and access_token_table_entities.row_key = access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update access_token_table_entities\n  set (value, version, etag) = (properties, access_token_table_entities_modify.version, new_etag)\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key and access_token_table_entities.etag = access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform access_token_table_entities.etag from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_modify.partition_key and access_token_table_entities.row_key = access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from access_token_table_entities\n  where access_token_table_entities.partition_key = access_token_table_entities_remove.partition_key and access_token_table_entities.row_key = access_token_table_entities_remove.row_key\n  returning access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, authorization_codes_table_entities_create.version, new_etag)\n    where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_create.pk and authorization_codes_table_entities.row_key = authorization_codes_table_entities_create.rk;\n  else\n    insert into authorization_codes_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version,\n  authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_load.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update authorization_codes_table_entities\n  set (value, version, etag) = (properties, authorization_codes_table_entities_modify.version, new_etag)\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key and authorization_codes_table_entities.etag = authorization_codes_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform authorization_codes_table_entities.etag from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_modify.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from authorization_codes_table_entities\n  where authorization_codes_table_entities.partition_key = authorization_codes_table_entities_remove.partition_key and authorization_codes_table_entities.row_key = authorization_codes_table_entities_remove.row_key\n  returning authorization_codes_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, cache_purges_entities_create.version, new_etag)\n    where cache_purges_entities.partition_key = cache_purges_entities_create.pk and cache_purges_entities.row_key = cache_purges_entities_create.rk;\n  else\n    insert into cache_purges_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version,\n  cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_load.partition_key and cache_purges_entities.row_key = cache_purges_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update cache_purges_entities\n  set (value, version, etag) = (properties, cache_purges_entities_modify.version, new_etag)\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key and cache_purges_entities.etag = cache_purges_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform cache_purges_entities.etag from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_modify.partition_key and cache_purges_entities.row_key = cache_purges_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from cache_purges_entities\n  where cache_purges_entities.partition_key = cache_purges_entities_remove.partition_key and cache_purges_entities.row_key = cache_purges_entities_remove.row_key\n  returning cache_purges_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "purge_cache"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, clients_entities_create.version, new_etag)\n    where clients_entities.partition_key = clients_entities_create.pk and clients_entities.row_key = clients_entities_create.rk;\n  else\n    insert into clients_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "clients_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version,\n  clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_load.partition_key and clients_entities.row_key = clients_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update clients_entities\n  set (value, version, etag) = (properties, clients_entities_modify.version, new_etag)\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key and clients_entities.etag = clients_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform clients_entities.etag from clients_entities\n  where clients_entities.partition_key = clients_entities_modify.partition_key and clients_entities.row_key = clients_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from clients_entities\n  where clients_entities.partition_key = clients_entities_remove.partition_key and clients_entities.row_key = clients_entities_remove.row_key\n  returning clients_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, denylisted_notification_entities_create.version, new_etag)\n    where denylisted_notification_entities.partition_key = denylisted_notification_entities_create.pk and denylisted_notification_entities.row_key = denylisted_notification_entities_create.rk;\n  else\n    insert into denylisted_notification_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version,\n  denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_load.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update denylisted_notification_entities\n  set (value, version, etag) = (properties, denylisted_notification_entities_modify.version, new_etag)\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key and denylisted_notification_entities.etag = denylisted_notification_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform denylisted_notification_entities.etag from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_modify.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from denylisted_notification_entities\n  where denylisted_notification_entities.partition_key = denylisted_notification_entities_remove.partition_key and denylisted_notification_entities.row_key = denylisted_notification_entities_remove.row_key\n  returning denylisted_notification_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "notify"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, github_access_token_table_entities_create.version, new_etag)\n    where github_access_token_table_entities.partition_key = github_access_token_table_entities_create.pk and github_access_token_table_entities.row_key = github_access_token_table_entities_create.rk;\n  else\n    insert into github_access_token_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version,\n  github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_load.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update github_access_token_table_entities\n  set (value, version, etag) = (properties, github_access_token_table_entities_modify.version, new_etag)\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key and github_access_token_table_entities.etag = github_access_token_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform github_access_token_table_entities.etag from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_modify.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from github_access_token_table_entities\n  where github_access_token_table_entities.partition_key = github_access_token_table_entities_remove.partition_key and github_access_token_table_entities.row_key = github_access_token_table_entities_remove.row_key\n  returning github_access_token_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, hooks_entities_create.version, new_etag)\n    where hooks_entities.partition_key = hooks_entities_create.pk and hooks_entities.row_key = hooks_entities_create.rk;\n  else\n    insert into hooks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "hooks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version,\n  hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_load.partition_key and hooks_entities.row_key = hooks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update hooks_entities\n  set (value, version, etag) = (properties, hooks_entities_modify.version, new_etag)\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key and hooks_entities.etag = hooks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform hooks_entities.etag from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_modify.partition_key and hooks_entities.row_key = hooks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from hooks_entities\n  where hooks_entities.partition_key = hooks_entities_remove.partition_key and hooks_entities.row_key = hooks_entities_remove.row_key\n  returning hooks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, indexed_tasks_entities_create.version, new_etag)\n    where indexed_tasks_entities.partition_key = indexed_tasks_entities_create.pk and indexed_tasks_entities.row_key = indexed_tasks_entities_create.rk;\n  else\n    insert into indexed_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "indexed_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version,\n  indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_load.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update indexed_tasks_entities\n  set (value, version, etag) = (properties, indexed_tasks_entities_modify.version, new_etag)\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key and indexed_tasks_entities.etag = indexed_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform indexed_tasks_entities.etag from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_modify.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from indexed_tasks_entities\n  where indexed_tasks_entities.partition_key = indexed_tasks_entities_remove.partition_key and indexed_tasks_entities.row_key = indexed_tasks_entities_remove.row_key\n  returning indexed_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, last_fire_3_entities_create.version, new_etag)\n    where last_fire_3_entities.partition_key = last_fire_3_entities_create.pk and last_fire_3_entities.row_key = last_fire_3_entities_create.rk;\n  else\n    insert into last_fire_3_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version,\n  last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_load.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update last_fire_3_entities\n  set (value, version, etag) = (properties, last_fire_3_entities_modify.version, new_etag)\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key and last_fire_3_entities.etag = last_fire_3_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform last_fire_3_entities.etag from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_modify.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from last_fire_3_entities\n  where last_fire_3_entities.partition_key = last_fire_3_entities_remove.partition_key and last_fire_3_entities.row_key = last_fire_3_entities_remove.row_key\n  returning last_fire_3_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, namespaces_entities_create.version, new_etag)\n    where namespaces_entities.partition_key = namespaces_entities_create.pk and namespaces_entities.row_key = namespaces_entities_create.rk;\n  else\n    insert into namespaces_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "index"
        },
        "namespaces_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version,\n  namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_load.partition_key and namespaces_entities.row_key = namespaces_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update namespaces_entities\n  set (value, version, etag) = (properties, namespaces_entities_modify.version, new_etag)\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key and namespaces_entities.etag = namespaces_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform namespaces_entities.etag from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_modify.partition_key and namespaces_entities.row_key = namespaces_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from namespaces_entities\n  where namespaces_entities.partition_key = namespaces_entities_remove.partition_key and namespaces_entities.row_key = namespaces_entities_remove.row_key\n  returning namespaces_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "index"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_artifacts_entities_create.version, new_etag)\n    where queue_artifacts_entities.partition_key = queue_artifacts_entities_create.pk and queue_artifacts_entities.row_key = queue_artifacts_entities_create.rk;\n  else\n    insert into queue_artifacts_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version,\n  queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_load.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_artifacts_entities\n  set (value, version, etag) = (properties, queue_artifacts_entities_modify.version, new_etag)\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key and queue_artifacts_entities.etag = queue_artifacts_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_artifacts_entities.etag from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_modify.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_artifacts_entities\n  where queue_artifacts_entities.partition_key = queue_artifacts_entities_remove.partition_key and queue_artifacts_entities.row_key = queue_artifacts_entities_remove.row_key\n  returning queue_artifacts_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_provisioner_entities_create.version, new_etag)\n    where queue_provisioner_entities.partition_key = queue_provisioner_entities_create.pk and queue_provisioner_entities.row_key = queue_provisioner_entities_create.rk;\n  else\n    insert into queue_provisioner_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version,\n  queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_load.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_provisioner_entities\n  set (value, version, etag) = (properties, queue_provisioner_entities_modify.version, new_etag)\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key and queue_provisioner_entities.etag = queue_provisioner_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_provisioner_entities.etag from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_modify.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_provisioner_entities\n  where queue_provisioner_entities.partition_key = queue_provisioner_entities_remove.partition_key and queue_provisioner_entities.row_key = queue_provisioner_entities_remove.row_key\n  returning queue_provisioner_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_dependency_entities_create.version, new_etag)\n    where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_create.pk and queue_task_dependency_entities.row_key = queue_task_dependency_entities_create.rk;\n  else\n    insert into queue_task_dependency_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version,\n  queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_load.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_dependency_entities\n  set (value, version, etag) = (properties, queue_task_dependency_entities_modify.version, new_etag)\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key and queue_task_dependency_entities.etag = queue_task_dependency_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_dependency_entities.etag from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_modify.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_dependency_entities\n  where queue_task_dependency_entities.partition_key = queue_task_dependency_entities_remove.partition_key and queue_task_dependency_entities.row_key = queue_task_dependency_entities_remove.row_key\n  returning queue_task_dependency_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_active_sets_entities_create.version, new_etag)\n    where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_create.pk and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_create.rk;\n  else\n    insert into queue_task_group_active_sets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version,\n  queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_load.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_active_sets_entities\n  set (value, version, etag) = (properties, queue_task_group_active_sets_entities_modify.version, new_etag)\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key and queue_task_group_active_sets_entities.etag = queue_task_group_active_sets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_modify.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_active_sets_entities\n  where queue_task_group_active_sets_entities.partition_key = queue_task_group_active_sets_entities_remove.partition_key and queue_task_group_active_sets_entities.row_key = queue_task_group_active_sets_entities_remove.row_key\n  returning queue_task_group_active_sets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_group_members_entities_create.version, new_etag)\n    where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_create.pk and queue_task_group_members_entities.row_key = queue_task_group_members_entities_create.rk;\n  else\n    insert into queue_task_group_members_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version,\n  queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_load.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_group_members_entities\n  set (value, version, etag) = (properties, queue_task_group_members_entities_modify.version, new_etag)\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key and queue_task_group_members_entities.etag = queue_task_group_members_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_group_members_entities.etag from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_modify.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_group_members_entities\n  where queue_task_group_members_entities.partition_key = queue_task_group_members_entities_remove.partition_key and queue_task_group_members_entities.row_key = queue_task_group_members_entities_remove.row_key\n  returning queue_task_group_members_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_groups_entities_create.version, new_etag)\n    where queue_task_groups_entities.partition_key = queue_task_groups_entities_create.pk and queue_task_groups_entities.row_key = queue_task_groups_entities_create.rk;\n  else\n    insert into queue_task_groups_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version,\n  queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_load.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_groups_entities\n  set (value, version, etag) = (properties, queue_task_groups_entities_modify.version, new_etag)\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key and queue_task_groups_entities.etag = queue_task_groups_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_groups_entities.etag from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_modify.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_groups_entities\n  where queue_task_groups_entities.partition_key = queue_task_groups_entities_remove.partition_key and queue_task_groups_entities.row_key = queue_task_groups_entities_remove.row_key\n  returning queue_task_groups_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_task_requirement_entities_create.version, new_etag)\n    where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_create.pk and queue_task_requirement_entities.row_key = queue_task_requirement_entities_create.rk;\n  else\n    insert into queue_task_requirement_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version,\n  queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_load.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_task_requirement_entities\n  set (value, version, etag) = (properties, queue_task_requirement_entities_modify.version, new_etag)\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key and queue_task_requirement_entities.etag = queue_task_requirement_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_task_requirement_entities.etag from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_modify.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_task_requirement_entities\n  where queue_task_requirement_entities.partition_key = queue_task_requirement_entities_remove.partition_key and queue_task_requirement_entities.row_key = queue_task_requirement_entities_remove.row_key\n  returning queue_task_requirement_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_tasks_entities_create.version, new_etag)\n    where queue_tasks_entities.partition_key = queue_tasks_entities_create.pk and queue_tasks_entities.row_key = queue_tasks_entities_create.rk;\n  else\n    insert into queue_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version,\n  queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_load.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_tasks_entities\n  set (value, version, etag) = (properties, queue_tasks_entities_modify.version, new_etag)\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key and queue_tasks_entities.etag = queue_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_tasks_entities.etag from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_modify.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_tasks_entities\n  where queue_tasks_entities.partition_key = queue_tasks_entities_remove.partition_key and queue_tasks_entities.row_key = queue_tasks_entities_remove.row_key\n  returning queue_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_entities_create.version, new_etag)\n    where queue_worker_entities.partition_key = queue_worker_entities_create.pk and queue_worker_entities.row_key = queue_worker_entities_create.rk;\n  else\n    insert into queue_worker_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version,\n  queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_load.partition_key and queue_worker_entities.row_key = queue_worker_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_entities\n  set (value, version, etag) = (properties, queue_worker_entities_modify.version, new_etag)\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key and queue_worker_entities.etag = queue_worker_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_entities.etag from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_modify.partition_key and queue_worker_entities.row_key = queue_worker_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_entities\n  where queue_worker_entities.partition_key = queue_worker_entities_remove.partition_key and queue_worker_entities.row_key = queue_worker_entities_remove.row_key\n  returning queue_worker_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queue_worker_type_entities_create.version, new_etag)\n    where queue_worker_type_entities.partition_key = queue_worker_type_entities_create.pk and queue_worker_type_entities.row_key = queue_worker_type_entities_create.rk;\n  else\n    insert into queue_worker_type_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version,\n  queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_load.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queue_worker_type_entities\n  set (value, version, etag) = (properties, queue_worker_type_entities_modify.version, new_etag)\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key and queue_worker_type_entities.etag = queue_worker_type_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queue_worker_type_entities.etag from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_modify.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queue_worker_type_entities\n  where queue_worker_type_entities.partition_key = queue_worker_type_entities_remove.partition_key and queue_worker_type_entities.row_key = queue_worker_type_entities_remove.row_key\n  returning queue_worker_type_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, queues_entities_create.version, new_etag)\n    where queues_entities.partition_key = queues_entities_create.pk and queues_entities.row_key = queues_entities_create.rk;\n  else\n    insert into queues_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "hooks"
        },
        "queues_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version,\n  queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_load.partition_key and queues_entities.row_key = queues_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update queues_entities\n  set (value, version, etag) = (properties, queues_entities_modify.version, new_etag)\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key and queues_entities.etag = queues_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform queues_entities.etag from queues_entities\n  where queues_entities.partition_key = queues_entities_modify.partition_key and queues_entities.row_key = queues_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from queues_entities\n  where queues_entities.partition_key = queues_entities_remove.partition_key and queues_entities.row_key = queues_entities_remove.row_key\n  returning queues_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "hooks"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, roles_entities_create.version, new_etag)\n    where roles_entities.partition_key = roles_entities_create.pk and roles_entities.row_key = roles_entities_create.rk;\n  else\n    insert into roles_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "auth"
        },
        "roles_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version,\n  roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_load.partition_key and roles_entities.row_key = roles_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update roles_entities\n  set (value, version, etag) = (properties, roles_entities_modify.version, new_etag)\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key and roles_entities.etag = roles_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform roles_entities.etag from roles_entities\n  where roles_entities.partition_key = roles_entities_modify.partition_key and roles_entities.row_key = roles_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from roles_entities\n  where roles_entities.partition_key = roles_entities_remove.partition_key and roles_entities.row_key = roles_entities_remove.row_key\n  returning roles_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "auth"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, secrets_entities_create.version, new_etag)\n    where secrets_entities.partition_key = secrets_entities_create.pk and secrets_entities.row_key = secrets_entities_create.rk;\n  else\n    insert into secrets_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "secrets"
        },
        "secrets_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version,\n  secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_load.partition_key and secrets_entities.row_key = secrets_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update secrets_entities\n  set (value, version, etag) = (properties, secrets_entities_modify.version, new_etag)\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key and secrets_entities.etag = secrets_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform secrets_entities.etag from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_modify.partition_key and secrets_entities.row_key = secrets_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from secrets_entities\n  where secrets_entities.partition_key = secrets_entities_remove.partition_key and secrets_entities.row_key = secrets_entities_remove.row_key\n  returning secrets_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "secrets"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, session_storage_table_entities_create.version, new_etag)\n    where session_storage_table_entities.partition_key = session_storage_table_entities_create.pk and session_storage_table_entities.row_key = session_storage_table_entities_create.rk;\n  else\n    insert into session_storage_table_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version,\n  session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_load.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update session_storage_table_entities\n  set (value, version, etag) = (properties, session_storage_table_entities_modify.version, new_etag)\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key and session_storage_table_entities.etag = session_storage_table_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform session_storage_table_entities.etag from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_modify.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from session_storage_table_entities\n  where session_storage_table_entities.partition_key = session_storage_table_entities_remove.partition_key and session_storage_table_entities.row_key = session_storage_table_entities_remove.row_key\n  returning session_storage_table_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "web_server"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_check_runs_entities_create.version, new_etag)\n    where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_create.pk and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_create.rk;\n  else\n    insert into taskcluster_check_runs_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version,\n  taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_load.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_check_runs_entities\n  set (value, version, etag) = (properties, taskcluster_check_runs_entities_modify.version, new_etag)\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key and taskcluster_check_runs_entities.etag = taskcluster_check_runs_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_modify.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_check_runs_entities\n  where taskcluster_check_runs_entities.partition_key = taskcluster_check_runs_entities_remove.partition_key and taskcluster_check_runs_entities.row_key = taskcluster_check_runs_entities_remove.row_key\n  returning taskcluster_check_runs_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_create.version, new_etag)\n    where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_create.pk and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_create.rk;\n  else\n    insert into taskcluster_checks_to_tasks_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version,\n  taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_load.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_checks_to_tasks_entities\n  set (value, version, etag) = (properties, taskcluster_checks_to_tasks_entities_modify.version, new_etag)\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key and taskcluster_checks_to_tasks_entities.etag = taskcluster_checks_to_tasks_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_modify.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_checks_to_tasks_entities\n  where taskcluster_checks_to_tasks_entities.partition_key = taskcluster_checks_to_tasks_entities_remove.partition_key and taskcluster_checks_to_tasks_entities.row_key = taskcluster_checks_to_tasks_entities_remove.row_key\n  returning taskcluster_checks_to_tasks_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_github_builds_entities_create.version, new_etag)\n    where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_create.pk and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_create.rk;\n  else\n    insert into taskcluster_github_builds_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version,\n  taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_load.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_github_builds_entities\n  set (value, version, etag) = (properties, taskcluster_github_builds_entities_modify.version, new_etag)\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key and taskcluster_github_builds_entities.etag = taskcluster_github_builds_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_modify.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_github_builds_entities\n  where taskcluster_github_builds_entities.partition_key = taskcluster_github_builds_entities_remove.partition_key and taskcluster_github_builds_entities.row_key = taskcluster_github_builds_entities_remove.row_key\n  returning taskcluster_github_builds_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, taskcluster_integration_owners_entities_create.version, new_etag)\n    where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_create.pk and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_create.rk;\n  else\n    insert into taskcluster_integration_owners_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version,\n  taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_load.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update taskcluster_integration_owners_entities\n  set (value, version, etag) = (properties, taskcluster_integration_owners_entities_modify.version, new_etag)\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key and taskcluster_integration_owners_entities.etag = taskcluster_integration_owners_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_modify.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from taskcluster_integration_owners_entities\n  where taskcluster_integration_owners_entities.partition_key = taskcluster_integration_owners_entities_remove.partition_key and taskcluster_integration_owners_entities.row_key = taskcluster_integration_owners_entities_remove.row_key\n  returning taskcluster_integration_owners_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pool_errors_entities_create.version, new_etag)\n    where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_create.pk and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_create.rk;\n  else\n    insert into wmworker_pool_errors_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version,\n  wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_load.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pool_errors_entities\n  set (value, version, etag) = (properties, wmworker_pool_errors_entities_modify.version, new_etag)\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key and wmworker_pool_errors_entities.etag = wmworker_pool_errors_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_modify.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pool_errors_entities\n  where wmworker_pool_errors_entities.partition_key = wmworker_pool_errors_entities_remove.partition_key and wmworker_pool_errors_entities.row_key = wmworker_pool_errors_entities_remove.row_key\n  returning wmworker_pool_errors_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworker_pools_entities_create.version, new_etag)\n    where wmworker_pools_entities.partition_key = wmworker_pools_entities_create.pk and wmworker_pools_entities.row_key = wmworker_pools_entities_create.rk;\n  else\n    insert into wmworker_pools_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version,\n  wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_load.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworker_pools_entities\n  set (value, version, etag) = (properties, wmworker_pools_entities_modify.version, new_etag)\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key and wmworker_pools_entities.etag = wmworker_pools_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworker_pools_entities.etag from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_modify.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworker_pools_entities\n  where wmworker_pools_entities.partition_key = wmworker_pools_entities_remove.partition_key and wmworker_pools_entities.row_key = wmworker_pools_entities_remove.row_key\n  returning wmworker_pools_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_create": {
          "args": "pk text, rk text, properties jsonb, overwrite boolean, version integer",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  if overwrite then\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    ) on conflict (partition_key, row_key) do\n    update\n    set (value, version, etag) = (properties, wmworkers_entities_create.version, new_etag)\n    where wmworkers_entities.partition_key = wmworkers_entities_create.pk and wmworkers_entities.row_key = wmworkers_entities_create.rk;\n  else\n    insert into wmworkers_entities(partition_key, row_key, value, version, etag)\n    values (\n      pk,\n      rk,\n      properties,\n      version,\n      new_etag\n    );\n  end if;\n  return new_etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "uuid",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_load": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query\n  select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version,\n  wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_load.partition_key and wmworkers_entities.row_key = wmworkers_entities_load.row_key;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key_out text, row_key_out text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_modify": {
          "args": "partition_key text, row_key text, properties jsonb, version integer, old_etag uuid",
          "body": "declare\n  new_etag uuid := public.gen_random_uuid();\nbegin\n  update wmworkers_entities\n  set (value, version, etag) = (properties, wmworkers_entities_modify.version, new_etag)\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key and wmworkers_entities.etag = wmworkers_entities_modify.old_etag;\n\n  if found then\n    return query select new_etag;\n    return;\n  end if;\n\n  perform wmworkers_entities.etag from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_modify.partition_key and wmworkers_entities.row_key = wmworkers_entities_modify.row_key;\n\n  if found then\n    raise exception 'unsuccessful update' using errcode = 'P0004';\n  else\n    raise exception 'no such row' using errcode = 'P0002';\n  end if;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_remove": {
          "args": "partition_key text, row_key text",
          "body": "begin\n  return query delete from wmworkers_entities\n  where wmworkers_entities.partition_key = wmworkers_entities_remove.partition_key and wmworkers_entities.row_key = wmworkers_entities_remove.row_key\n  returning wmworkers_entities.etag;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "write",
          "returns": "table (etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\n  page_offset integer;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      page_offset := size * (page - 1);\n      sql := sql || ' offset ' || page_offset;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "migrationScript": "begin\n  create table clients_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table clients_entities add primary key (partition_key, row_key);\n\n  create table roles_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table roles_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_github_builds_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_github_builds_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_integration_owners_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_integration_owners_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_checks_to_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_checks_to_tasks_entities add primary key (partition_key, row_key);\n\n  create table taskcluster_check_runs_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table taskcluster_check_runs_entities add primary key (partition_key, row_key);\n\n  create table hooks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table hooks_entities add primary key (partition_key, row_key);\n\n  create table queues_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queues_entities add primary key (partition_key, row_key);\n\n  create table last_fire_3_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table last_fire_3_entities add primary key (partition_key, row_key);\n\n  create table indexed_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table indexed_tasks_entities add primary key (partition_key, row_key);\n\n  create table namespaces_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table namespaces_entities add primary key (partition_key, row_key);\n\n  create table denylisted_notification_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table denylisted_notification_entities add primary key (partition_key, row_key);\n\n  create table cache_purges_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table cache_purges_entities add primary key (partition_key, row_key);\n\n  create table queue_tasks_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_tasks_entities add primary key (partition_key, row_key);\n\n  create table queue_artifacts_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_artifacts_entities add primary key (partition_key, row_key);\n\n  create table queue_task_groups_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_groups_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_members_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_members_entities add primary key (partition_key, row_key);\n\n  create table queue_task_group_active_sets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_group_active_sets_entities add primary key (partition_key, row_key);\n\n  create table queue_task_requirement_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_requirement_entities add primary key (partition_key, row_key);\n\n  create table queue_task_dependency_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_task_dependency_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_entities add primary key (partition_key, row_key);\n\n  create table queue_worker_type_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_worker_type_entities add primary key (partition_key, row_key);\n\n  create table queue_provisioner_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table queue_provisioner_entities add primary key (partition_key, row_key);\n\n  create table secrets_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table secrets_entities add primary key (partition_key, row_key);\n\n  create table authorization_codes_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table authorization_codes_table_entities add primary key (partition_key, row_key);\n\n  create table access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table access_token_table_entities add primary key (partition_key, row_key);\n\n  create table session_storage_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table session_storage_table_entities add primary key (partition_key, row_key);\n\n  create table github_access_token_table_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table github_access_token_table_entities add primary key (partition_key, row_key);\n\n  create table wmworkers_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworkers_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pools_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pools_entities add primary key (partition_key, row_key);\n\n  create table wmworker_pool_errors_entities(partition_key text, row_key text, value jsonb not null, version integer not null, etag uuid default public.gen_random_uuid());\n  alter table wmworker_pool_errors_entities add primary key (partition_key, row_key);\n\n  grant select, insert, update, delete on clients_entities to $db_user_prefix$_auth;\n  grant select, insert, update, delete on roles_entities to $db_user_prefix$_auth;\n\n  grant select, insert, update, delete on taskcluster_check_runs_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_checks_to_tasks_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_github_builds_entities to $db_user_prefix$_github;\n  grant select, insert, update, delete on taskcluster_integration_owners_entities to $db_user_prefix$_github;\n\n  grant select, insert, update, delete on hooks_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on last_fire_3_entities to $db_user_prefix$_hooks;\n  grant select, insert, update, delete on queues_entities to $db_user_prefix$_hooks;\n\n  grant select, insert, update, delete on indexed_tasks_entities to $db_user_prefix$_index;\n  grant select, insert, update, delete on namespaces_entities to $db_user_prefix$_index;\n\n  grant select, insert, update, delete on denylisted_notification_entities to $db_user_prefix$_notify;\n\n  grant select, insert, update, delete on cache_purges_entities to $db_user_prefix$_purge_cache;\n\n  grant select, insert, update, delete on secrets_entities to $db_user_prefix$_secrets;\n\n  grant select, insert, update, delete on access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on authorization_codes_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on github_access_token_table_entities to $db_user_prefix$_web_server;\n  grant select, insert, update, delete on session_storage_table_entities to $db_user_prefix$_web_server;\n\n  grant select, insert, update, delete on wmworker_pool_errors_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworker_pools_entities to $db_user_prefix$_worker_manager;\n  grant select, insert, update, delete on wmworkers_entities to $db_user_prefix$_worker_manager;\n\n  grant select, insert, update, delete on queue_tasks_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_artifacts_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_groups_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_members_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_group_active_sets_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_requirement_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_task_dependency_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_worker_type_entities to $db_user_prefix$_queue;\n  grant select, insert, update, delete on queue_provisioner_entities to $db_user_prefix$_queue;\nend",
      "version": 2
    },
    {
      "downgradeScript": "begin\n  revoke select, insert, update, delete on azure_queue_messages from $db_user_prefix$_queue;\n  drop table azure_queue_messages;\nend",
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (select count(*)\n  from azure_queue_messages msgs\n  where msgs.queue_name = azure_queue_count.queue_name);\nend",
          "deprecated": false,
          "description": "Count messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        },
        "azure_queue_delete": {
          "args": "queue_name text, message_id uuid, pop_receipt uuid",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.queue_name = azure_queue_delete.queue_name\n      and msgs.message_id = azure_queue_delete.message_id\n      and msgs.pop_receipt = azure_queue_delete.pop_receipt;\nend",
          "deprecated": false,
          "description": "Delete the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_delete_expired": {
          "args": "",
          "body": "begin\n  delete from azure_queue_messages msgs\n    where msgs.expires <= now();\nend",
          "deprecated": false,
          "description": "Delete all expired messages.  This is a maintenance task that should occur\nabout once an hour.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query update azure_queue_messages m1\n    set\n      pop_receipt = public.gen_random_uuid(),\n      visible = azure_queue_get.visible\n    where\n      m1.message_id in (\n        select m2.message_id from azure_queue_messages m2\n        where m2.queue_name = azure_queue_get.queue_name\n          and m2.visible <= now()\n          and m2.expires > now()\n        order by m2.inserted\n        for update skip locked\n        limit count\n    )\n    returning m1.message_id, m1.message_text, m1.pop_receipt;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        },
        "azure_queue_put": {
          "args": "queue_name text, message_text text, visible timestamp, expires timestamp",
          "body": "begin\n  insert into azure_queue_messages (\n      queue_name,\n      message_id,\n      message_text,\n      inserted,\n      visible,\n      expires\n    ) values (\n      azure_queue_put.queue_name,\n      public.gen_random_uuid(),\n      azure_queue_put.message_text,\n      now(),\n      azure_queue_put.visible,\n      azure_queue_put.expires\n    );\n  execute 'notify ' || quote_ident(queue_name);\nend",
          "deprecated": false,
          "description": "Put the given message into the given queue.  The message will not be visible until\nafter the visible timestamp, and will disappear after the expires timestamp.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        },
        "azure_queue_update": {
          "args": "queue_name text, message_text text, message_id uuid, pop_receipt uuid, visible timestamp",
          "body": "begin\n  update azure_queue_messages msgs\n    set message_text = azure_queue_update.message_text,\n      visible = azure_queue_update.visible\n    where msgs.queue_name = azure_queue_update.queue_name\n      and msgs.message_id = azure_queue_update.message_id\n      and msgs.pop_receipt = azure_queue_update.pop_receipt;\nend",
          "deprecated": false,
          "description": "Update the message identified by the given `queue_name`, `message_id` and\n`pop_receipt`, setting its `visible` and `message_text` properties as\ngiven.\n",
          "mode": "write",
          "returns": "void",
          "serviceName": "queue"
        }
      },
      "migrationScript": "begin\n  create table azure_queue_messages (\n    message_id uuid not null primary key,\n    queue_name text not null,\n    message_text text not null,\n    inserted timestamp not null,\n    visible timestamp not null, -- visible after this time\n    expires timestamp not null,  -- expired after this time\n    pop_receipt uuid -- null means not popped\n  );\n  -- 'get' operations sort by inserted within a queue\n  create index azure_queue_messages_inserted on azure_queue_messages(queue_name, inserted);\n  grant select, insert, update, delete on azure_queue_messages to $db_user_prefix$_queue;\nend",
      "version": 3
    },
    {
      "downgradeScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamp,\n    alter column visible type timestamp,\n    alter column expires type timestamp;\nend",
      "methods": {
      },
      "migrationScript": "begin\n  alter table azure_queue_messages\n    alter column inserted type timestamptz,\n    alter column visible type timestamptz,\n    alter column expires type timestamptz;\nend",
      "version": 4
    },
    {
      "methods": {
        "azure_queue_get": {
          "args": "queue_name text, visible timestamp, count integer",
          "body": "begin\n  return query\n    with updated as (\n      update azure_queue_messages m\n      set\n        pop_receipt = public.gen_random_uuid(),\n        visible = azure_queue_get.visible\n      where\n        m.message_id in (\n          select m2.message_id from azure_queue_messages m2\n          where m2.queue_name = azure_queue_get.queue_name\n            and m2.visible <= now()\n            and m2.expires > now()\n          order by m2.inserted\n          for update skip locked\n          limit count\n      )\n      returning m.inserted, m.message_id, m.message_text, m.pop_receipt\n    )\n    select\n      u.message_id, u.message_text, u.pop_receipt\n    from updated as u\n    order by u.inserted;\nend",
          "deprecated": false,
          "description": "Get up to `count` messages from the given queue, setting the `visible`\ncolumn of each to the given value.  Returns a `message_id` and\n`pop_receipt` for each one, for use with `azure_queue_delete` and\n`azure_queue_update`.\n",
          "mode": "write",
          "returns": "table (message_id uuid, message_text text, pop_receipt uuid)",
          "serviceName": "queue"
        }
      },
      "version": 5
    },
    {
      "methods": {
        "azure_queue_count": {
          "args": "queue_name text",
          "body": "begin\n  return (\n    select\n      count(*)\n    from\n      azure_queue_messages msgs\n    where\n      msgs.queue_name = azure_queue_count.queue_name\n      and msgs.expires > now()\n  );\nend",
          "deprecated": false,
          "description": "Count non-expired messages in the named queue.\n",
          "mode": "read",
          "returns": "integer",
          "serviceName": "queue"
        }
      },
      "version": 6
    },
    {
      "methods": {
        "access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select access_token_table_entities.partition_key, access_token_table_entities.row_key, access_token_table_entities.value, access_token_table_entities.version, access_token_table_entities.etag from access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if access_token_table_entities_scan.pk is not null or access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(access_token_table_entities_scan.pk);\n  end if;\n\n  if access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by access_token_table_entities.partition_key, access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "authorization_codes_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key, authorization_codes_table_entities.value, authorization_codes_table_entities.version, authorization_codes_table_entities.etag from authorization_codes_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if authorization_codes_table_entities_scan.pk is not null or authorization_codes_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if authorization_codes_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(authorization_codes_table_entities_scan.pk);\n  end if;\n\n  if authorization_codes_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(authorization_codes_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by authorization_codes_table_entities.partition_key, authorization_codes_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "cache_purges_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select cache_purges_entities.partition_key, cache_purges_entities.row_key, cache_purges_entities.value, cache_purges_entities.version, cache_purges_entities.etag from cache_purges_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if cache_purges_entities_scan.pk is not null or cache_purges_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if cache_purges_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(cache_purges_entities_scan.pk);\n  end if;\n\n  if cache_purges_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(cache_purges_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by cache_purges_entities.partition_key, cache_purges_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "purge_cache"
        },
        "clients_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select clients_entities.partition_key, clients_entities.row_key, clients_entities.value, clients_entities.version, clients_entities.etag from clients_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if clients_entities_scan.pk is not null or clients_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if clients_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(clients_entities_scan.pk);\n  end if;\n\n  if clients_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(clients_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by clients_entities.partition_key, clients_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "denylisted_notification_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key, denylisted_notification_entities.value, denylisted_notification_entities.version, denylisted_notification_entities.etag from denylisted_notification_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if denylisted_notification_entities_scan.pk is not null or denylisted_notification_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if denylisted_notification_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(denylisted_notification_entities_scan.pk);\n  end if;\n\n  if denylisted_notification_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(denylisted_notification_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by denylisted_notification_entities.partition_key, denylisted_notification_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "notify"
        },
        "github_access_token_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key, github_access_token_table_entities.value, github_access_token_table_entities.version, github_access_token_table_entities.etag from github_access_token_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if github_access_token_table_entities_scan.pk is not null or github_access_token_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if github_access_token_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(github_access_token_table_entities_scan.pk);\n  end if;\n\n  if github_access_token_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(github_access_token_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by github_access_token_table_entities.partition_key, github_access_token_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "hooks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select hooks_entities.partition_key, hooks_entities.row_key, hooks_entities.value, hooks_entities.version, hooks_entities.etag from hooks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if hooks_entities_scan.pk is not null or hooks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if hooks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(hooks_entities_scan.pk);\n  end if;\n\n  if hooks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(hooks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by hooks_entities.partition_key, hooks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "indexed_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key, indexed_tasks_entities.value, indexed_tasks_entities.version, indexed_tasks_entities.etag from indexed_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if indexed_tasks_entities_scan.pk is not null or indexed_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if indexed_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(indexed_tasks_entities_scan.pk);\n  end if;\n\n  if indexed_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(indexed_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by indexed_tasks_entities.partition_key, indexed_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "last_fire_3_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select last_fire_3_entities.partition_key, last_fire_3_entities.row_key, last_fire_3_entities.value, last_fire_3_entities.version, last_fire_3_entities.etag from last_fire_3_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if last_fire_3_entities_scan.pk is not null or last_fire_3_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if last_fire_3_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(last_fire_3_entities_scan.pk);\n  end if;\n\n  if last_fire_3_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(last_fire_3_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by last_fire_3_entities.partition_key, last_fire_3_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "namespaces_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select namespaces_entities.partition_key, namespaces_entities.row_key, namespaces_entities.value, namespaces_entities.version, namespaces_entities.etag from namespaces_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if namespaces_entities_scan.pk is not null or namespaces_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if namespaces_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(namespaces_entities_scan.pk);\n  end if;\n\n  if namespaces_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(namespaces_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by namespaces_entities.partition_key, namespaces_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "index"
        },
        "queue_artifacts_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key, queue_artifacts_entities.value, queue_artifacts_entities.version, queue_artifacts_entities.etag from queue_artifacts_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_artifacts_entities_scan.pk is not null or queue_artifacts_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_artifacts_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_artifacts_entities_scan.pk);\n  end if;\n\n  if queue_artifacts_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_artifacts_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_artifacts_entities.partition_key, queue_artifacts_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_provisioner_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key, queue_provisioner_entities.value, queue_provisioner_entities.version, queue_provisioner_entities.etag from queue_provisioner_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_provisioner_entities_scan.pk is not null or queue_provisioner_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_provisioner_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_provisioner_entities_scan.pk);\n  end if;\n\n  if queue_provisioner_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_provisioner_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_provisioner_entities.partition_key, queue_provisioner_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_dependency_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key, queue_task_dependency_entities.value, queue_task_dependency_entities.version, queue_task_dependency_entities.etag from queue_task_dependency_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_dependency_entities_scan.pk is not null or queue_task_dependency_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_dependency_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_dependency_entities_scan.pk);\n  end if;\n\n  if queue_task_dependency_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_dependency_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_dependency_entities.partition_key, queue_task_dependency_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_active_sets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key, queue_task_group_active_sets_entities.value, queue_task_group_active_sets_entities.version, queue_task_group_active_sets_entities.etag from queue_task_group_active_sets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_active_sets_entities_scan.pk is not null or queue_task_group_active_sets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.pk);\n  end if;\n\n  if queue_task_group_active_sets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_active_sets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_active_sets_entities.partition_key, queue_task_group_active_sets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_group_members_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key, queue_task_group_members_entities.value, queue_task_group_members_entities.version, queue_task_group_members_entities.etag from queue_task_group_members_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_group_members_entities_scan.pk is not null or queue_task_group_members_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_group_members_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_group_members_entities_scan.pk);\n  end if;\n\n  if queue_task_group_members_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_group_members_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_group_members_entities.partition_key, queue_task_group_members_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_groups_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key, queue_task_groups_entities.value, queue_task_groups_entities.version, queue_task_groups_entities.etag from queue_task_groups_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_groups_entities_scan.pk is not null or queue_task_groups_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_groups_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_groups_entities_scan.pk);\n  end if;\n\n  if queue_task_groups_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_groups_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_groups_entities.partition_key, queue_task_groups_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_task_requirement_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key, queue_task_requirement_entities.value, queue_task_requirement_entities.version, queue_task_requirement_entities.etag from queue_task_requirement_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_task_requirement_entities_scan.pk is not null or queue_task_requirement_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_task_requirement_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_task_requirement_entities_scan.pk);\n  end if;\n\n  if queue_task_requirement_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_task_requirement_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_task_requirement_entities.partition_key, queue_task_requirement_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_tasks_entities.partition_key, queue_tasks_entities.row_key, queue_tasks_entities.value, queue_tasks_entities.version, queue_tasks_entities.etag from queue_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_tasks_entities_scan.pk is not null or queue_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_tasks_entities_scan.pk);\n  end if;\n\n  if queue_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_tasks_entities.partition_key, queue_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_entities.partition_key, queue_worker_entities.row_key, queue_worker_entities.value, queue_worker_entities.version, queue_worker_entities.etag from queue_worker_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_entities_scan.pk is not null or queue_worker_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_entities_scan.pk);\n  end if;\n\n  if queue_worker_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_entities.partition_key, queue_worker_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queue_worker_type_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key, queue_worker_type_entities.value, queue_worker_type_entities.version, queue_worker_type_entities.etag from queue_worker_type_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queue_worker_type_entities_scan.pk is not null or queue_worker_type_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queue_worker_type_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queue_worker_type_entities_scan.pk);\n  end if;\n\n  if queue_worker_type_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queue_worker_type_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queue_worker_type_entities.partition_key, queue_worker_type_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "queue"
        },
        "queues_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select queues_entities.partition_key, queues_entities.row_key, queues_entities.value, queues_entities.version, queues_entities.etag from queues_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if queues_entities_scan.pk is not null or queues_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if queues_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(queues_entities_scan.pk);\n  end if;\n\n  if queues_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(queues_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by queues_entities.partition_key, queues_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "hooks"
        },
        "roles_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select roles_entities.partition_key, roles_entities.row_key, roles_entities.value, roles_entities.version, roles_entities.etag from roles_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if roles_entities_scan.pk is not null or roles_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if roles_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(roles_entities_scan.pk);\n  end if;\n\n  if roles_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(roles_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by roles_entities.partition_key, roles_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "auth"
        },
        "secrets_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select secrets_entities.partition_key, secrets_entities.row_key, secrets_entities.value, secrets_entities.version, secrets_entities.etag from secrets_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if secrets_entities_scan.pk is not null or secrets_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if secrets_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(secrets_entities_scan.pk);\n  end if;\n\n  if secrets_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(secrets_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by secrets_entities.partition_key, secrets_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "secrets"
        },
        "session_storage_table_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select session_storage_table_entities.partition_key, session_storage_table_entities.row_key, session_storage_table_entities.value, session_storage_table_entities.version, session_storage_table_entities.etag from session_storage_table_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if session_storage_table_entities_scan.pk is not null or session_storage_table_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if session_storage_table_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(session_storage_table_entities_scan.pk);\n  end if;\n\n  if session_storage_table_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(session_storage_table_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by session_storage_table_entities.partition_key, session_storage_table_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "web_server"
        },
        "taskcluster_check_runs_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key, taskcluster_check_runs_entities.value, taskcluster_check_runs_entities.version, taskcluster_check_runs_entities.etag from taskcluster_check_runs_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_check_runs_entities_scan.pk is not null or taskcluster_check_runs_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_check_runs_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_check_runs_entities_scan.pk);\n  end if;\n\n  if taskcluster_check_runs_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_check_runs_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_check_runs_entities.partition_key, taskcluster_check_runs_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_checks_to_tasks_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key, taskcluster_checks_to_tasks_entities.value, taskcluster_checks_to_tasks_entities.version, taskcluster_checks_to_tasks_entities.etag from taskcluster_checks_to_tasks_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null or taskcluster_checks_to_tasks_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.pk);\n  end if;\n\n  if taskcluster_checks_to_tasks_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_checks_to_tasks_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_checks_to_tasks_entities.partition_key, taskcluster_checks_to_tasks_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_github_builds_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key, taskcluster_github_builds_entities.value, taskcluster_github_builds_entities.version, taskcluster_github_builds_entities.etag from taskcluster_github_builds_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_github_builds_entities_scan.pk is not null or taskcluster_github_builds_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_github_builds_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_github_builds_entities_scan.pk);\n  end if;\n\n  if taskcluster_github_builds_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_github_builds_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_github_builds_entities.partition_key, taskcluster_github_builds_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "taskcluster_integration_owners_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key, taskcluster_integration_owners_entities.value, taskcluster_integration_owners_entities.version, taskcluster_integration_owners_entities.etag from taskcluster_integration_owners_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if taskcluster_integration_owners_entities_scan.pk is not null or taskcluster_integration_owners_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.pk);\n  end if;\n\n  if taskcluster_integration_owners_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(taskcluster_integration_owners_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by taskcluster_integration_owners_entities.partition_key, taskcluster_integration_owners_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "github"
        },
        "wmworker_pool_errors_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key, wmworker_pool_errors_entities.value, wmworker_pool_errors_entities.version, wmworker_pool_errors_entities.etag from wmworker_pool_errors_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pool_errors_entities_scan.pk is not null or wmworker_pool_errors_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pool_errors_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pool_errors_entities_scan.pk);\n  end if;\n\n  if wmworker_pool_errors_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pool_errors_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pool_errors_entities.partition_key, wmworker_pool_errors_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworker_pools_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key, wmworker_pools_entities.value, wmworker_pools_entities.version, wmworker_pools_entities.etag from wmworker_pools_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworker_pools_entities_scan.pk is not null or wmworker_pools_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworker_pools_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworker_pools_entities_scan.pk);\n  end if;\n\n  if wmworker_pools_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworker_pools_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworker_pools_entities.partition_key, wmworker_pools_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        },
        "wmworkers_entities_scan": {
          "args": "pk text, rk text, condition text, size integer, page integer",
          "body": "declare\n  sql text := 'select wmworkers_entities.partition_key, wmworkers_entities.row_key, wmworkers_entities.value, wmworkers_entities.version, wmworkers_entities.etag from wmworkers_entities';\n  partition_key_var text;\n  row_key_var text;\nbegin\n  if wmworkers_entities_scan.pk is not null or wmworkers_entities_scan.rk is not null or condition is not null then\n    sql := sql || ' where ';\n  end if;\n\n  if wmworkers_entities_scan.pk is not null then\n    partition_key_var := 'partition_key = ' || quote_literal(wmworkers_entities_scan.pk);\n  end if;\n\n  if wmworkers_entities_scan.rk is not null then\n    row_key_var := 'row_key = ' || quote_literal(wmworkers_entities_scan.rk);\n  end if;\n\n  sql := sql || concat_ws(' and ', partition_key_var, row_key_var, condition);\n  sql := sql || ' order by wmworkers_entities.partition_key, wmworkers_entities.row_key';\n\n  if size is not null and size > 0 then\n    sql := sql || ' limit ' || size + 1;\n\n    if page is not null and page > 0 then\n      sql := sql || ' offset ' || page;\n    end if;\n  end if;\n\n  return query execute sql;\nend",
          "deprecated": false,
          "description": "See taskcluster-lib-entities",
          "mode": "read",
          "returns": "table (partition_key text, row_key text, value jsonb, version integer, etag uuid)",
          "serviceName": "worker_manager"
        }
      },
      "version": 7
    }
  ]
}